function mousedown(t) {
	startX = t.clientX, startY = t.clientY, startLeft = getNum(getStyle(measureBox, "left")), startTop = getNum(getStyle(measureBox, "top")), draggingbox = !0
}
function mouseup() {
	draggingbox = !1
}
function mousemove(t) {
	if (draggingbox) {
		var e = startLeft + t.clientX - startX,
			n = startTop + t.clientY - startY;
		measureBox.style.left = e + "px", measureBox.style.top = n + "px"
	}
}
function getNum(t) {
	return parseFloat(t) ? parseFloat(t) : 0
}
function getStyle(t, e) {
	return t.currentStyle ? t.currentStyle[e] : getComputedStyle(t, null)[e]
}
function clearAll() {
	viewer.entities.remove(d_polyline), viewer.entities.remove(d_polyline2), viewer.entities.remove(d_polygon), viewer.entities.remove(billboard), viewer.entities.remove(startPoint), clearText(), positions = [], terrainSamplePositions = [], movingPolyline.removeAll(), pointCollection.removeAll(), polygonPolyline.removeAll()
}
function toggleMouse(t) {
	t ? (scene.screenSpaceCameraController.enableRotate = !0, scene.screenSpaceCameraController.enableTranslate = !0, scene.screenSpaceCameraController.enableZoom = !0, scene.screenSpaceCameraController.enableTilt = !0, scene.screenSpaceCameraController.enableLook = !0) : (scene.screenSpaceCameraController.enableRotate = !1, scene.screenSpaceCameraController.enableTranslate = !1, scene.screenSpaceCameraController.enableZoom = !1, scene.screenSpaceCameraController.enableTilt = !1, scene.screenSpaceCameraController.enableLook = !1)
}
function toggleEdit(t) {
	t ? (editing = !0, drawing = !1) : editing = !1
}
function morphStart() {
	startSceneMode = camera._mode;
	var t = document.getElementById("boxBody_tit").getElementsByTagName("p");
	startSceneMode == Cesium.SceneMode.SCENE2D && (t[4].className = "topC0", t[5].className = "topC0", t[4].onclick = function() {
		changeNav(this.value)
	}, t[5].onclick = function() {
		changeNav(this.value)
	})
}
function morphComplete() {
	var t = document.getElementById("boxBody_tit").getElementsByTagName("p");
	if (camera._mode == Cesium.SceneMode.SCENE2D) for (var e = 1; e < t.length; e++)"topC1" == t[e].className && e < 4 ? (t[4].className = "disable", t[5].className = "disable", t[4].onclick = "", t[5].onclick = "") : "topC1" == t[e].className && e > 3 && (changeNav(1), t[4].className = "disable", t[5].className = "disable", t[4].onclick = "", t[5].onclick = "")
}
function startDrawing() {
	globe.depthTestAgainstTerrain = !1, leftClick = viewer.screenSpaceEventHandler.getInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK), dbClick = viewer.screenSpaceEventHandler.getInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK), viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK), viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK), handler.setInputAction(function(t) {
		if (camera._mode === Cesium.SceneMode.SCENE3D) {
			var e = scene.pickPosition(t.position),
				n = camera.getPickRay(t.position),
				i = globe.pick(n, scene);
			if (scene.pickPositionSupported && (Cesium.defined(e) || Cesium.defined(i))) {
				if (1 == flag) if (console.log("flag 1"), drawing) clear(), positions.push(i), draw(positions), calc_1(positions), drawing = !drawing;
				else if (editing) if (0 == vertexMoving) {
					var o = scene.pick(t.position);
					Cesium.defined(o) && "point" == o.id && (movingindex = o.primitive._index, vertexMoving = !vertexMoving)
				} else clear(), draw(positions), calc_1(positions), vertexMoving = !vertexMoving, movingindex = -1;
				else clear(), positions = [], positions.push(i), drawSP(i), drawing = !drawing;
				else 2 == flag ? (console.log("flag 2"), drawing ? (clear(), positions.push(i), draw(positions), calc_2(positions)) : editing ? 0 == vertexMoving ? (o = scene.pick(t.position), Cesium.defined(o) && "point" == o.id && (movingindex = o.primitive._index, vertexMoving = !vertexMoving)) : (clear(), draw(positions), calc_2(positions), drawProfile(positions), vertexMoving = !vertexMoving, movingindex = -1) : (clear(), positions = [], positions.push(i), drawSP(i), drawing = !drawing)) : 3 == flag ? (console.log("flag 3"), drawing ? (clear(), positions.push(i), drawP(positions), calc_3(positions)) : editing ? 0 == vertexMoving ? (o = scene.pick(t.position), Cesium.defined(o) && "point" == o.id && (movingindex = o.primitive._index, vertexMoving = !vertexMoving)) : (clear(), drawP(positions), calc_3(positions), vertexMoving = !vertexMoving, movingindex = -1) : (clear(), positions = [], positions.push(i), drawSP(i), drawing = !drawing)) : 4 == flag ? (console.log("flag 4"), drawing ? (clear(), positions.push(e), draw(positions), calc_4(positions)) : editing ? 0 == vertexMoving ? (o = scene.pick(t.position), Cesium.defined(o) && "point" == o.id && (movingindex = o.primitive._index, vertexMoving = !vertexMoving)) : (clear(), draw(positions), calc_4(positions), vertexMoving = !vertexMoving, movingindex = -1) : (clear(), positions = [], positions.push(e), drawSP(e), drawing = !drawing)) : 5 == flag && (console.log("flag 5"), drawing ? (clear(), positions.push(e), drawP3(positions), calc_5(positions)) : editing ? 0 == vertexMoving ? (o = scene.pick(t.position), Cesium.defined(o) && "point" == o.id && (movingindex = o.primitive._index, vertexMoving = !vertexMoving)) : (clear(), drawP3(positions), calc_5(positions), vertexMoving = !vertexMoving, movingindex = -1) : (clear(), positions = [], positions.push(e), drawSP(e), drawing = !drawing));
				changeCursor(drawing)
			}
		} else if (camera._mode === Cesium.SceneMode.SCENE2D) {
			var r = camera.pickEllipsoid(t.position, ellipsoid);
			if (Cesium.defined(r)) {
				if (1 == flag) if (console.log("flag 1"), drawing) console.log(2), clear(), positions.push(r), draw2d(positions), calc_1(positions), drawing = !drawing;
				else if (editing) if (0 == vertexMoving) {
					var o = scene.pick(t.position);
					Cesium.defined(o) && "point" == o.id && (movingindex = o.primitive._index, vertexMoving = !vertexMoving)
				} else clear(), draw2d(positions), calc_1(positions), vertexMoving = !vertexMoving, movingindex = -1;
				else console.log(1), clear(), positions = [], positions.push(r), drawSP(r), drawing = !drawing;
				else 2 == flag ? (console.log("flag 2"), drawing ? (clear(), positions.push(r), draw2d(positions), calc_2(positions)) : editing ? 0 == vertexMoving ? (o = scene.pick(t.position), Cesium.defined(o) && "point" == o.id && (movingindex = o.primitive._index, vertexMoving = !vertexMoving)) : (clear(), draw2d(positions), calc_2(positions), drawProfile(positions), vertexMoving = !vertexMoving, movingindex = -1) : (clear(), positions = [], positions.push(r), drawSP(r), drawing = !drawing)) : 3 == flag && (console.log("flag 3"), drawing ? (clear(), positions.push(r), drawP2d(positions), calc_3(positions)) : editing ? 0 == vertexMoving ? (o = scene.pick(t.position), Cesium.defined(o) && "point" == o.id && (movingindex = o.primitive._index, vertexMoving = !vertexMoving)) : (clear(), drawP2d(positions), calc_3(positions), vertexMoving = !vertexMoving, movingindex = -1) : (clear(), positions = [], positions.push(r), drawSP(r), drawing = !drawing));
				changeCursor(drawing)
			}
		} else camera._mode === Cesium.SceneMode.COLUMBUS_VIEW
	}, Cesium.ScreenSpaceEventType.LEFT_CLICK), handler.setInputAction(function(t) {
		if (camera._mode === Cesium.SceneMode.SCENE3D) {
			var e = scene.pickPosition(t.position),
				n = camera.getPickRay(t.position),
				i = globe.pick(n, scene);
			scene.pickPositionSupported && (Cesium.defined(e) || Cesium.defined(i)) && (1 == flag || (2 == flag ? drawing && (clear(), positions.pop(), draw(positions), calc_2(positions), drawProfile(positions), drawing = !drawing) : 3 == flag ? drawing && (clear(), positions.pop(), drawP(positions), calc_3(positions), drawing = !drawing) : 4 == flag ? drawing && (clear(), positions.pop(), draw(positions), calc_4(positions), drawing = !drawing) : 5 == flag && drawing && (clear(), positions.pop(), drawP3(positions), calc_5(positions), drawing = !drawing)), changeCursor(drawing))
		} else if (camera._mode === Cesium.SceneMode.SCENE2D) {
			var o = camera.pickEllipsoid(t.position, ellipsoid);
			Cesium.defined(o) && (1 == flag || (2 == flag ? drawing && (clear(), positions.pop(), draw2d(positions), calc_2(positions), drawProfile(positions), drawing = !drawing) : 3 == flag && drawing && (clear(), positions.pop(), drawP2d(positions), calc_3(positions), drawing = !drawing)), changeCursor(drawing))
		}
	}, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK), handler.setInputAction(function(t) {
		if (camera._mode === Cesium.SceneMode.SCENE3D) {
			var e = scene.pickPosition(t.endPosition),
				n = camera.getPickRay(t.endPosition),
				i = globe.pick(n, scene);
			if (scene.pickPositionSupported && (Cesium.defined(e) || Cesium.defined(i))) if (1 == flag) {
				if (drawing) {
					var o = positions.length - 1;
					moveDraw1(positions[o], i)
				} else if (editing) {
					var r = scene.pick(t.endPosition);
					Cesium.defined(r) && "point" == r.id ? scene.canvas.style.cursor = "pointer" : scene.canvas.style.cursor = "auto", vertexMoving && (clear(), positions = editMoveDraw(movingindex, positions, i), draw(positions), calc_1(positions))
				}
			} else 2 == flag ? drawing ? (o = positions.length - 1, moveDraw1(positions[o], i)) : editing && (r = scene.pick(t.endPosition), Cesium.defined(r) && "point" == r.id ? scene.canvas.style.cursor = "pointer" : scene.canvas.style.cursor = "auto", vertexMoving && (console.log("start vertexMoving"), clear(), positions = editMoveDraw(movingindex, positions, i), draw(positions), calc_2(positions))) : 3 == flag ? drawing ? positions.length < 2 ? moveDraw1(positions[0], i) : (clear(), positions.push(i), drawP(positions), positions.pop()) : editing && (r = scene.pick(t.endPosition), Cesium.defined(r) && "point" == r.id ? scene.canvas.style.cursor = "pointer" : scene.canvas.style.cursor = "auto", vertexMoving && (console.log("start vertexMoving"), clear(), positions = editMoveDraw(movingindex, positions, i), drawP(positions), calc_3(positions))) : 4 == flag ? drawing ? (o = positions.length - 1, moveDraw3(positions[o], e)) : editing && (r = scene.pick(t.endPosition), Cesium.defined(r) && "point" == r.id ? scene.canvas.style.cursor = "pointer" : scene.canvas.style.cursor = "auto", vertexMoving && (console.log("start vertexMoving"), clear(), positions = editMoveDraw(movingindex, positions, e), draw(positions), calc_4(positions))) : 5 == flag && (drawing ? (o = positions.length - 1, positions.length < 3 ? moveDraw3(positions[o], e) : moveDraw4(positions[o], e, positions[0])) : editing && (r = scene.pick(t.endPosition), Cesium.defined(r) && "point" == r.id ? scene.canvas.style.cursor = "pointer" : scene.canvas.style.cursor = "auto", vertexMoving && (console.log("start vertexMoving"), clear(), positions = editMoveDraw(movingindex, positions, e), drawP3(positions), calc_5(positions))))
		} else if (camera._mode === Cesium.SceneMode.SCENE2D) {
			var s = camera.pickEllipsoid(t.endPosition, ellipsoid);
			if (Cesium.defined(s)) if (1 == flag) {
				if (drawing) {
					console.log(3);
					var o = positions.length - 1;
					moveDraw2d(positions[o], s)
				} else if (editing) {
					var r = scene.pick(t.endPosition);
					Cesium.defined(r) && "point" == r.id ? scene.canvas.style.cursor = "pointer" : scene.canvas.style.cursor = "auto", vertexMoving && (clear(), positions = editMoveDraw(movingindex, positions, s), draw2d(positions), calc_1(positions))
				}
			} else 2 == flag ? drawing ? (o = positions.length - 1, moveDraw2d(positions[o], s)) : editing && (r = scene.pick(t.endPosition), Cesium.defined(r) && "point" == r.id ? scene.canvas.style.cursor = "pointer" : scene.canvas.style.cursor = "auto", vertexMoving && (console.log("start vertexMoving"), clear(), positions = editMoveDraw(movingindex, positions, s), draw2d(positions), calc_2(positions))) : 3 == flag && (drawing ? positions.length < 2 ? moveDraw2d(positions[0], s) : (clear(), positions.push(s), drawP2d(positions), positions.pop()) : editing && (r = scene.pick(t.endPosition), Cesium.defined(r) && "point" == r.id ? scene.canvas.style.cursor = "pointer" : scene.canvas.style.cursor = "auto", vertexMoving && (console.log("start vertexMoving"), clear(), positions = editMoveDraw(movingindex, positions, s), drawP2d(positions), calc_3(positions))))
		}
	}, Cesium.ScreenSpaceEventType.MOUSE_MOVE)
}
function stopDrawing() {
	handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK), handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK), handler.setInputAction(leftClick, Cesium.ScreenSpaceEventType.LEFT_CLICK), handler.setInputAction(dbClick, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK)
}
function clear() {
	viewer.entities.remove(d_polyline), viewer.entities.remove(d_polyline2), viewer.entities.remove(d_polygon), viewer.entities.remove(billboard), viewer.entities.remove(startPoint), movingPolyline.removeAll(), polygonPolyline.removeAll(), pointCollection.removeAll()
}
function changeCursor(t) {
	t ? scene.canvas.style.cursor = "crosshair" : scene.canvas.style.cursor = "auto"
}
function drawSP(t) {
	startPoint = viewer.entities.add({
		position: t,
		point: {
			color: Cesium.Color.RED,
			pixelSize: 8
		}
	})
}
function lineCut(t, e) {
	var n = Cesium.Cartesian3.angleBetween(t, e);
	if (Cesium.defined(n) && n >= 10 * Cesium.Math.RADIANS_PER_DEGREE) {
		for (var i = Cesium.Cartographic.fromCartesian(t), o = Cesium.Cartographic.fromCartesian(e), r = 10, s = {
			type: "Feature",
			geometry: {
				type: "LineString",
				coordinates: [
					[Cesium.Math.toDegrees(i.longitude), Cesium.Math.toDegrees(i.latitude)],
					[Cesium.Math.toDegrees(o.longitude), Cesium.Math.toDegrees(o.latitude)]
				]
			}
		}, a = turf.lineDistance(s, "kilometers"), l = [], u = 0; u <= r; u++) {
			var p = turf.along(s, a / r * u, "kilometers"),
				h = p.geometry.coordinates[0],
				c = p.geometry.coordinates[1],
				g = Cesium.Cartesian3.fromDegrees(h, c);
			l.push(g)
		}
		return l
	}
	return [t, e]
}
function lineCut_Mercator(t) {
	for (var e = 10, n = [], i = 0; i < t.length - 1; i++) {
		var o = Cesium.Cartesian3.angleBetween(t[i], t[i + 1]),
			r = Cesium.Cartographic.fromCartesian(t[i]),
			s = Cesium.Cartographic.fromCartesian(t[i + 1]);
		if (Cesium.defined(o) && o >= 10 * Cesium.Math.RADIANS_PER_DEGREE) if (r.longitude != s.longitude && r.latitude != s.latitude) for (var a, l, u = Math.log(Math.tan(s.latitude) + 1 / Math.cos(s.latitude)), p = Math.log(Math.tan(r.latitude) + 1 / Math.cos(r.latitude)), h = (s.longitude - r.longitude) / (u - p), o = (Math.atan(h), r.longitude - h * p), c = r.latitude, g = s.latitude - r.latitude, d = g / e, f = 0; f < e; f++) a = c + f * d, l = o + h * Math.log(Math.tan(a) + 1 / Math.cos(a)), n.push(l), n.push(a);
		else n.push(r.longitude), n.push(r.latitude);
		else n.push(r.longitude), n.push(r.latitude)
	}
	return n.push(s.longitude), n.push(s.latitude), n
}
function moveDraw1(t, e) {
	var n = lineCut(t, e),
		i = Cesium.Material.fromType("Color", {
			color: 1 == flag || 3 == flag ? Cesium.Color.BLUE : Cesium.Color.YELLOW
		});
	movingPolyline.removeAll(), movingPolyline.add({
		positions: n,
		material: i,
		width: 3
	})
}
function moveDraw2d(t, e) {
	if (console.log("moveDraw2d start"), !t.equals(e)) {
		var n = lineCut_Mercator([t, e]),
			i = Cesium.Material.fromType("Color", {
				color: 1 == flag || 3 == flag ? Cesium.Color.BLUE : Cesium.Color.YELLOW
			});
		movingPolyline.removeAll(), movingPolyline.add({
			positions: Cesium.Cartesian3.fromRadiansArray(n),
			material: i,
			width: 3
		}), console.log("moveDraw2d stop")
	}
}
function drawVertices(t) {
	for (var e = 0; e < t.length; e++) pointCollection.add({
		id: "point",
		position: t[e],
		pixelSize: 8,
		color: Cesium.Color.RED
	})
}
function moveDraw3(t, e) {
	var n = Cesium.Material.fromType("Color", {
		color: Cesium.Color.YELLOW
	});
	movingPolyline.removeAll(), movingPolyline.add({
		positions: [t, e],
		material: n,
		width: 3
	})
}
function moveDraw4(t, e, n) {
	var i = Cesium.Material.fromType("Color", {
		color: Cesium.Color.YELLOW
	});
	movingPolyline.removeAll(), movingPolyline.add({
		positions: [t, e, n],
		material: i,
		width: 3
	})
}
function editMoveDraw(t, e, n) {
	return 0 == t ? e[0] = n : t == e.length - 1 ? e[e.length - 1] = n : e[t] = n, e
}
function draw(t) {
	drawVertices(t), d_polyline = viewer.entities.add({
		polyline: {
			positions: new Cesium.CallbackProperty(function() {
				return t
			}, (!1)),
			material: 1 == flag ? Cesium.Color.BLUE : Cesium.Color.YELLOW,
			width: 3
		}
	})
}
function draw2d(t) {
	drawVertices(t), d_polyline = viewer.entities.add({
		polyline: {
			positions: new Cesium.CallbackProperty(function() {
				return Cesium.Cartesian3.fromRadiansArray(lineCut_Mercator(t))
			}, (!1)),
			material: 1 == flag ? Cesium.Color.BLUE : Cesium.Color.YELLOW,
			width: 3
		}
	}), console.log("draw2d")
}
function drawP(t) {
	for (var e = 0; e < t.length; e++) {
		var n = Cesium.Material.fromType("Color", {
			color: Cesium.Color.BLUE
		});
		if (e == t.length - 1) {
			var i = lineCut(t[e], t[0]);
			polygonPolyline.add({
				positions: i,
				material: n,
				width: 3
			})
		} else i = lineCut(t[e], t[e + 1]), polygonPolyline.add({
			positions: i,
			material: n,
			width: 3
		})
	}
	drawVertices(t)
}
function drawP2d(t) {
	var e = Cesium.Material.fromType("Color", {
		color: Cesium.Color.BLUE
	}),
		n = Cesium.Material.fromType("Color", {
			color: Cesium.Color.BLUE
		}),
		i = t.length,
		o = Cesium.Cartesian3.fromRadiansArray(lineCut_Mercator([t[i - 1], t[0]]));
	polygonPolyline.add({
		positions: o,
		material: e,
		width: 3
	});
	var r = Cesium.Cartesian3.fromRadiansArray(lineCut_Mercator(t));
	polygonPolyline.add({
		positions: r,
		material: n,
		width: 3
	}), drawVertices(t)
}
function drawP3(t) {
	d_polyline = viewer.entities.add({
		polyline: {
			positions: new Cesium.CallbackProperty(function() {
				return t
			}, (!1)),
			material: Cesium.Color.YELLOW,
			width: 3
		}
	}), t.length > 2 && (d_polyline2 = viewer.entities.add({
		polyline: {
			positions: new Cesium.CallbackProperty(function() {
				return [t[0], t[t.length - 1]]
			}, (!1)),
			material: Cesium.Color.YELLOW,
			width: 3
		}
	})), drawVertices(t)
}
function gcDist(t, e) {
	var n = Cesium.Cartographic.fromCartesian(t),
		i = Cesium.Cartographic.fromCartesian(e),
		o = n.latitude,
		r = i.latitude,
		s = n.longitude,
		a = i.longitude,
		l = Math.abs(o - r),
		u = Math.abs(s - a),
		p = Math.sin(l / 2) * Math.sin(l / 2) + Math.cos(o) * Math.cos(r) * Math.sin(u / 2) * Math.sin(u / 2),
		h = 2 * Math.asin(Math.sqrt(p)),
		c = R * h;
	return {
		angle: h,
		dist: c
	}
}
function calc_1(t) {
	var e, n, i, o, r = t.length,
		s = 0,
		a = 0,
		l = Cesium.Cartographic.fromCartesian(t[0]);
	n = geoProj.project(l), n.height = 0, o = webMercatorProj.project(l), o.height = 0;
	for (var u = 0; u < r - 1; u++) {
		var p = Cesium.Cartographic.fromCartesian(t[u + 1]);
		p.height = 0, e = n, n = geoProj.project(p), i = o, o = webMercatorProj.project(p), s += Cesium.Cartesian3.distance(e, n), a += gcDist(t[u], t[u + 1]).dist
	}
	var h = 0,
		c = Cesium.Cartographic.fromCartesian(t[0]),
		g = Cesium.Cartographic.fromCartesian(t[1]),
		d = Cesium.Cartesian3.angleBetween(t[0], t[1]),
		f = Math.sqrt(1 - Math.cos(d) * Math.cos(d));
	return h = Math.asin(Math.sin(Math.PI / 2 - g.latitude) * Math.sin(g.longitude - c.longitude) / f), h = Math.abs(g.longitude - c.longitude) < Math.PI ? g.longitude > c.longitude && g.latitude > c.latitude ? h : g.longitude <= c.longitude && g.latitude > c.latitude ? 2 * Math.PI + h : Math.PI - h : g.longitude < c.longitude && g.latitude > c.latitude ? h : g.longitude >= c.longitude && g.latitude > c.latitude ? 2 * Math.PI + h : Math.PI - h, h = Cesium.Math.toDegrees(h), unitDetect_1(document.getElementById("sb_gclength").value, "gclength", a), unitDetect_1(document.getElementById("sb_geoplength").value, "geoplength", s), document.getElementById("headingangle").innerHTML = h.toFixed(2), console.log("Azimuth: " + Cesium.Math.toDegrees(h)), console.log("GeographicProjection distance: " + s), console.log("Great Circle distance: " + a), [a, s, h]
}
function calc_2(t) {
	for (var e = t.length, n = 0, i = 0; i < e - 1; i++) {
		var o = Cesium.Cartographic.fromCartesian(t[i]),
			r = Cesium.Cartographic.fromCartesian(t[i + 1]),
			s = o.latitude,
			a = r.latitude,
			l = o.longitude,
			u = r.longitude,
			p = Math.abs(s - a),
			h = Math.abs(l - u),
			c = Math.sin(p / 2) * Math.sin(p / 2) + Math.cos(s) * Math.cos(a) * Math.sin(h / 2) * Math.sin(h / 2),
			g = 2 * Math.asin(Math.sqrt(c));
		n += R * g
	}
	return console.log("Great Circle distance: " + n), unitDetect_1(document.getElementById("sb_pathlength").value, "pathlength", n), n
}
function calc_3(t) {
	for (var e, n = [], i = 0; i < t.length; i++) e = Cesium.Cartographic.fromCartesian(t[i]), n.push([Cesium.Math.toDegrees(e.longitude), Cesium.Math.toDegrees(e.latitude)]);
	e = Cesium.Cartographic.fromCartesian(t[0]), n.push([Cesium.Math.toDegrees(e.longitude), Cesium.Math.toDegrees(e.latitude)]);
	var o = {
		type: "Feature",
		geometry: {
			type: "Polygon",
			coordinates: [n]
		}
	},
		r = {
			type: "Feature",
			geometry: {
				type: "LineString",
				coordinates: n
			}
		},
		s = turf.area(o),
		a = 1e3 * turf.lineDistance(r, "kilometers");
	return unitDetect_1(document.getElementById("sb_perimeter").value, "perimeter", a), unitDetect_2(document.getElementById("sb_globeA").value, "globeA", s), console.log("turf area: " + s), console.log("turf length: " + a), [s, a]
}
function calc_4(t) {
	for (var e = t.length, n = 0, i = 0; i < e - 1; i++) n += Cesium.Cartesian3.distance(t[i], t[i + 1]);
	return console.log("Cartesian3 distance: " + n), unitDetect_1(document.getElementById("sb_3DLength").value, "3DLength", n), n
}
function calc_5_1(t) {
	var e = t.length,
		n = t[0],
		o = 0;
	for (i = 1; i < e - 1; i++) {
		var r = t[i],
			s = t[i + 1],
			a = vec3sub(r, n),
			l = vec3sub(s, n),
			u = vec3cross(a, l);
		o += vec3mod(u)
	}
	o /= 2;
	var p = 0;
	for (i = 0; i < e - 1; i++) p += Cesium.Cartesian3.distance(t[i], t[i + 1]);
	return p += Cesium.Cartesian3.distance(t[e - 1], t[0]), console.log("Cartesian3 distance: " + p), unitDetect_1(document.getElementById("sb_3DPerimeter").value, "3DPerimeter", p), console.log("Cartesian3 Area: " + o), unitDetect_2(document.getElementById("sb_3DArea").value, "3DArea", o), [o, p]
}
function calc_5(t) {
	var e = 1,
		n = 0,
		o = new Cesium.Cartesian3,
		r = !1,
		s = t[0];
	if (t.length > 2) {
		for (i = 1; i < t.length - 1; i++) {
			var a = t[i],
				l = t[i + 1],
				u = vec3sub(a, s),
				p = vec3sub(l, s),
				h = vec3cross(u, p),
				c = Cesium.Cartesian3.angleBetween(h, o) / Math.PI * 180;
			console.log(c), Math.abs(c - 0) < e || Math.abs(c - 180) < e || !c ? (o = vec3add(o, h), r = !0) : (n += vec3mod(o), o = h, r = !1)
		}
		n += vec3mod(r ? o : h), n /= 2
	}
	var g = 0;
	for (i = 0; i < t.length - 1; i++) g += Cesium.Cartesian3.distance(t[i], t[i + 1]);
	return g += Cesium.Cartesian3.distance(t[t.length - 1], t[0]), console.log("Cartesian3 distance: " + g), unitDetect_1(document.getElementById("sb_3DPerimeter").value, "3DPerimeter", g), console.log("Cartesian3 Area: " + n), unitDetect_2(document.getElementById("sb_3DArea").value, "3DArea", n), [n, g]
}
function vec3add(t, e) {
	var n = new Cesium.Cartesian3;
	return n.x = t.x + e.x, n.y = t.y + e.y, n.z = t.z + e.z, n
}
function vec3sub(t, e) {
	var n = new Cesium.Cartesian3;
	return n.x = t.x - e.x, n.y = t.y - e.y, n.z = t.z - e.z, n
}
function vec3cross(t, e) {
	var n = t.x,
		i = t.y,
		o = t.z,
		r = e.x,
		s = e.y,
		a = e.z,
		l = i * a - o * s,
		u = o * r - n * a,
		p = n * s - i * r,
		h = new Cesium.Cartesian3;
	return h.x = l, h.y = u, h.z = p, h
}
function vec3mod(t) {
	return Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z)
}
function maxMeanMin(t) {
	for (var e = -1e3, n = 1e7, i = 0, o = 0; o < t.length; o++) i += t[o], e = Math.max(e, t[o]), n = Math.min(n, t[o]);
	var r = i / t.length;
	return [e, r, n]
}
function windowResize() {
	var t = document.body.clientWidth;
	charts.setAttribute("style", "width:" + .99 * t + "px;height:191px;"), myChart.resize()
}
function change_cb(t) {
	t ? document.getElementById("profileBox").className = "show" : document.getElementById("profileBox").className = "hide"
}
function toggleProfile() {
	var t = document.getElementById("cb_profile");
	t.checked && (document.getElementById("profileBox").className = "hide", t.checked = !1)
}
function changeNav(t) {
	clear(), positions = [], terrainSamplePositions = [], drawing = !1, changeCursor(drawing), clearText(), Tags[flag].className = "topC0", TagsCnt[flag].className = "undis", flag = t, Tags[t].className = "topC1", TagsCnt[t].className = "dis", console.log(flag), 1 == flag || 2 == flag || 3 == flag ? globe.depthTestAgainstTerrain = !1 : globe.depthTestAgainstTerrain = !0
}
function clearText() {
	for (var t = 0; t < tagNames.length; t++) console.log(tagNames[t]), document.getElementById(tagNames[t]).innerHTML = " "
}
function unitDetect_1(t, e, n) {
	"米" == t ? document.getElementById(e).innerHTML = n.toFixed(2) : "公里" == t ? document.getElementById(e).innerHTML = (n / 1e3).toFixed(2) : "厘米" == t && (document.getElementById(e).innerHTML = (100 * n).toFixed(2))
}
function unitDetect_2(t, e, n) {
	"平方米" == t ? document.getElementById(e).innerHTML = n.toFixed(2) : "平方公里" == t ? document.getElementById(e).innerHTML = (n / 1e6).toFixed(2) : "平方厘米" == t && (document.getElementById(e).innerHTML = (1e4 * n).toFixed(2))
}
function drawProfile(t) {
	if (t.length > 1) {
		var e = parseInt(document.getElementById("sb_interval").value);
		console.log(e), terrainSamplePositions = [];
		var n = [];
		for (i = 0; i < t.length; i++) {
			var o = Cesium.Cartographic.fromCartesian(t[i]);
			n.push([Cesium.Math.toDegrees(o.longitude), Cesium.Math.toDegrees(o.latitude)])
		}
		var r = {
			type: "Feature",
			geometry: {
				type: "LineString",
				coordinates: n
			}
		},
			s = turf.lineDistance(r, "kilometers");
		for (i = 0; i <= e; i++) {
			var a = turf.along(r, s / e * i, "kilometers"),
				l = a.geometry.coordinates[0],
				u = a.geometry.coordinates[1],
				p = Cesium.Cartographic.fromDegrees(l, u);
			terrainSamplePositions.push(p)
		}
		myChart.showLoading();
		var h = Cesium.sampleTerrain(terrainProvider, 9, terrainSamplePositions),
			c = [],
			g = [];
		h.then(function() {
			var t = !1;
			Math.round(s / e * 1e3) > 1e3 && (t = !0);
			for (var n = 0; n < terrainSamplePositions.length; n++) {
				var i = parseFloat(terrainSamplePositions[n].height.toFixed(2)),
					o = t ? (s / e * n).toFixed(0) + "公里" : (s / e * n * 1e3).toFixed(0) + "米";
				c.push(o), g.push(i), myChart.hideLoading(), myChart.setOption({
					xAxis: {
						data: c
					},
					series: [{
						data: g
					}]
				});
				var r = maxMeanMin(g);
				document.getElementById("title1").innerHTML = '海拔（米）  最大值：<span style="color:red"><strong>' + r[0] + '</strong> 米</span>   平均值：<span style="color:red"><strong>' + r[1].toFixed(2) + '</strong> 米</span>   最小值：<span style="color:red"><strong>' + r[2] + "</strong> 米</span>", document.getElementById("title2").innerHTML = '距离：<span style="color:red"><strong>' + (t ? s.toFixed(0) + " 公里</strong>" : (1e3 * s).toFixed(0) + " 米</strong>") + "</span>"
			}
		}).otherwise(function(t) {
			console.log(t)
		})
	}
}
function toggleMeasureBox() {
	var t = document.getElementById("measureBox"),
		e = document.getElementById("profileBox"),
		n = document.getElementById("cb_profile"),
		i = document.getElementById("cb_mouseControl");
	show ? (console.log("show: " + show), t.className = "show", startDrawing()) : (console.log("show: " + show), t.className = "hide", e.className = "hide", n.checked = !1, i.checked = !0, toggleMouse(!0), clear(), clearAll(), stopDrawing(), globe.depthTestAgainstTerrain = !1), show = !show
}!
function(t) {
	if ("object" == typeof exports && "undefined" != typeof module) module.exports = t();
	else if ("function" == typeof define && define.amd) define([], t);
	else {
		var e;
		e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, e.turf = t()
	}
}(function() {
	var t;
	return function e(t, n, i) {
		function o(s, a) {
			if (!n[s]) {
				if (!t[s]) {
					var l = "function" == typeof require && require;
					if (!a && l) return l(s, !0);
					if (r) return r(s, !0);
					var u = new Error("Cannot find module '" + s + "'");
					throw u.code = "MODULE_NOT_FOUND", u
				}
				var p = n[s] = {
					exports: {}
				};
				t[s][0].call(p.exports, function(e) {
					var n = t[s][1][e];
					return o(n ? n : e)
				}, p, p.exports, e, t, n, i)
			}
			return n[s].exports
		}
		for (var r = "function" == typeof require && require, s = 0; s < i.length; s++) o(i[s]);
		return o
	}({
		1: [function(t, e) {
			e.exports = {
				isolines: t("turf-isolines"),
				merge: t("turf-merge"),
				convex: t("turf-convex"),
				within: t("turf-within"),
				concave: t("turf-concave"),
				count: t("turf-count"),
				erase: t("turf-erase"),
				variance: t("turf-variance"),
				deviation: t("turf-deviation"),
				median: t("turf-median"),
				min: t("turf-min"),
				max: t("turf-max"),
				aggregate: t("turf-aggregate"),
				flip: t("turf-flip"),
				simplify: t("turf-simplify"),
				sum: t("turf-sum"),
				average: t("turf-average"),
				bezier: t("turf-bezier"),
				tag: t("turf-tag"),
				size: t("turf-size"),
				sample: t("turf-sample"),
				jenks: t("turf-jenks"),
				quantile: t("turf-quantile"),
				envelope: t("turf-envelope"),
				square: t("turf-square"),
				midpoint: t("turf-midpoint"),
				buffer: t("turf-buffer"),
				center: t("turf-center"),
				centroid: t("turf-centroid"),
				combine: t("turf-combine"),
				distance: t("turf-distance"),
				explode: t("turf-explode"),
				extent: t("turf-extent"),
				bboxPolygon: t("turf-bbox-polygon"),
				featurecollection: t("turf-featurecollection"),
				filter: t("turf-filter"),
				inside: t("turf-inside"),
				intersect: t("turf-intersect"),
				linestring: t("turf-linestring"),
				nearest: t("turf-nearest"),
				planepoint: t("turf-planepoint"),
				point: t("turf-point"),
				polygon: t("turf-polygon"),
				random: t("turf-random"),
				reclass: t("turf-reclass"),
				remove: t("turf-remove"),
				tin: t("turf-tin"),
				union: t("turf-union"),
				bearing: t("turf-bearing"),
				destination: t("turf-destination"),
				kinks: t("turf-kinks"),
				pointOnSurface: t("turf-point-on-surface"),
				area: t("turf-area"),
				along: t("turf-along"),
				lineDistance: t("turf-line-distance"),
				lineSlice: t("turf-line-slice"),
				pointOnLine: t("turf-point-on-line"),
				pointGrid: t("turf-point-grid"),
				squareGrid: t("turf-square-grid"),
				triangleGrid: t("turf-triangle-grid"),
				hexGrid: t("turf-hex-grid")
			}
		}, {
			"turf-aggregate": 6,
			"turf-along": 7,
			"turf-area": 8,
			"turf-average": 11,
			"turf-bbox-polygon": 12,
			"turf-bearing": 13,
			"turf-bezier": 14,
			"turf-buffer": 16,
			"turf-center": 21,
			"turf-centroid": 22,
			"turf-combine": 24,
			"turf-concave": 25,
			"turf-convex": 26,
			"turf-count": 56,
			"turf-destination": 57,
			"turf-deviation": 58,
			"turf-distance": 60,
			"turf-envelope": 62,
			"turf-erase": 63,
			"turf-explode": 68,
			"turf-extent": 70,
			"turf-featurecollection": 72,
			"turf-filter": 73,
			"turf-flip": 74,
			"turf-hex-grid": 75,
			"turf-inside": 76,
			"turf-intersect": 77,
			"turf-isolines": 83,
			"turf-jenks": 85,
			"turf-kinks": 87,
			"turf-line-distance": 88,
			"turf-line-slice": 89,
			"turf-linestring": 90,
			"turf-max": 91,
			"turf-median": 92,
			"turf-merge": 93,
			"turf-midpoint": 95,
			"turf-min": 96,
			"turf-nearest": 97,
			"turf-planepoint": 98,
			"turf-point": 102,
			"turf-point-grid": 99,
			"turf-point-on-line": 100,
			"turf-point-on-surface": 101,
			"turf-polygon": 103,
			"turf-quantile": 104,
			"turf-random": 106,
			"turf-reclass": 108,
			"turf-remove": 109,
			"turf-sample": 110,
			"turf-simplify": 111,
			"turf-size": 113,
			"turf-square": 115,
			"turf-square-grid": 114,
			"turf-sum": 116,
			"turf-tag": 117,
			"turf-tin": 118,
			"turf-triangle-grid": 119,
			"turf-union": 120,
			"turf-variance": 125,
			"turf-within": 127
		}],
		2: [function(t, e, n) {
			function i(t, e, n) {
				if (!(this instanceof i)) return new i(t, e, n);
				var o, r = typeof t;
				if ("number" === r) o = +t;
				else if ("string" === r) o = i.byteLength(t, e);
				else {
					if ("object" !== r || null === t) throw new TypeError("must start with number, buffer, array or string");
					"Buffer" === t.type && D(t.data) && (t = t.data), o = +t.length
				}
				if (o > B) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + B.toString(16) + " bytes");
				0 > o ? o = 0 : o >>>= 0;
				var s = this;
				i.TYPED_ARRAY_SUPPORT ? s = i._augment(new Uint8Array(o)) : (s.length = o, s._isBuffer = !0);
				var a;
				if (i.TYPED_ARRAY_SUPPORT && "number" == typeof t.byteLength) s._set(t);
				else if (L(t)) if (i.isBuffer(t)) for (a = 0; o > a; a++) s[a] = t.readUInt8(a);
				else for (a = 0; o > a; a++) s[a] = (t[a] % 256 + 256) % 256;
				else if ("string" === r) s.write(t, 0, e);
				else if ("number" === r && !i.TYPED_ARRAY_SUPPORT && !n) for (a = 0; o > a; a++) s[a] = 0;
				return o > 0 && o <= i.poolSize && (s.parent = G), s
			}
			function o(t, e, n) {
				if (!(this instanceof o)) return new o(t, e, n);
				var r = new i(t, e, n);
				return delete r.parent, r
			}
			function r(t, e, n, i) {
				n = Number(n) || 0;
				var o = t.length - n;
				i ? (i = Number(i), i > o && (i = o)) : i = o;
				var r = e.length;
				if (r % 2 !== 0) throw new Error("Invalid hex string");
				i > r / 2 && (i = r / 2);
				for (var s = 0; i > s; s++) {
					var a = parseInt(e.substr(2 * s, 2), 16);
					if (isNaN(a)) throw new Error("Invalid hex string");
					t[n + s] = a
				}
				return s
			}
			function s(t, e, n, i) {
				var o = A(P(e, t.length - n), t, n, i);
				return o
			}
			function a(t, e, n, i) {
				var o = A(M(e), t, n, i);
				return o
			}
			function l(t, e, n, i) {
				return a(t, e, n, i)
			}
			function u(t, e, n, i) {
				var o = A(N(e), t, n, i);
				return o
			}
			function p(t, e, n, i) {
				var o = A(_(e, t.length - n), t, n, i);
				return o
			}
			function h(t, e, n) {
				return R.fromByteArray(0 === e && n === t.length ? t : t.slice(e, n))
			}
			function c(t, e, n) {
				var i = "",
					o = "";
				n = Math.min(t.length, n);
				for (var r = e; n > r; r++) t[r] <= 127 ? (i += T(o) + String.fromCharCode(t[r]), o = "") : o += "%" + t[r].toString(16);
				return i + T(o)
			}
			function g(t, e, n) {
				var i = "";
				n = Math.min(t.length, n);
				for (var o = e; n > o; o++) i += String.fromCharCode(127 & t[o]);
				return i
			}
			function d(t, e, n) {
				var i = "";
				n = Math.min(t.length, n);
				for (var o = e; n > o; o++) i += String.fromCharCode(t[o]);
				return i
			}
			function f(t, e, n) {
				var i = t.length;
				(!e || 0 > e) && (e = 0), (!n || 0 > n || n > i) && (n = i);
				for (var o = "", r = e; n > r; r++) o += w(t[r]);
				return o
			}
			function m(t, e, n) {
				for (var i = t.slice(e, n), o = "", r = 0; r < i.length; r += 2) o += String.fromCharCode(i[r] + 256 * i[r + 1]);
				return o
			}
			function y(t, e, n) {
				if (t % 1 !== 0 || 0 > t) throw new RangeError("offset is not uint");
				if (t + e > n) throw new RangeError("Trying to access beyond buffer length")
			}
			function v(t, e, n, o, r, s) {
				if (!i.isBuffer(t)) throw new TypeError("buffer must be a Buffer instance");
				if (e > r || s > e) throw new RangeError("value is out of bounds");
				if (n + o > t.length) throw new RangeError("index out of range")
			}
			function x(t, e, n, i) {
				0 > e && (e = 65535 + e + 1);
				for (var o = 0, r = Math.min(t.length - n, 2); r > o; o++) t[n + o] = (e & 255 << 8 * (i ? o : 1 - o)) >>> 8 * (i ? o : 1 - o)
			}
			function j(t, e, n, i) {
				0 > e && (e = 4294967295 + e + 1);
				for (var o = 0, r = Math.min(t.length - n, 4); r > o; o++) t[n + o] = e >>> 8 * (i ? o : 3 - o) & 255
			}
			function E(t, e, n, i, o, r) {
				if (e > o || r > e) throw new RangeError("value is out of bounds");
				if (n + i > t.length) throw new RangeError("index out of range");
				if (0 > n) throw new RangeError("index out of range")
			}
			function I(t, e, n, i, o) {
				return o || E(t, e, n, 4, 3.4028234663852886e38, -3.4028234663852886e38), O.write(t, e, n, i, 23, 4), n + 4
			}
			function C(t, e, n, i, o) {
				return o || E(t, e, n, 8, 1.7976931348623157e308, -1.7976931348623157e308), O.write(t, e, n, i, 52, 8), n + 8
			}
			function S(t) {
				if (t = b(t).replace(k, ""), t.length < 2) return "";
				for (; t.length % 4 !== 0;) t += "=";
				return t
			}
			function b(t) {
				return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
			}
			function L(t) {
				return D(t) || i.isBuffer(t) || t && "object" == typeof t && "number" == typeof t.length
			}
			function w(t) {
				return 16 > t ? "0" + t.toString(16) : t.toString(16)
			}
			function P(t, e) {
				e = e || 1 / 0;
				for (var n, i = t.length, o = null, r = [], s = 0; i > s; s++) {
					if (n = t.charCodeAt(s), n > 55295 && 57344 > n) {
						if (!o) {
							if (n > 56319) {
								(e -= 3) > -1 && r.push(239, 191, 189);
								continue
							}
							if (s + 1 === i) {
								(e -= 3) > -1 && r.push(239, 191, 189);
								continue
							}
							o = n;
							continue
						}
						if (56320 > n) {
							(e -= 3) > -1 && r.push(239, 191, 189), o = n;
							continue
						}
						n = o - 55296 << 10 | n - 56320 | 65536, o = null
					} else o && ((e -= 3) > -1 && r.push(239, 191, 189), o = null);
					if (128 > n) {
						if ((e -= 1) < 0) break;
						r.push(n)
					} else if (2048 > n) {
						if ((e -= 2) < 0) break;
						r.push(n >> 6 | 192, 63 & n | 128)
					} else if (65536 > n) {
						if ((e -= 3) < 0) break;
						r.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
					} else {
						if (!(2097152 > n)) throw new Error("Invalid code point");
						if ((e -= 4) < 0) break;
						r.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
					}
				}
				return r
			}
			function M(t) {
				for (var e = [], n = 0; n < t.length; n++) e.push(255 & t.charCodeAt(n));
				return e
			}
			function _(t, e) {
				for (var n, i, o, r = [], s = 0; s < t.length && !((e -= 2) < 0); s++) n = t.charCodeAt(s), i = n >> 8, o = n % 256, r.push(o), r.push(i);
				return r
			}
			function N(t) {
				return R.toByteArray(S(t))
			}
			function A(t, e, n, i) {
				for (var o = 0; i > o && !(o + n >= e.length || o >= t.length); o++) e[o + n] = t[o];
				return o
			}
			function T(t) {
				try {
					return decodeURIComponent(t);
				} catch (e) {
					return String.fromCharCode(65533)
				}
			}
			var R = t("base64-js"),
				O = t("ieee754"),
				D = t("is-array");
			n.Buffer = i, n.SlowBuffer = o, n.INSPECT_MAX_BYTES = 50, i.poolSize = 8192;
			var B = 1073741823,
				G = {};
			i.TYPED_ARRAY_SUPPORT = function() {
				try {
					var t = new ArrayBuffer(0),
						e = new Uint8Array(t);
					return e.foo = function() {
						return 42
					}, 42 === e.foo() && "function" == typeof e.subarray && 0 === new Uint8Array(1).subarray(1, 1).byteLength
				} catch (n) {
					return !1
				}
			}(), i.isBuffer = function(t) {
				return !(null == t || !t._isBuffer)
			}, i.compare = function(t, e) {
				if (!i.isBuffer(t) || !i.isBuffer(e)) throw new TypeError("Arguments must be Buffers");
				if (t === e) return 0;
				for (var n = t.length, o = e.length, r = 0, s = Math.min(n, o); s > r && t[r] === e[r]; r++);
				return r !== s && (n = t[r], o = e[r]), o > n ? -1 : n > o ? 1 : 0
			}, i.isEncoding = function(t) {
				switch (String(t).toLowerCase()) {
				case "hex":
				case "utf8":
				case "utf-8":
				case "ascii":
				case "binary":
				case "base64":
				case "raw":
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
					return !0;
				default:
					return !1
				}
			}, i.concat = function(t, e) {
				if (!D(t)) throw new TypeError("Usage: Buffer.concat(list[, length])");
				if (0 === t.length) return new i(0);
				if (1 === t.length) return t[0];
				var n;
				if (void 0 === e) for (e = 0, n = 0; n < t.length; n++) e += t[n].length;
				var o = new i(e),
					r = 0;
				for (n = 0; n < t.length; n++) {
					var s = t[n];
					s.copy(o, r), r += s.length
				}
				return o
			}, i.byteLength = function(t, e) {
				var n;
				switch (t += "", e || "utf8") {
				case "ascii":
				case "binary":
				case "raw":
					n = t.length;
					break;
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
					n = 2 * t.length;
					break;
				case "hex":
					n = t.length >>> 1;
					break;
				case "utf8":
				case "utf-8":
					n = P(t).length;
					break;
				case "base64":
					n = N(t).length;
					break;
				default:
					n = t.length
				}
				return n
			}, i.prototype.length = void 0, i.prototype.parent = void 0, i.prototype.toString = function(t, e, n) {
				var i = !1;
				if (e >>>= 0, n = void 0 === n || 1 / 0 === n ? this.length : n >>> 0, t || (t = "utf8"), 0 > e && (e = 0), n > this.length && (n = this.length), e >= n) return "";
				for (;;) switch (t) {
				case "hex":
					return f(this, e, n);
				case "utf8":
				case "utf-8":
					return c(this, e, n);
				case "ascii":
					return g(this, e, n);
				case "binary":
					return d(this, e, n);
				case "base64":
					return h(this, e, n);
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
					return m(this, e, n);
				default:
					if (i) throw new TypeError("Unknown encoding: " + t);
					t = (t + "").toLowerCase(), i = !0
				}
			}, i.prototype.equals = function(t) {
				if (!i.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
				return this === t || 0 === i.compare(this, t)
			}, i.prototype.inspect = function() {
				var t = "",
					e = n.INSPECT_MAX_BYTES;
				return this.length > 0 && (t = this.toString("hex", 0, e).match(/.{2}/g).join(" "), this.length > e && (t += " ... ")), "<Buffer " + t + ">"
			}, i.prototype.compare = function(t) {
				if (!i.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
				return this === t ? 0 : i.compare(this, t)
			}, i.prototype.get = function(t) {
				return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(t)
			}, i.prototype.set = function(t, e) {
				return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(t, e)
			}, i.prototype.write = function(t, e, n, i) {
				if (isFinite(e)) isFinite(n) || (i = n, n = void 0);
				else {
					var o = i;
					i = e, e = n, n = o
				}
				if (e = Number(e) || 0, 0 > n || 0 > e || e > this.length) throw new RangeError("attempt to write outside buffer bounds");
				var h = this.length - e;
				n ? (n = Number(n), n > h && (n = h)) : n = h, i = String(i || "utf8").toLowerCase();
				var c;
				switch (i) {
				case "hex":
					c = r(this, t, e, n);
					break;
				case "utf8":
				case "utf-8":
					c = s(this, t, e, n);
					break;
				case "ascii":
					c = a(this, t, e, n);
					break;
				case "binary":
					c = l(this, t, e, n);
					break;
				case "base64":
					c = u(this, t, e, n);
					break;
				case "ucs2":
				case "ucs-2":
				case "utf16le":
				case "utf-16le":
					c = p(this, t, e, n);
					break;
				default:
					throw new TypeError("Unknown encoding: " + i)
				}
				return c
			}, i.prototype.toJSON = function() {
				return {
					type: "Buffer",
					data: Array.prototype.slice.call(this._arr || this, 0)
				}
			}, i.prototype.slice = function(t, e) {
				var n = this.length;
				t = ~~t, e = void 0 === e ? n : ~~e, 0 > t ? (t += n, 0 > t && (t = 0)) : t > n && (t = n), 0 > e ? (e += n, 0 > e && (e = 0)) : e > n && (e = n), t > e && (e = t);
				var o;
				if (i.TYPED_ARRAY_SUPPORT) o = i._augment(this.subarray(t, e));
				else {
					var r = e - t;
					o = new i(r, (void 0), (!0));
					for (var s = 0; r > s; s++) o[s] = this[s + t]
				}
				return o.length && (o.parent = this.parent || this), o
			}, i.prototype.readUIntLE = function(t, e, n) {
				t >>>= 0, e >>>= 0, n || y(t, e, this.length);
				for (var i = this[t], o = 1, r = 0; ++r < e && (o *= 256);) i += this[t + r] * o;
				return i
			}, i.prototype.readUIntBE = function(t, e, n) {
				t >>>= 0, e >>>= 0, n || y(t, e, this.length);
				for (var i = this[t + --e], o = 1; e > 0 && (o *= 256);) i += this[t + --e] * o;
				return i
			}, i.prototype.readUInt8 = function(t, e) {
				return e || y(t, 1, this.length), this[t]
			}, i.prototype.readUInt16LE = function(t, e) {
				return e || y(t, 2, this.length), this[t] | this[t + 1] << 8
			}, i.prototype.readUInt16BE = function(t, e) {
				return e || y(t, 2, this.length), this[t] << 8 | this[t + 1]
			}, i.prototype.readUInt32LE = function(t, e) {
				return e || y(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
			}, i.prototype.readUInt32BE = function(t, e) {
				return e || y(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
			}, i.prototype.readIntLE = function(t, e, n) {
				t >>>= 0, e >>>= 0, n || y(t, e, this.length);
				for (var i = this[t], o = 1, r = 0; ++r < e && (o *= 256);) i += this[t + r] * o;
				return o *= 128, i >= o && (i -= Math.pow(2, 8 * e)), i
			}, i.prototype.readIntBE = function(t, e, n) {
				t >>>= 0, e >>>= 0, n || y(t, e, this.length);
				for (var i = e, o = 1, r = this[t + --i]; i > 0 && (o *= 256);) r += this[t + --i] * o;
				return o *= 128, r >= o && (r -= Math.pow(2, 8 * e)), r
			}, i.prototype.readInt8 = function(t, e) {
				return e || y(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
			}, i.prototype.readInt16LE = function(t, e) {
				e || y(t, 2, this.length);
				var n = this[t] | this[t + 1] << 8;
				return 32768 & n ? 4294901760 | n : n
			}, i.prototype.readInt16BE = function(t, e) {
				e || y(t, 2, this.length);
				var n = this[t + 1] | this[t] << 8;
				return 32768 & n ? 4294901760 | n : n
			}, i.prototype.readInt32LE = function(t, e) {
				return e || y(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
			}, i.prototype.readInt32BE = function(t, e) {
				return e || y(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
			}, i.prototype.readFloatLE = function(t, e) {
				return e || y(t, 4, this.length), O.read(this, t, !0, 23, 4)
			}, i.prototype.readFloatBE = function(t, e) {
				return e || y(t, 4, this.length), O.read(this, t, !1, 23, 4)
			}, i.prototype.readDoubleLE = function(t, e) {
				return e || y(t, 8, this.length), O.read(this, t, !0, 52, 8)
			}, i.prototype.readDoubleBE = function(t, e) {
				return e || y(t, 8, this.length), O.read(this, t, !1, 52, 8)
			}, i.prototype.writeUIntLE = function(t, e, n, i) {
				t = +t, e >>>= 0, n >>>= 0, i || v(this, t, e, n, Math.pow(2, 8 * n), 0);
				var o = 1,
					r = 0;
				for (this[e] = 255 & t; ++r < n && (o *= 256);) this[e + r] = t / o >>> 0 & 255;
				return e + n
			}, i.prototype.writeUIntBE = function(t, e, n, i) {
				t = +t, e >>>= 0, n >>>= 0, i || v(this, t, e, n, Math.pow(2, 8 * n), 0);
				var o = n - 1,
					r = 1;
				for (this[e + o] = 255 & t; --o >= 0 && (r *= 256);) this[e + o] = t / r >>> 0 & 255;
				return e + n
			}, i.prototype.writeUInt8 = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 1, 255, 0), i.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = t, e + 1
			}, i.prototype.writeUInt16LE = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 2, 65535, 0), i.TYPED_ARRAY_SUPPORT ? (this[e] = t, this[e + 1] = t >>> 8) : x(this, t, e, !0), e + 2
			}, i.prototype.writeUInt16BE = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 2, 65535, 0), i.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = t) : x(this, t, e, !1), e + 2
			}, i.prototype.writeUInt32LE = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 4, 4294967295, 0), i.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = t) : j(this, t, e, !0), e + 4
			}, i.prototype.writeUInt32BE = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 4, 4294967295, 0), i.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = t) : j(this, t, e, !1), e + 4
			}, i.prototype.writeIntLE = function(t, e, n, i) {
				t = +t, e >>>= 0, i || v(this, t, e, n, Math.pow(2, 8 * n - 1) - 1, -Math.pow(2, 8 * n - 1));
				var o = 0,
					r = 1,
					s = 0 > t ? 1 : 0;
				for (this[e] = 255 & t; ++o < n && (r *= 256);) this[e + o] = (t / r >> 0) - s & 255;
				return e + n
			}, i.prototype.writeIntBE = function(t, e, n, i) {
				t = +t, e >>>= 0, i || v(this, t, e, n, Math.pow(2, 8 * n - 1) - 1, -Math.pow(2, 8 * n - 1));
				var o = n - 1,
					r = 1,
					s = 0 > t ? 1 : 0;
				for (this[e + o] = 255 & t; --o >= 0 && (r *= 256);) this[e + o] = (t / r >> 0) - s & 255;
				return e + n
			}, i.prototype.writeInt8 = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 1, 127, -128), i.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), 0 > t && (t = 255 + t + 1), this[e] = t, e + 1
			}, i.prototype.writeInt16LE = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 2, 32767, -32768), i.TYPED_ARRAY_SUPPORT ? (this[e] = t, this[e + 1] = t >>> 8) : x(this, t, e, !0), e + 2
			}, i.prototype.writeInt16BE = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 2, 32767, -32768), i.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = t) : x(this, t, e, !1), e + 2
			}, i.prototype.writeInt32LE = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 4, 2147483647, -2147483648), i.TYPED_ARRAY_SUPPORT ? (this[e] = t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : j(this, t, e, !0), e + 4
			}, i.prototype.writeInt32BE = function(t, e, n) {
				return t = +t, e >>>= 0, n || v(this, t, e, 4, 2147483647, -2147483648), 0 > t && (t = 4294967295 + t + 1), i.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = t) : j(this, t, e, !1), e + 4
			}, i.prototype.writeFloatLE = function(t, e, n) {
				return I(this, t, e, !0, n)
			}, i.prototype.writeFloatBE = function(t, e, n) {
				return I(this, t, e, !1, n)
			}, i.prototype.writeDoubleLE = function(t, e, n) {
				return C(this, t, e, !0, n)
			}, i.prototype.writeDoubleBE = function(t, e, n) {
				return C(this, t, e, !1, n)
			}, i.prototype.copy = function(t, e, n, o) {
				var r = this;
				if (n || (n = 0), o || 0 === o || (o = this.length), e >= t.length && (e = t.length), e || (e = 0), o > 0 && n > o && (o = n), o === n) return 0;
				if (0 === t.length || 0 === r.length) return 0;
				if (0 > e) throw new RangeError("targetStart out of bounds");
				if (0 > n || n >= r.length) throw new RangeError("sourceStart out of bounds");
				if (0 > o) throw new RangeError("sourceEnd out of bounds");
				o > this.length && (o = this.length), t.length - e < o - n && (o = t.length - e + n);
				var s = o - n;
				if (1e3 > s || !i.TYPED_ARRAY_SUPPORT) for (var a = 0; s > a; a++) t[a + e] = this[a + n];
				else t._set(this.subarray(n, n + s), e);
				return s
			}, i.prototype.fill = function(t, e, n) {
				if (t || (t = 0), e || (e = 0), n || (n = this.length), e > n) throw new RangeError("end < start");
				if (n !== e && 0 !== this.length) {
					if (0 > e || e >= this.length) throw new RangeError("start out of bounds");
					if (0 > n || n > this.length) throw new RangeError("end out of bounds");
					var i;
					if ("number" == typeof t) for (i = e; n > i; i++) this[i] = t;
					else {
						var o = P(t.toString()),
							r = o.length;
						for (i = e; n > i; i++) this[i] = o[i % r]
					}
					return this
				}
			}, i.prototype.toArrayBuffer = function() {
				if ("undefined" != typeof Uint8Array) {
					if (i.TYPED_ARRAY_SUPPORT) return new i(this).buffer;
					for (var t = new Uint8Array(this.length), e = 0, n = t.length; n > e; e += 1) t[e] = this[e];
					return t.buffer
				}
				throw new TypeError("Buffer.toArrayBuffer not supported in this browser")
			};
			var F = i.prototype;
			i._augment = function(t) {
				return t.constructor = i, t._isBuffer = !0, t._get = t.get, t._set = t.set, t.get = F.get, t.set = F.set, t.write = F.write, t.toString = F.toString, t.toLocaleString = F.toString, t.toJSON = F.toJSON, t.equals = F.equals, t.compare = F.compare, t.copy = F.copy, t.slice = F.slice, t.readUIntLE = F.readUIntLE, t.readUIntBE = F.readUIntBE, t.readUInt8 = F.readUInt8, t.readUInt16LE = F.readUInt16LE, t.readUInt16BE = F.readUInt16BE, t.readUInt32LE = F.readUInt32LE, t.readUInt32BE = F.readUInt32BE, t.readIntLE = F.readIntLE, t.readIntBE = F.readIntBE, t.readInt8 = F.readInt8, t.readInt16LE = F.readInt16LE, t.readInt16BE = F.readInt16BE, t.readInt32LE = F.readInt32LE, t.readInt32BE = F.readInt32BE, t.readFloatLE = F.readFloatLE, t.readFloatBE = F.readFloatBE, t.readDoubleLE = F.readDoubleLE, t.readDoubleBE = F.readDoubleBE, t.writeUInt8 = F.writeUInt8, t.writeUIntLE = F.writeUIntLE, t.writeUIntBE = F.writeUIntBE, t.writeUInt16LE = F.writeUInt16LE, t.writeUInt16BE = F.writeUInt16BE, t.writeUInt32LE = F.writeUInt32LE, t.writeUInt32BE = F.writeUInt32BE, t.writeIntLE = F.writeIntLE, t.writeIntBE = F.writeIntBE, t.writeInt8 = F.writeInt8, t.writeInt16LE = F.writeInt16LE, t.writeInt16BE = F.writeInt16BE, t.writeInt32LE = F.writeInt32LE, t.writeInt32BE = F.writeInt32BE, t.writeFloatLE = F.writeFloatLE, t.writeFloatBE = F.writeFloatBE, t.writeDoubleLE = F.writeDoubleLE, t.writeDoubleBE = F.writeDoubleBE, t.fill = F.fill, t.inspect = F.inspect, t.toArrayBuffer = F.toArrayBuffer, t
			};
			var k = /[^+\/0-9A-z\-]/g
		}, {
			"base64-js": 3,
			ieee754: 4,
			"is-array": 5
		}],
		3: [function(t, e, n) {
			var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
			!
			function(t) {
				"use strict";

				function e(t) {
					var e = t.charCodeAt(0);
					return e === s || e === h ? 62 : e === a || e === c ? 63 : l > e ? -1 : l + 10 > e ? e - l + 26 + 26 : p + 26 > e ? e - p : u + 26 > e ? e - u + 26 : void 0
				}
				function n(t) {
					function n(t) {
						u[h++] = t
					}
					var i, o, s, a, l, u;
					if (t.length % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
					var p = t.length;
					l = "=" === t.charAt(p - 2) ? 2 : "=" === t.charAt(p - 1) ? 1 : 0, u = new r(3 * t.length / 4 - l), s = l > 0 ? t.length - 4 : t.length;
					var h = 0;
					for (i = 0, o = 0; s > i; i += 4, o += 3) a = e(t.charAt(i)) << 18 | e(t.charAt(i + 1)) << 12 | e(t.charAt(i + 2)) << 6 | e(t.charAt(i + 3)), n((16711680 & a) >> 16), n((65280 & a) >> 8), n(255 & a);
					return 2 === l ? (a = e(t.charAt(i)) << 2 | e(t.charAt(i + 1)) >> 4, n(255 & a)) : 1 === l && (a = e(t.charAt(i)) << 10 | e(t.charAt(i + 1)) << 4 | e(t.charAt(i + 2)) >> 2, n(a >> 8 & 255), n(255 & a)), u
				}
				function o(t) {
					function e(t) {
						return i.charAt(t)
					}
					function n(t) {
						return e(t >> 18 & 63) + e(t >> 12 & 63) + e(t >> 6 & 63) + e(63 & t)
					}
					var o, r, s, a = t.length % 3,
						l = "";
					for (o = 0, s = t.length - a; s > o; o += 3) r = (t[o] << 16) + (t[o + 1] << 8) + t[o + 2], l += n(r);
					switch (a) {
					case 1:
						r = t[t.length - 1], l += e(r >> 2), l += e(r << 4 & 63), l += "==";
						break;
					case 2:
						r = (t[t.length - 2] << 8) + t[t.length - 1], l += e(r >> 10), l += e(r >> 4 & 63), l += e(r << 2 & 63), l += "="
					}
					return l
				}
				var r = "undefined" != typeof Uint8Array ? Uint8Array : Array,
					s = "+".charCodeAt(0),
					a = "/".charCodeAt(0),
					l = "0".charCodeAt(0),
					u = "a".charCodeAt(0),
					p = "A".charCodeAt(0),
					h = "-".charCodeAt(0),
					c = "_".charCodeAt(0);
				t.toByteArray = n, t.fromByteArray = o
			}("undefined" == typeof n ? this.base64js = {} : n)
		}, {}],
		4: [function(t, e, n) {
			n.read = function(t, e, n, i, o) {
				var r, s, a = 8 * o - i - 1,
					l = (1 << a) - 1,
					u = l >> 1,
					p = -7,
					h = n ? o - 1 : 0,
					c = n ? -1 : 1,
					g = t[e + h];
				for (h += c, r = g & (1 << -p) - 1, g >>= -p, p += a; p > 0; r = 256 * r + t[e + h], h += c, p -= 8);
				for (s = r & (1 << -p) - 1, r >>= -p, p += i; p > 0; s = 256 * s + t[e + h], h += c, p -= 8);
				if (0 === r) r = 1 - u;
				else {
					if (r === l) return s ? NaN : 1 / 0 * (g ? -1 : 1);
					s += Math.pow(2, i), r -= u
				}
				return (g ? -1 : 1) * s * Math.pow(2, r - i)
			}, n.write = function(t, e, n, i, o, r) {
				var s, a, l, u = 8 * r - o - 1,
					p = (1 << u) - 1,
					h = p >> 1,
					c = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
					g = i ? 0 : r - 1,
					d = i ? 1 : -1,
					f = 0 > e || 0 === e && 0 > 1 / e ? 1 : 0;
				for (e = Math.abs(e), isNaN(e) || 1 / 0 === e ? (a = isNaN(e) ? 1 : 0, s = p) : (s = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), e += s + h >= 1 ? c / l : c * Math.pow(2, 1 - h), e * l >= 2 && (s++, l /= 2), s + h >= p ? (a = 0, s = p) : s + h >= 1 ? (a = (e * l - 1) * Math.pow(2, o), s += h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, o), s = 0)); o >= 8; t[n + g] = 255 & a, g += d, a /= 256, o -= 8);
				for (s = s << o | a, u += o; u > 0; t[n + g] = 255 & s, g += d, s /= 256, u -= 8);
				t[n + g - d] |= 128 * f
			}
		}, {}],
		5: [function(t, e) {
			var n = Array.isArray,
				i = Object.prototype.toString;
			e.exports = n ||
			function(t) {
				return !!t && "[object Array]" == i.call(t)
			}
		}, {}],
		6: [function(t, e) {
			function n(t) {
				return "average" === t || "sum" === t || "median" === t || "min" === t || "max" === t || "deviation" === t || "variance" === t || "count" === t
			}
			var i = t("turf-average"),
				o = t("turf-sum"),
				r = t("turf-median"),
				s = t("turf-min"),
				a = t("turf-max"),
				l = t("turf-deviation"),
				u = t("turf-variance"),
				p = t("turf-count"),
				h = {};
			h.average = i, h.sum = o, h.median = r, h.min = s, h.max = a, h.deviation = l, h.variance = u, h.count = p, e.exports = function(t, e, i) {
				for (var o = 0, r = i.length; r > o; o++) {
					var s = i[o],
						a = s.aggregation;
					if (!n(a)) throw new Error('"' + a + '" is not a recognized aggregation operation.');
					t = "count" === a ? h[a](t, e, s.outField) : h[a](t, e, s.inField, s.outField)
				}
				return t
			}
		}, {
			"turf-average": 11,
			"turf-count": 56,
			"turf-deviation": 58,
			"turf-max": 91,
			"turf-median": 92,
			"turf-min": 96,
			"turf-sum": 116,
			"turf-variance": 125
		}],
		7: [function(t, e) {
			var n = t("turf-distance"),
				i = t("turf-point"),
				o = t("turf-bearing"),
				r = t("turf-destination");
			e.exports = function(t, e, s) {
				var a;
				if ("Feature" === t.type) a = t.geometry.coordinates;
				else {
					if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry");
					a = t.geometry.coordinates
				}
				for (var l = 0, u = 0; u < a.length && !(e >= l && u === a.length - 1); u++) {
					if (l >= e) {
						var p = e - l;
						if (p) {
							var h = o(i(a[u]), i(a[u - 1])) - 180,
								c = r(i(a[u]), p, h, s);
							return c
						}
						return i(a[u])
					}
					l += n(i(a[u]), i(a[u + 1]), s)
				}
				return i(a[a.length - 1])
			}
		}, {
			"turf-bearing": 13,
			"turf-destination": 57,
			"turf-distance": 60,
			"turf-point": 102
		}],
		8: [function(t, e) {
			var n = t("geojson-area").geometry;
			e.exports = function(t) {
				if ("FeatureCollection" === t.type) {
					for (var e = 0, i = 0; e < t.features.length; e++) t.features[e].geometry && (i += n(t.features[e].geometry));
					return i
				}
				return n("Feature" === t.type ? t.geometry : t)
			}
		}, {
			"geojson-area": 9
		}],
		9: [function(t, e) {
			function n(t) {
				var e, o = 0;
				switch (t.type) {
				case "Polygon":
					return i(t.coordinates);
				case "MultiPolygon":
					for (e = 0; e < t.coordinates.length; e++) o += i(t.coordinates[e]);
					return o;
				case "Point":
				case "MultiPoint":
				case "LineString":
				case "MultiLineString":
					return 0;
				case "GeometryCollection":
					for (e = 0; e < t.geometries.length; e++) o += n(t.geometries[e]);
					return o
				}
			}
			function i(t) {
				var e = 0;
				if (t && t.length > 0) {
					e += Math.abs(o(t[0]));
					for (var n = 1; n < t.length; n++) e -= Math.abs(o(t[n]))
				}
				return e
			}
			function o(t) {
				var e = 0;
				if (t.length > 2) {
					for (var n, i, o = 0; o < t.length - 1; o++) n = t[o], i = t[o + 1], e += r(i[0] - n[0]) * (2 + Math.sin(r(n[1])) + Math.sin(r(i[1])));
					e = e * s.RADIUS * s.RADIUS / 2
				}
				return e
			}
			function r(t) {
				return t * Math.PI / 180
			}
			var s = t("wgs84");
			e.exports.geometry = n, e.exports.ring = o
		}, {
			wgs84: 10
		}],
		10: [function(t, e) {
			e.exports.RADIUS = 6378137, e.exports.FLATTENING = 1 / 298.257223563, e.exports.POLAR_RADIUS = 6356752.3142
		}, {}],
		11: [function(t, e) {
			function n(t) {
				for (var e = 0, n = 0; n < t.length; n++) e += t[n];
				return e / t.length
			}
			var i = t("turf-inside");
			e.exports = function(t, e, o, r) {
				return t.features.forEach(function(t) {
					t.properties || (t.properties = {});
					var s = [];
					e.features.forEach(function(e) {
						i(e, t) && s.push(e.properties[o])
					}), t.properties[r] = n(s)
				}), t
			}
		}, {
			"turf-inside": 76
		}],
		12: [function(t, e) {
			var n = t("turf-polygon");
			e.exports = function(t) {
				var e = [t[0], t[1]],
					i = [t[0], t[3]],
					o = [t[2], t[3]],
					r = [t[2], t[1]],
					s = n([
						[e, r, o, i, e]
					]);
				return s
			}
		}, {
			"turf-polygon": 103
		}],
		13: [function(t, e) {
			function n(t) {
				return t * Math.PI / 180
			}
			function i(t) {
				return 180 * t / Math.PI
			}
			e.exports = function(t, e) {
				var o = t.geometry.coordinates,
					r = e.geometry.coordinates,
					s = n(o[0]),
					a = n(r[0]),
					l = n(o[1]),
					u = n(r[1]),
					p = Math.sin(a - s) * Math.cos(u),
					h = Math.cos(l) * Math.sin(u) - Math.sin(l) * Math.cos(u) * Math.cos(a - s),
					c = i(Math.atan2(p, h));
				return c
			}
		}, {}],
		14: [function(t, e) {
			var n = t("turf-linestring"),
				i = t("./spline.js");
			e.exports = function(t, e, o) {
				var r = n([]);
				r.properties = t.properties;
				for (var s = t.geometry.coordinates.map(function(t) {
					return {
						x: t[0],
						y: t[1]
					}
				}), a = new i({
					points: s,
					duration: e,
					sharpness: o
				}), l = 0; l < a.duration; l += 10) {
					var u = a.pos(l);
					Math.floor(l / 100) % 2 === 0 && r.geometry.coordinates.push([u.x, u.y])
				}
				return r
			}
		}, {
			"./spline.js": 15,
			"turf-linestring": 90
		}],
		15: [function(t, e) {
			var n = function(t) {
					this.points = t.points || [], this.duration = t.duration || 1e4, this.sharpness = t.sharpness || .85, this.centers = [], this.controls = [], this.stepLength = t.stepLength || 60, this.length = this.points.length, this.delay = 0;
					for (var e = 0; e < this.length; e++) this.points[e].z = this.points[e].z || 0;
					for (var e = 0; e < this.length - 1; e++) {
						var n = this.points[e],
							i = this.points[e + 1];
						this.centers.push({
							x: (n.x + i.x) / 2,
							y: (n.y + i.y) / 2,
							z: (n.z + i.z) / 2
						})
					}
					this.controls.push([this.points[0], this.points[0]]);
					for (var e = 0; e < this.centers.length - 1; e++) {
						var n = this.centers[e],
							i = this.centers[e + 1],
							o = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2,
							r = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2,
							s = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2;
						this.controls.push([{
							x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + o),
							y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + r),
							z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + s)
						}, {
							x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + o),
							y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + r),
							z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + s)
						}])
					}
					return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this
				};
			n.prototype.cacheSteps = function(t) {
				var e = [],
					n = this.pos(0);
				e.push(0);
				for (var i = 0; i < this.duration; i += 10) {
					var o = this.pos(i),
						r = Math.sqrt((o.x - n.x) * (o.x - n.x) + (o.y - n.y) * (o.y - n.y) + (o.z - n.z) * (o.z - n.z));
					r > t && (e.push(i), n = o)
				}
				return e
			}, n.prototype.vector = function(t) {
				var e = this.pos(t + 10),
					n = this.pos(t - 10);
				return {
					angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14,
					speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z))
				}
			}, n.prototype.pos = function(t) {
				function e(t, e, n, i, o) {
					var r = function(t) {
							var e = t * t,
								n = e * t;
							return [n, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)]
						},
						s = r(t),
						a = {
							x: o.x * s[0] + i.x * s[1] + n.x * s[2] + e.x * s[3],
							y: o.y * s[0] + i.y * s[1] + n.y * s[2] + e.y * s[3],
							z: o.z * s[0] + i.z * s[1] + n.z * s[2] + e.z * s[3]
						};
					return a
				}
				var n = t - this.delay;
				0 > n && (n = 0), n > this.duration && (n = this.duration - 1);
				var i = n / this.duration;
				if (i >= 1) return this.points[this.length - 1];
				var o = Math.floor((this.points.length - 1) * i),
					r = (this.length - 1) * i - o;
				return e(r, this.points[o], this.controls[o][1], this.controls[o + 1][0], this.points[o + 1])
			}, e.exports = n
		}, {}],
		16: [function(t, e) {
			var n = t("turf-featurecollection"),
				i = t("turf-polygon"),
				o = t("turf-combine"),
				r = t("jsts");
			e.exports = function(t, e, n) {
				var i;
				switch (n) {
				case "miles":
					e /= 69.047;
					break;
				case "feet":
					e /= 364568;
					break;
				case "kilometers":
					e /= 111.12;
					break;
				case "meters":
					e /= 111120;
					break;
				case "degrees":
				}
				if ("FeatureCollection" === t.type) {
					var r = o(t);
					return r.properties = {}, i = s(r, e)
				}
				return i = s(t, e)
			};
			var s = function(t, e) {
					var o = new r.io.GeoJSONReader,
						s = o.read(JSON.stringify(t.geometry)),
						a = s.buffer(e),
						l = new r.io.GeoJSONParser;
					return a = l.write(a), "MultiPolygon" === a.type ? (a = {
						type: "Feature",
						geometry: a,
						properties: {}
					}, a = n([a])) : a = n([i(a.coordinates)]), a
				}
		}, {
			jsts: 17,
			"turf-combine": 24,
			"turf-featurecollection": 72,
			"turf-polygon": 103
		}],
		17: [function(t, e) {
			t("javascript.util");
			var n = t("./lib/jsts");
			e.exports = n
		}, {
			"./lib/jsts": 18,
			"javascript.util": 20
		}],
		18: [function(t, e) {
			jsts = {
				version: "0.15.0",
				algorithm: {
					distance: {},
					locate: {}
				},
				error: {},
				geom: {
					util: {}
				},
				geomgraph: {
					index: {}
				},
				index: {
					bintree: {},
					chain: {},
					kdtree: {},
					quadtree: {},
					strtree: {}
				},
				io: {},
				noding: {
					snapround: {}
				},
				operation: {
					buffer: {},
					distance: {},
					overlay: {
						snap: {}
					},
					polygonize: {},
					predicate: {},
					relate: {},
					union: {},
					valid: {}
				},
				planargraph: {},
				simplify: {},
				triangulate: {
					quadedge: {}
				},
				util: {}
			}, "function" != typeof String.prototype.trim && (String.prototype.trim = function() {
				return this.replace(/^\s+|\s+$/g, "")
			}), jsts.abstractFunc = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.error = {}, jsts.error.IllegalArgumentError = function(t) {
				this.name = "IllegalArgumentError", this.message = t
			}, jsts.error.IllegalArgumentError.prototype = new Error, jsts.error.TopologyError = function(t, e) {
				this.name = "TopologyError", this.message = e ? t + " [ " + e + " ]" : t
			}, jsts.error.TopologyError.prototype = new Error, jsts.error.AbstractMethodInvocationError = function() {
				this.name = "AbstractMethodInvocationError", this.message = "Abstract method called, should be implemented in subclass."
			}, jsts.error.AbstractMethodInvocationError.prototype = new Error, jsts.error.NotImplementedError = function() {
				this.name = "NotImplementedError", this.message = "This method has not yet been implemented."
			}, jsts.error.NotImplementedError.prototype = new Error, jsts.error.NotRepresentableError = function(t) {
				this.name = "NotRepresentableError", this.message = t
			}, jsts.error.NotRepresentableError.prototype = new Error, jsts.error.LocateFailureError = function(t) {
				this.name = "LocateFailureError", this.message = t
			}, jsts.error.LocateFailureError.prototype = new Error, "undefined" != typeof e && (e.exports = jsts), jsts.geom.GeometryFilter = function() {}, jsts.geom.GeometryFilter.prototype.filter = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.util.PolygonExtracter = function(t) {
				this.comps = t
			}, jsts.geom.util.PolygonExtracter.prototype = new jsts.geom.GeometryFilter, jsts.geom.util.PolygonExtracter.prototype.comps = null, jsts.geom.util.PolygonExtracter.getPolygons = function(t, e) {
				return void 0 === e && (e = []), t instanceof jsts.geom.Polygon ? e.push(t) : t instanceof jsts.geom.GeometryCollection && t.apply(new jsts.geom.util.PolygonExtracter(e)), e
			}, jsts.geom.util.PolygonExtracter.prototype.filter = function(t) {
				t instanceof jsts.geom.Polygon && this.comps.push(t)
			}, jsts.io.WKTParser = function(t) {
				this.geometryFactory = t || new jsts.geom.GeometryFactory, this.regExes = {
					typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
					emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
					spaces: /\s+/,
					parenComma: /\)\s*,\s*\(/,
					doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
					trimParens: /^\s*\(?(.*?)\)?\s*$/
				}
			}, jsts.io.WKTParser.prototype.read = function(t) {
				var e, n, i;
				t = t.replace(/[\n\r]/g, " ");
				var o = this.regExes.typeStr.exec(t);
				if (-1 !== t.search("EMPTY") && (o = this.regExes.emptyTypeStr.exec(t), o[2] = void 0), o && (n = o[1].toLowerCase(), i = o[2], this.parse[n] && (e = this.parse[n].apply(this, [i]))), void 0 === e) throw new Error("Could not parse WKT " + t);
				return e
			}, jsts.io.WKTParser.prototype.write = function(t) {
				return this.extractGeometry(t)
			}, jsts.io.WKTParser.prototype.extractGeometry = function(t) {
				var e = t.CLASS_NAME.split(".")[2].toLowerCase();
				if (!this.extract[e]) return null;
				var n, i = e.toUpperCase();
				return n = t.isEmpty() ? i + " EMPTY" : i + "(" + this.extract[e].apply(this, [t]) + ")"
			}, jsts.io.WKTParser.prototype.extract = {
				coordinate: function(t) {
					return t.x + " " + t.y
				},
				point: function(t) {
					return t.coordinate.x + " " + t.coordinate.y
				},
				multipoint: function(t) {
					for (var e = [], n = 0, i = t.geometries.length; i > n; ++n) e.push("(" + this.extract.point.apply(this, [t.geometries[n]]) + ")");
					return e.join(",")
				},
				linestring: function(t) {
					for (var e = [], n = 0, i = t.points.length; i > n; ++n) e.push(this.extract.coordinate.apply(this, [t.points[n]]));
					return e.join(",")
				},
				multilinestring: function(t) {
					for (var e = [], n = 0, i = t.geometries.length; i > n; ++n) e.push("(" + this.extract.linestring.apply(this, [t.geometries[n]]) + ")");
					return e.join(",")
				},
				polygon: function(t) {
					var e = [];
					e.push("(" + this.extract.linestring.apply(this, [t.shell]) + ")");
					for (var n = 0, i = t.holes.length; i > n; ++n) e.push("(" + this.extract.linestring.apply(this, [t.holes[n]]) + ")");
					return e.join(",")
				},
				multipolygon: function(t) {
					for (var e = [], n = 0, i = t.geometries.length; i > n; ++n) e.push("(" + this.extract.polygon.apply(this, [t.geometries[n]]) + ")");
					return e.join(",")
				},
				geometrycollection: function(t) {
					for (var e = [], n = 0, i = t.geometries.length; i > n; ++n) e.push(this.extractGeometry.apply(this, [t.geometries[n]]));
					return e.join(",")
				}
			}, jsts.io.WKTParser.prototype.parse = {
				point: function(t) {
					if (void 0 === t) return this.geometryFactory.createPoint(null);
					var e = t.trim().split(this.regExes.spaces);
					return this.geometryFactory.createPoint(new jsts.geom.Coordinate(e[0], e[1]))
				},
				multipoint: function(t) {
					if (void 0 === t) return this.geometryFactory.createMultiPoint(null);
					for (var e, n = t.trim().split(","), i = [], o = 0, r = n.length; r > o; ++o) e = n[o].replace(this.regExes.trimParens, "$1"), i.push(this.parse.point.apply(this, [e]));
					return this.geometryFactory.createMultiPoint(i)
				},
				linestring: function(t) {
					if (void 0 === t) return this.geometryFactory.createLineString(null);
					for (var e, n = t.trim().split(","), i = [], o = 0, r = n.length; r > o; ++o) e = n[o].trim().split(this.regExes.spaces), i.push(new jsts.geom.Coordinate(e[0], e[1]));
					return this.geometryFactory.createLineString(i)
				},
				linearring: function(t) {
					if (void 0 === t) return this.geometryFactory.createLinearRing(null);
					for (var e, n = t.trim().split(","), i = [], o = 0, r = n.length; r > o; ++o) e = n[o].trim().split(this.regExes.spaces), i.push(new jsts.geom.Coordinate(e[0], e[1]));
					return this.geometryFactory.createLinearRing(i)
				},
				multilinestring: function(t) {
					if (void 0 === t) return this.geometryFactory.createMultiLineString(null);
					for (var e, n = t.trim().split(this.regExes.parenComma), i = [], o = 0, r = n.length; r > o; ++o) e = n[o].replace(this.regExes.trimParens, "$1"), i.push(this.parse.linestring.apply(this, [e]));
					return this.geometryFactory.createMultiLineString(i)
				},
				polygon: function(t) {
					if (void 0 === t) return this.geometryFactory.createPolygon(null);
					for (var e, n, i, o, r = t.trim().split(this.regExes.parenComma), s = [], a = 0, l = r.length; l > a; ++a) e = r[a].replace(this.regExes.trimParens, "$1"), n = this.parse.linestring.apply(this, [e]), i = this.geometryFactory.createLinearRing(n.points), 0 === a ? o = i : s.push(i);
					return this.geometryFactory.createPolygon(o, s)
				},
				multipolygon: function(t) {
					if (void 0 === t) return this.geometryFactory.createMultiPolygon(null);
					for (var e, n = t.trim().split(this.regExes.doubleParenComma), i = [], o = 0, r = n.length; r > o; ++o) e = n[o].replace(this.regExes.trimParens, "$1"), i.push(this.parse.polygon.apply(this, [e]));
					return this.geometryFactory.createMultiPolygon(i)
				},
				geometrycollection: function(t) {
					if (void 0 === t) return this.geometryFactory.createGeometryCollection(null);
					t = t.replace(/,\s*([A-Za-z])/g, "|$1");
					for (var e = t.trim().split("|"), n = [], i = 0, o = e.length; o > i; ++i) n.push(jsts.io.WKTParser.prototype.read.apply(this, [e[i]]));
					return this.geometryFactory.createGeometryCollection(n)
				}
			}, jsts.index.ItemVisitor = function() {}, jsts.index.ItemVisitor.prototype.visitItem = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.algorithm.CGAlgorithms = function() {}, jsts.algorithm.CGAlgorithms.CLOCKWISE = -1, jsts.algorithm.CGAlgorithms.RIGHT = jsts.algorithm.CGAlgorithms.CLOCKWISE, jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE = 1, jsts.algorithm.CGAlgorithms.LEFT = jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE, jsts.algorithm.CGAlgorithms.COLLINEAR = 0, jsts.algorithm.CGAlgorithms.STRAIGHT = jsts.algorithm.CGAlgorithms.COLLINEAR, jsts.algorithm.CGAlgorithms.orientationIndex = function(t, e, n) {
				var i, o, r, s;
				return i = e.x - t.x, o = e.y - t.y, r = n.x - e.x, s = n.y - e.y, jsts.algorithm.RobustDeterminant.signOfDet2x2(i, o, r, s)
			}, jsts.algorithm.CGAlgorithms.isPointInRing = function(t, e) {
				return jsts.algorithm.CGAlgorithms.locatePointInRing(t, e) !== jsts.geom.Location.EXTERIOR
			}, jsts.algorithm.CGAlgorithms.locatePointInRing = function(t, e) {
				return jsts.algorithm.RayCrossingCounter.locatePointInRing(t, e)
			}, jsts.algorithm.CGAlgorithms.isOnLine = function(t, e) {
				var n, i, o, r, s;
				for (n = new jsts.algorithm.RobustLineIntersector, i = 1, o = e.length; o > i; i++) if (r = e[i - 1], s = e[i], n.computeIntersection(t, r, s), n.hasIntersection()) return !0;
				return !1
			}, jsts.algorithm.CGAlgorithms.isCCW = function(t) {
				var e, n, i, o, r, s, a, l, u, p, h;
				if (e = t.length - 1, 3 > e) throw new jsts.IllegalArgumentError("Ring has fewer than 3 points, so orientation cannot be determined");
				for (n = t[0], i = 0, u = 1; e >= u; u++) o = t[u], o.y > n.y && (n = o, i = u);
				r = i;
				do r -= 1, 0 > r && (r = e);
				while (t[r].equals2D(n) && r !== i);
				s = i;
				do s = (s + 1) % e;
				while (t[s].equals2D(n) && s !== i);
				return a = t[r], l = t[s], !(a.equals2D(n) || l.equals2D(n) || a.equals2D(l)) && (p = jsts.algorithm.CGAlgorithms.computeOrientation(a, n, l), h = !1, h = 0 === p ? a.x > l.x : p > 0)
			}, jsts.algorithm.CGAlgorithms.computeOrientation = function(t, e, n) {
				return jsts.algorithm.CGAlgorithms.orientationIndex(t, e, n)
			}, jsts.algorithm.CGAlgorithms.distancePointLine = function(t, e, n) {
				if (e instanceof jsts.geom.Coordinate || jsts.algorithm.CGAlgorithms.distancePointLine2.apply(this, arguments), e.x === n.x && e.y === n.y) return t.distance(e);
				var i, o;
				return i = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / ((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y)), 0 >= i ? t.distance(e) : i >= 1 ? t.distance(n) : (o = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / ((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y)), Math.abs(o) * Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y)))
			}, jsts.algorithm.CGAlgorithms.distancePointLinePerpendicular = function(t, e, n) {
				var i = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / ((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y));
				return Math.abs(i) * Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y))
			}, jsts.algorithm.CGAlgorithms.distancePointLine2 = function(t, e) {
				var n, i, o, r;
				if (0 === e.length) throw new jsts.error.IllegalArgumentError("Line array must contain at least one vertex");
				for (n = t.distance(e[0]), i = 0, o = e.length - 1; o > i; i++) r = jsts.algorithm.CGAlgorithms.distancePointLine(t, e[i], e[i + 1]), n > r && (n = r);
				return n
			}, jsts.algorithm.CGAlgorithms.distanceLineLine = function(t, e, n, i) {
				if (t.equals(e)) return jsts.algorithm.CGAlgorithms.distancePointLine(t, n, i);
				if (n.equals(i)) return jsts.algorithm.CGAlgorithms.distancePointLine(i, t, e);
				var o, r, s, a, l, u;
				return o = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y), r = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x), s = (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y), a = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x), 0 === r || 0 === a ? Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(t, n, i), Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(e, n, i), Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(n, t, e), jsts.algorithm.CGAlgorithms.distancePointLine(i, t, e)))) : (l = s / a, u = o / r, 0 > u || u > 1 || 0 > l || l > 1 ? Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(t, n, i), Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(e, n, i), Math.min(jsts.algorithm.CGAlgorithms.distancePointLine(n, t, e), jsts.algorithm.CGAlgorithms.distancePointLine(i, t, e)))) : 0)
			}, jsts.algorithm.CGAlgorithms.signedArea = function(t) {
				if (t.length < 3) return 0;
				var e, n, i, o, r, s, a;
				for (e = 0, n = 0, i = t.length - 1; i > n; n++) o = t[n].x, r = t[n].y, s = t[n + 1].x, a = t[n + 1].y, e += (o + s) * (a - r);
				return -e / 2
			}, jsts.algorithm.CGAlgorithms.signedArea = function(t) {
				var e, n, i, o, r, s, a, l;
				if (e = t.length, 3 > e) return 0;
				for (n = 0, i = t[0], o = i.x, r = i.y, s = 1; e > s; s++) i = t[s], a = i.x, l = i.y, n += (o + a) * (l - r), o = a, r = l;
				return -n / 2
			}, jsts.algorithm.CGAlgorithms.computeLength = function(t) {
				var e, n, i, o, r, s, a, l, u, p, h = t.length;
				if (1 >= h) return 0;
				for (e = 0, l = t[0], n = l.x, i = l.y, u = 1, p = h, u; h > u; u++) l = t[u], o = l.x, r = l.y, s = o - n, a = r - i, e += Math.sqrt(s * s + a * a), n = o, i = r;
				return e
			}, jsts.algorithm.CGAlgorithms.length = function() {}, jsts.algorithm.Angle = function() {}, jsts.algorithm.Angle.PI_TIMES_2 = 2 * Math.PI, jsts.algorithm.Angle.PI_OVER_2 = Math.PI / 2, jsts.algorithm.Angle.PI_OVER_4 = Math.PI / 4, jsts.algorithm.Angle.COUNTERCLOCKWISE = jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE, jsts.algorithm.Angle.CLOCKWISE = jsts.algorithm.CGAlgorithms.CLOCKWISE, jsts.algorithm.Angle.NONE = jsts.algorithm.CGAlgorithms.COLLINEAR, jsts.algorithm.Angle.toDegrees = function(t) {
				return 180 * t / Math.PI
			}, jsts.algorithm.Angle.toRadians = function(t) {
				return t * Math.PI / 180
			}, jsts.algorithm.Angle.angle = function() {
				return 1 === arguments.length ? jsts.algorithm.Angle.angleFromOrigo(arguments[0]) : jsts.algorithm.Angle.angleBetweenCoords(arguments[0], arguments[1])
			}, jsts.algorithm.Angle.angleBetweenCoords = function(t, e) {
				var n, i;
				return n = e.x - t.x, i = e.y - t.y, Math.atan2(i, n)
			}, jsts.algorithm.Angle.angleFromOrigo = function(t) {
				return Math.atan2(t.y, t.x)
			}, jsts.algorithm.Angle.isAcute = function(t, e, n) {
				var i, o, r, s, a;
				return i = t.x - e.x, o = t.y - e.y, r = n.x - e.x, s = n.y - e.y, a = i * r + o * s, a > 0
			}, jsts.algorithm.Angle.isObtuse = function(t, e, n) {
				var i, o, r, s, a;
				return i = t.x - e.x, o = t.y - e.y, r = n.x - e.x, s = n.y - e.y, a = i * r + o * s, 0 > a
			}, jsts.algorithm.Angle.angleBetween = function(t, e, n) {
				var i, o;
				return i = jsts.algorithm.Angle.angle(e, t), o = jsts.algorithm.Angle.angle(e, n), jsts.algorithm.Angle.diff(i, o)
			}, jsts.algorithm.Angle.angleBetweenOriented = function(t, e, n) {
				var i, o, r;
				return i = jsts.algorithm.Angle.angle(e, t), o = jsts.algorithm.Angle.angle(e, n), r = o - i, r <= -Math.PI ? r + jsts.algorithm.Angle.PI_TIMES_2 : r > Math.PI ? r - jsts.algorithm.Angle.PI_TIMES_2 : r
			}, jsts.algorithm.Angle.interiorAngle = function(t, e, n) {
				var i, o;
				return i = jsts.algorithm.Angle.angle(e, t), o = jsts.algorithm.Angle.angle(e, n), Math.abs(o - i)
			}, jsts.algorithm.Angle.getTurn = function(t, e) {
				var n = Math.sin(e - t);
				return n > 0 ? jsts.algorithm.Angle.COUNTERCLOCKWISE : 0 > n ? jsts.algorithm.Angle.CLOCKWISE : jsts.algorithm.Angle.NONE
			}, jsts.algorithm.Angle.normalize = function(t) {
				for (; t > Math.PI;) t -= jsts.algorithm.Angle.PI_TIMES_2;
				for (; t <= -Math.PI;) t += jsts.algorithm.Angle.PI_TIMES_2;
				return t
			}, jsts.algorithm.Angle.normalizePositive = function(t) {
				if (0 > t) {
					for (; 0 > t;) t += jsts.algorithm.Angle.PI_TIMES_2;
					t >= jsts.algorithm.Angle.PI_TIMES_2 && (t = 0)
				} else {
					for (; t >= jsts.algorithm.Angle.PI_TIMES_2;) t -= jsts.algorithm.Angle.PI_TIMES_2;
					0 > t && (t = 0)
				}
				return t
			}, jsts.algorithm.Angle.diff = function(t, e) {
				var n;
				return n = e > t ? e - t : t - e, n > Math.PI && (n = 2 * Math.PI - n), n
			}, jsts.geom.GeometryComponentFilter = function() {}, jsts.geom.GeometryComponentFilter.prototype.filter = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.util.LinearComponentExtracter = function(t, e) {
				this.lines = t, this.isForcedToLineString = e
			}, jsts.geom.util.LinearComponentExtracter.prototype = new jsts.geom.GeometryComponentFilter, jsts.geom.util.LinearComponentExtracter.prototype.lines = null, jsts.geom.util.LinearComponentExtracter.prototype.isForcedToLineString = !1, jsts.geom.util.LinearComponentExtracter.getLines = function(t, e) {
				if (1 == arguments.length) return jsts.geom.util.LinearComponentExtracter.getLines5.apply(this, arguments);
				if (2 == arguments.length && "boolean" == typeof e) return jsts.geom.util.LinearComponentExtracter.getLines6.apply(this, arguments);
				if (2 == arguments.length && t instanceof jsts.geom.Geometry) return jsts.geom.util.LinearComponentExtracter.getLines3.apply(this, arguments);
				if (3 == arguments.length && t instanceof jsts.geom.Geometry) return jsts.geom.util.LinearComponentExtracter.getLines4.apply(this, arguments);
				if (3 == arguments.length) return jsts.geom.util.LinearComponentExtracter.getLines2.apply(this, arguments);
				for (var n = 0; n < t.length; n++) {
					var i = t[n];
					jsts.geom.util.LinearComponentExtracter.getLines3(i, e)
				}
				return e
			}, jsts.geom.util.LinearComponentExtracter.getLines2 = function(t, e, n) {
				for (var i = 0; i < t.length; i++) {
					var o = t[i];
					jsts.geom.util.LinearComponentExtracter.getLines4(o, e, n)
				}
				return e
			}, jsts.geom.util.LinearComponentExtracter.getLines3 = function(t, e) {
				return t instanceof LineString ? e.add(t) : t.apply(new jsts.geom.util.LinearComponentExtracter(e)), e
			}, jsts.geom.util.LinearComponentExtracter.getLines4 = function(t, e, n) {
				return t.apply(new jsts.geom.util.LinearComponentExtracter(e, n)), e
			}, jsts.geom.util.LinearComponentExtracter.getLines5 = function(t) {
				return jsts.geom.util.LinearComponentExtracter.getLines6(t, !1)
			}, jsts.geom.util.LinearComponentExtracter.getLines6 = function(t, e) {
				var n = [];
				return t.apply(new jsts.geom.util.LinearComponentExtracter(n, e)), n
			}, jsts.geom.util.LinearComponentExtracter.prototype.setForceToLineString = function(t) {
				this.isForcedToLineString = t
			}, jsts.geom.util.LinearComponentExtracter.prototype.filter = function(t) {
				if (this.isForcedToLineString && t instanceof jsts.geom.LinearRing) {
					var e = t.getFactory().createLineString(t.getCoordinateSequence());
					return void this.lines.push(e)
				}(t instanceof jsts.geom.LineString || t instanceof jsts.geom.LinearRing) && this.lines.push(t)
			}, jsts.geom.Location = function() {}, jsts.geom.Location.INTERIOR = 0, jsts.geom.Location.BOUNDARY = 1, jsts.geom.Location.EXTERIOR = 2, jsts.geom.Location.NONE = -1, jsts.geom.Location.toLocationSymbol = function(t) {
				switch (t) {
				case jsts.geom.Location.EXTERIOR:
					return "e";
				case jsts.geom.Location.BOUNDARY:
					return "b";
				case jsts.geom.Location.INTERIOR:
					return "i";
				case jsts.geom.Location.NONE:
					return "-"
				}
				throw new jsts.IllegalArgumentError("Unknown location value: " + t)
			}, function() {
				jsts.io.GeoJSONReader = function(t) {
					this.geometryFactory = t || new jsts.geom.GeometryFactory, this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new jsts.io.GeoJSONParser(this.geometryFactory)
				}, jsts.io.GeoJSONReader.prototype.read = function(t) {
					var e = this.parser.read(t);
					return this.precisionModel.getType() === jsts.geom.PrecisionModel.FIXED && this.reducePrecision(e), e
				}, jsts.io.GeoJSONReader.prototype.reducePrecision = function(t) {
					var e, n;
					if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);
					else if (t.points) for (e = 0, n = t.points.length; n > e; e++) this.precisionModel.makePrecise(t.points[e]);
					else if (t.geometries) for (e = 0, n = t.geometries.length; n > e; e++) this.reducePrecision(t.geometries[e])
				}
			}(), jsts.geom.Geometry = function(t) {
				this.factory = t
			}, jsts.geom.Geometry.prototype.envelope = null, jsts.geom.Geometry.prototype.factory = null, jsts.geom.Geometry.prototype.getGeometryType = function() {
				return "Geometry"
			}, jsts.geom.Geometry.hasNonEmptyElements = function(t) {
				var e;
				for (e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;
				return !1
			}, jsts.geom.Geometry.hasNullElements = function(t) {
				var e;
				for (e = 0; e < t.length; e++) if (null === t[e]) return !0;
				return !1
			}, jsts.geom.Geometry.prototype.getFactory = function() {
				return (null === this.factory || void 0 === this.factory) && (this.factory = new jsts.geom.GeometryFactory), this.factory
			}, jsts.geom.Geometry.prototype.getNumGeometries = function() {
				return 1
			}, jsts.geom.Geometry.prototype.getGeometryN = function() {
				return this
			}, jsts.geom.Geometry.prototype.getPrecisionModel = function() {
				return this.getFactory().getPrecisionModel()
			}, jsts.geom.Geometry.prototype.getCoordinate = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.getCoordinates = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.getNumPoints = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.isSimple = function() {
				this.checkNotGeometryCollection(this);
				var t = new jsts.operation.IsSimpleOp(this);
				return t.isSimple()
			}, jsts.geom.Geometry.prototype.isValid = function() {
				var t = new jsts.operation.valid.IsValidOp(this);
				return t.isValid()
			}, jsts.geom.Geometry.prototype.isEmpty = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.distance = function(t) {
				return jsts.operation.distance.DistanceOp.distance(this, t)
			}, jsts.geom.Geometry.prototype.isWithinDistance = function(t, e) {
				var n = this.getEnvelopeInternal().distance(t.getEnvelopeInternal());
				return !(n > e) && DistanceOp.isWithinDistance(this, t, e)
			}, jsts.geom.Geometry.prototype.isRectangle = function() {
				return !1
			}, jsts.geom.Geometry.prototype.getArea = function() {
				return 0
			}, jsts.geom.Geometry.prototype.getLength = function() {
				return 0
			}, jsts.geom.Geometry.prototype.getCentroid = function() {
				if (this.isEmpty()) return null;
				var t, e = null,
					n = this.getDimension();
				return 0 === n ? (t = new jsts.algorithm.CentroidPoint, t.add(this), e = t.getCentroid()) : 1 === n ? (t = new jsts.algorithm.CentroidLine, t.add(this), e = t.getCentroid()) : (t = new jsts.algorithm.CentroidArea, t.add(this), e = t.getCentroid()), this.createPointFromInternalCoord(e, this)
			}, jsts.geom.Geometry.prototype.getInteriorPoint = function() {
				var t, e = null,
					n = this.getDimension();
				return 0 === n ? (t = new jsts.algorithm.InteriorPointPoint(this), e = t.getInteriorPoint()) : 1 === n ? (t = new jsts.algorithm.InteriorPointLine(this), e = t.getInteriorPoint()) : (t = new jsts.algorithm.InteriorPointArea(this), e = t.getInteriorPoint()), this.createPointFromInternalCoord(e, this)
			}, jsts.geom.Geometry.prototype.getDimension = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.getBoundary = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.getBoundaryDimension = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.getEnvelope = function() {
				return this.getFactory().toGeometry(this.getEnvelopeInternal())
			}, jsts.geom.Geometry.prototype.getEnvelopeInternal = function() {
				return null === this.envelope && (this.envelope = this.computeEnvelopeInternal()), this.envelope
			}, jsts.geom.Geometry.prototype.disjoint = function(t) {
				return !this.intersects(t)
			}, jsts.geom.Geometry.prototype.touches = function(t) {
				return !!this.getEnvelopeInternal().intersects(t.getEnvelopeInternal()) && this.relate(t).isTouches(this.getDimension(), t.getDimension())
			}, jsts.geom.Geometry.prototype.intersects = function(t) {
				return !!this.getEnvelopeInternal().intersects(t.getEnvelopeInternal()) && (this.isRectangle() ? jsts.operation.predicate.RectangleIntersects.intersects(this, t) : t.isRectangle() ? jsts.operation.predicate.RectangleIntersects.intersects(t, this) : this.relate(t).isIntersects())
			}, jsts.geom.Geometry.prototype.crosses = function(t) {
				return !!this.getEnvelopeInternal().intersects(t.getEnvelopeInternal()) && this.relate(t).isCrosses(this.getDimension(), t.getDimension())
			}, jsts.geom.Geometry.prototype.within = function(t) {
				return t.contains(this)
			}, jsts.geom.Geometry.prototype.contains = function(t) {
				return !!this.getEnvelopeInternal().contains(t.getEnvelopeInternal()) && (this.isRectangle() ? jsts.operation.predicate.RectangleContains.contains(this, t) : this.relate(t).isContains())
			}, jsts.geom.Geometry.prototype.overlaps = function(t) {
				return !!this.getEnvelopeInternal().intersects(t.getEnvelopeInternal()) && this.relate(t).isOverlaps(this.getDimension(), t.getDimension())
			}, jsts.geom.Geometry.prototype.covers = function(t) {
				return !!this.getEnvelopeInternal().covers(t.getEnvelopeInternal()) && ( !! this.isRectangle() || this.relate(t).isCovers())
			}, jsts.geom.Geometry.prototype.coveredBy = function(t) {
				return t.covers(this)
			}, jsts.geom.Geometry.prototype.relate = function(t, e) {
				return 1 === arguments.length ? this.relate2.apply(this, arguments) : this.relate2(t).matches(e)
			}, jsts.geom.Geometry.prototype.relate2 = function(t) {
				return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), jsts.operation.relate.RelateOp.relate(this, t)
			}, jsts.geom.Geometry.prototype.equalsTopo = function(t) {
				return !!this.getEnvelopeInternal().equals(t.getEnvelopeInternal()) && this.relate(t).isEquals(this.getDimension(), t.getDimension())
			}, jsts.geom.Geometry.prototype.equals = function(t) {
				return (t instanceof jsts.geom.Geometry || t instanceof jsts.geom.LinearRing || t instanceof jsts.geom.Polygon || t instanceof jsts.geom.GeometryCollection || t instanceof jsts.geom.MultiPoint || t instanceof jsts.geom.MultiLineString || t instanceof jsts.geom.MultiPolygon) && this.equalsExact(t)
			}, jsts.geom.Geometry.prototype.buffer = function(t, e, n) {
				var i = new jsts.operation.buffer.BufferParameters(e, n);
				return jsts.operation.buffer.BufferOp.bufferOp2(this, t, i)
			}, jsts.geom.Geometry.prototype.convexHull = function() {
				return new jsts.algorithm.ConvexHull(this).getConvexHull()
			}, jsts.geom.Geometry.prototype.intersection = function(t) {
				return this.isEmpty() ? this.getFactory().createGeometryCollection(null) : t.isEmpty() ? this.getFactory().createGeometryCollection(null) : (this.isGeometryCollection(this), this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this, t, jsts.operation.overlay.OverlayOp.INTERSECTION))
			}, jsts.geom.Geometry.prototype.union = function(t) {
				return 0 === arguments.length ? jsts.operation.union.UnaryUnionOp.union(this) : this.isEmpty() ? t.clone() : t.isEmpty() ? this.clone() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this, t, jsts.operation.overlay.OverlayOp.UNION))
			}, jsts.geom.Geometry.prototype.difference = function(t) {
				return this.isEmpty() ? this.getFactory().createGeometryCollection(null) : t.isEmpty() ? this.clone() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this, t, jsts.operation.overlay.OverlayOp.DIFFERENCE))
			}, jsts.geom.Geometry.prototype.symDifference = function(t) {
				return this.isEmpty() ? t.clone() : t.isEmpty() ? this.clone() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(t), jsts.operation.overlay.snap.SnapIfNeededOverlayOp.overlayOp(this, t, jsts.operation.overlay.OverlayOp.SYMDIFFERENCE))
			}, jsts.geom.Geometry.prototype.equalsExact = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.equalsNorm = function(t) {
				return null !== t && void 0 !== t && this.norm().equalsExact(t.norm())
			}, jsts.geom.Geometry.prototype.apply = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.clone = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.normalize = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.norm = function() {
				var t = this.clone();
				return t.normalize(), t
			}, jsts.geom.Geometry.prototype.compareTo = function(t) {
				var e = t;
				return this.getClassSortIndex() !== e.getClassSortIndex() ? this.getClassSortIndex() - e.getClassSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t)
			}, jsts.geom.Geometry.prototype.isEquivalentClass = function(t) {
				return this instanceof jsts.geom.Point && t instanceof jsts.geom.Point || ( !! (this instanceof jsts.geom.LineString && t instanceof jsts.geom.LineString | t instanceof jsts.geom.LinearRing) || ( !! (this instanceof jsts.geom.LinearRing && t instanceof jsts.geom.LineString | t instanceof jsts.geom.LinearRing) || (this instanceof jsts.geom.Polygon && t instanceof jsts.geom.Polygon || (this instanceof jsts.geom.MultiPoint && t instanceof jsts.geom.MultiPoint || (this instanceof jsts.geom.MultiLineString && t instanceof jsts.geom.MultiLineString || (this instanceof jsts.geom.MultiPolygon && t instanceof jsts.geom.MultiPolygon || this instanceof jsts.geom.GeometryCollection && t instanceof jsts.geom.GeometryCollection))))))
			}, jsts.geom.Geometry.prototype.checkNotGeometryCollection = function(t) {
				if (t.isGeometryCollectionBase()) throw new jsts.error.IllegalArgumentError("This method does not support GeometryCollection")
			}, jsts.geom.Geometry.prototype.isGeometryCollection = function() {
				return this instanceof jsts.geom.GeometryCollection
			}, jsts.geom.Geometry.prototype.isGeometryCollectionBase = function() {
				return "jsts.geom.GeometryCollection" === this.CLASS_NAME
			}, jsts.geom.Geometry.prototype.computeEnvelopeInternal = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.compareToSameClass = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.Geometry.prototype.compare = function(t, e) {
				for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext();) {
					var o = n.next(),
						r = i.next(),
						s = o.compareTo(r);
					if (0 !== s) return s
				}
				return n.hasNext() ? 1 : i.hasNext() ? -1 : 0
			}, jsts.geom.Geometry.prototype.equal = function(t, e, n) {
				return void 0 === n || null === n || 0 === n ? t.equals(e) : t.distance(e) <= n
			}, jsts.geom.Geometry.prototype.getClassSortIndex = function() {
				for (var t = [jsts.geom.Point, jsts.geom.MultiPoint, jsts.geom.LineString, jsts.geom.LinearRing, jsts.geom.MultiLineString, jsts.geom.Polygon, jsts.geom.MultiPolygon, jsts.geom.GeometryCollection], e = 0; e < t.length; e++) if (this instanceof t[e]) return e;
				return jsts.util.Assert.shouldNeverReachHere("Class not supported: " + this), -1
			}, jsts.geom.Geometry.prototype.toString = function() {
				return (new jsts.io.WKTWriter).write(this)
			}, jsts.geom.Geometry.prototype.createPointFromInternalCoord = function(t, e) {
				return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t)
			}, function() {
				jsts.geom.Coordinate = function(t, e) {
					"number" == typeof t ? (this.x = t, this.y = e) : t instanceof jsts.geom.Coordinate ? (this.x = parseFloat(t.x), this.y = parseFloat(t.y)) : void 0 === t || null === t ? (this.x = 0, this.y = 0) : "string" == typeof t && (this.x = parseFloat(t), this.y = parseFloat(e))
				}, jsts.geom.Coordinate.prototype.setCoordinate = function(t) {
					this.x = t.x, this.y = t.y
				}, jsts.geom.Coordinate.prototype.clone = function() {
					return new jsts.geom.Coordinate(this.x, this.y)
				}, jsts.geom.Coordinate.prototype.distance = function(t) {
					var e = this.x - t.x,
						n = this.y - t.y;
					return Math.sqrt(e * e + n * n)
				}, jsts.geom.Coordinate.prototype.equals2D = function(t) {
					return this.x === t.x && this.y === t.y
				}, jsts.geom.Coordinate.prototype.equals = function(t) {
					return !(!t instanceof jsts.geom.Coordinate || void 0 === t) && this.equals2D(t)
				}, jsts.geom.Coordinate.prototype.compareTo = function(t) {
					return this.x < t.x ? -1 : this.x > t.x ? 1 : this.y < t.y ? -1 : this.y > t.y ? 1 : 0
				}, jsts.geom.Coordinate.prototype.toString = function() {
					return "(" + this.x + ", " + this.y + ")"
				}
			}(), jsts.geom.Envelope = function() {
				jsts.geom.Envelope.prototype.init.apply(this, arguments)
			}, jsts.geom.Envelope.prototype.minx = null, jsts.geom.Envelope.prototype.maxx = null, jsts.geom.Envelope.prototype.miny = null, jsts.geom.Envelope.prototype.maxy = null, jsts.geom.Envelope.prototype.init = function() {
				"number" == typeof arguments[0] && 4 === arguments.length ? this.initFromValues(arguments[0], arguments[1], arguments[2], arguments[3]) : arguments[0] instanceof jsts.geom.Coordinate && 1 === arguments.length ? this.initFromCoordinate(arguments[0]) : arguments[0] instanceof jsts.geom.Coordinate && 2 === arguments.length ? this.initFromCoordinates(arguments[0], arguments[1]) : arguments[0] instanceof jsts.geom.Envelope && 1 === arguments.length ? this.initFromEnvelope(arguments[0]) : this.setToNull()
			}, jsts.geom.Envelope.prototype.initFromValues = function(t, e, n, i) {
				e > t ? (this.minx = t, this.maxx = e) : (this.minx = e, this.maxx = t), i > n ? (this.miny = n, this.maxy = i) : (this.miny = i, this.maxy = n)
			}, jsts.geom.Envelope.prototype.initFromCoordinates = function(t, e) {
				this.initFromValues(t.x, e.x, t.y, e.y)
			}, jsts.geom.Envelope.prototype.initFromCoordinate = function(t) {
				this.initFromValues(t.x, t.x, t.y, t.y)
			}, jsts.geom.Envelope.prototype.initFromEnvelope = function(t) {
				this.minx = t.minx, this.maxx = t.maxx, this.miny = t.miny, this.maxy = t.maxy
			}, jsts.geom.Envelope.prototype.setToNull = function() {
				this.minx = 0, this.maxx = -1, this.miny = 0, this.maxy = -1
			}, jsts.geom.Envelope.prototype.isNull = function() {
				return this.maxx < this.minx
			}, jsts.geom.Envelope.prototype.getHeight = function() {
				return this.isNull() ? 0 : this.maxy - this.miny
			}, jsts.geom.Envelope.prototype.getWidth = function() {
				return this.isNull() ? 0 : this.maxx - this.minx
			}, jsts.geom.Envelope.prototype.getMinX = function() {
				return this.minx
			}, jsts.geom.Envelope.prototype.getMaxX = function() {
				return this.maxx
			}, jsts.geom.Envelope.prototype.getMinY = function() {
				return this.miny
			}, jsts.geom.Envelope.prototype.getMaxY = function() {
				return this.maxy
			}, jsts.geom.Envelope.prototype.getArea = function() {
				return this.getWidth() * this.getHeight()
			}, jsts.geom.Envelope.prototype.expandToInclude = function() {
				arguments[0] instanceof jsts.geom.Coordinate ? this.expandToIncludeCoordinate(arguments[0]) : arguments[0] instanceof jsts.geom.Envelope ? this.expandToIncludeEnvelope(arguments[0]) : this.expandToIncludeValues(arguments[0], arguments[1])
			}, jsts.geom.Envelope.prototype.expandToIncludeCoordinate = function(t) {
				this.expandToIncludeValues(t.x, t.y)
			}, jsts.geom.Envelope.prototype.expandToIncludeValues = function(t, e) {
				this.isNull() ? (this.minx = t, this.maxx = t, this.miny = e, this.maxy = e) : (t < this.minx && (this.minx = t), t > this.maxx && (this.maxx = t), e < this.miny && (this.miny = e), e > this.maxy && (this.maxy = e))
			}, jsts.geom.Envelope.prototype.expandToIncludeEnvelope = function(t) {
				t.isNull() || (this.isNull() ? (this.minx = t.getMinX(), this.maxx = t.getMaxX(), this.miny = t.getMinY(), this.maxy = t.getMaxY()) : (t.minx < this.minx && (this.minx = t.minx), t.maxx > this.maxx && (this.maxx = t.maxx), t.miny < this.miny && (this.miny = t.miny), t.maxy > this.maxy && (this.maxy = t.maxy)))
			}, jsts.geom.Envelope.prototype.expandBy = function() {
				1 === arguments.length ? this.expandByDistance(arguments[0]) : this.expandByDistances(arguments[0], arguments[1])
			}, jsts.geom.Envelope.prototype.expandByDistance = function(t) {
				this.expandByDistances(t, t)
			}, jsts.geom.Envelope.prototype.expandByDistances = function(t, e) {
				this.isNull() || (this.minx -= t, this.maxx += t, this.miny -= e, this.maxy += e, (this.minx > this.maxx || this.miny > this.maxy) && this.setToNull())
			}, jsts.geom.Envelope.prototype.translate = function(t, e) {
				this.isNull() || this.init(this.minx + t, this.maxx + t, this.miny + e, this.maxy + e)
			}, jsts.geom.Envelope.prototype.centre = function() {
				return this.isNull() ? null : new jsts.geom.Coordinate((this.minx + this.maxx) / 2, (this.miny + this.maxy) / 2)
			}, jsts.geom.Envelope.prototype.intersection = function(t) {
				if (this.isNull() || t.isNull() || !this.intersects(t)) return new jsts.geom.Envelope;
				var e = this.minx > t.minx ? this.minx : t.minx,
					n = this.miny > t.miny ? this.miny : t.miny,
					i = this.maxx < t.maxx ? this.maxx : t.maxx,
					o = this.maxy < t.maxy ? this.maxy : t.maxy;
				return new jsts.geom.Envelope(e, i, n, o)
			}, jsts.geom.Envelope.prototype.intersects = function() {
				return arguments[0] instanceof jsts.geom.Envelope ? this.intersectsEnvelope(arguments[0]) : arguments[0] instanceof jsts.geom.Coordinate ? this.intersectsCoordinate(arguments[0]) : this.intersectsValues(arguments[0], arguments[1])
			}, jsts.geom.Envelope.prototype.intersectsEnvelope = function(t) {
				if (this.isNull() || t.isNull()) return !1;
				var e = !(t.minx > this.maxx || t.maxx < this.minx || t.miny > this.maxy || t.maxy < this.miny);
				return e
			}, jsts.geom.Envelope.prototype.intersectsCoordinate = function(t) {
				return this.intersectsValues(t.x, t.y)
			}, jsts.geom.Envelope.prototype.intersectsValues = function(t, e) {
				return !this.isNull() && !(t > this.maxx || t < this.minx || e > this.maxy || e < this.miny)
			}, jsts.geom.Envelope.prototype.contains = function() {
				return arguments[0] instanceof jsts.geom.Envelope ? this.containsEnvelope(arguments[0]) : arguments[0] instanceof jsts.geom.Coordinate ? this.containsCoordinate(arguments[0]) : this.containsValues(arguments[0], arguments[1])
			}, jsts.geom.Envelope.prototype.containsEnvelope = function(t) {
				return this.coversEnvelope(t)
			}, jsts.geom.Envelope.prototype.containsCoordinate = function(t) {
				return this.coversCoordinate(t)
			}, jsts.geom.Envelope.prototype.containsValues = function(t, e) {
				return this.coversValues(t, e)
			}, jsts.geom.Envelope.prototype.covers = function() {
				return arguments[0] instanceof jsts.geom.Envelope ? this.coversEnvelope(arguments[0]) : arguments[0] instanceof jsts.geom.Coordinate ? this.coversCoordinate(arguments[0]) : this.coversValues(arguments[0], arguments[1])
			}, jsts.geom.Envelope.prototype.coversValues = function(t, e) {
				return !this.isNull() && (t >= this.minx && t <= this.maxx && e >= this.miny && e <= this.maxy)
			}, jsts.geom.Envelope.prototype.coversCoordinate = function(t) {
				return this.coversValues(t.x, t.y)
			}, jsts.geom.Envelope.prototype.coversEnvelope = function(t) {
				return !this.isNull() && !t.isNull() && (t.minx >= this.minx && t.maxx <= this.maxx && t.miny >= this.miny && t.maxy <= this.maxy)
			}, jsts.geom.Envelope.prototype.distance = function(t) {
				if (this.intersects(t)) return 0;
				var e = 0;
				this.maxx < t.minx && (e = t.minx - this.maxx), this.minx > t.maxx && (e = this.minx - t.maxx);
				var n = 0;
				return this.maxy < t.miny && (n = t.miny - this.maxy), this.miny > t.maxy && (n = this.miny - t.maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n)
			}, jsts.geom.Envelope.prototype.equals = function(t) {
				return this.isNull() ? t.isNull() : this.maxx === t.maxx && this.maxy === t.maxy && this.minx === t.minx && this.miny === t.miny
			}, jsts.geom.Envelope.prototype.toString = function() {
				return "Env[" + this.minx + " : " + this.maxx + ", " + this.miny + " : " + this.maxy + "]"
			}, jsts.geom.Envelope.intersects = function(t, e, n) {
				if (4 === arguments.length) return jsts.geom.Envelope.intersectsEnvelope(arguments[0], arguments[1], arguments[2], arguments[3]);
				var i = t.x < e.x ? t.x : e.x,
					o = t.x > e.x ? t.x : e.x,
					r = t.y < e.y ? t.y : e.y,
					s = t.y > e.y ? t.y : e.y;
				return n.x >= i && n.x <= o && n.y >= r && n.y <= s
			}, jsts.geom.Envelope.intersectsEnvelope = function(t, e, n, i) {
				var o = Math.min(n.x, i.x),
					r = Math.max(n.x, i.x),
					s = Math.min(t.x, e.x),
					a = Math.max(t.x, e.x);
				return !(s > r) && (!(o > a) && (o = Math.min(n.y, i.y), r = Math.max(n.y, i.y), s = Math.min(t.y, e.y), a = Math.max(t.y, e.y), !(s > r) && !(o > a)))
			}, jsts.geom.Envelope.prototype.clone = function() {
				return new jsts.geom.Envelope(this.minx, this.maxx, this.miny, this.maxy)
			}, jsts.geom.util.GeometryCombiner = function(t) {
				this.geomFactory = jsts.geom.util.GeometryCombiner.extractFactory(t), this.inputGeoms = t
			}, jsts.geom.util.GeometryCombiner.combine = function(t) {
				if (arguments.length > 1) return this.combine2.apply(this, arguments);
				var e = new jsts.geom.util.GeometryCombiner(t);
				return e.combine()
			}, jsts.geom.util.GeometryCombiner.combine2 = function() {
				var t = new javascript.util.ArrayList;
				Array.prototype.slice.call(arguments).forEach(function(e) {
					t.add(e)
				});
				var e = new jsts.geom.util.GeometryCombiner(t);
				return e.combine()
			}, jsts.geom.util.GeometryCombiner.prototype.geomFactory = null, jsts.geom.util.GeometryCombiner.prototype.skipEmpty = !1, jsts.geom.util.GeometryCombiner.prototype.inputGeoms, jsts.geom.util.GeometryCombiner.extractFactory = function(t) {
				return t.isEmpty() ? null : t.iterator().next().getFactory()
			}, jsts.geom.util.GeometryCombiner.prototype.combine = function() {
				var t, e = new javascript.util.ArrayList;
				for (t = this.inputGeoms.iterator(); t.hasNext();) {
					var n = t.next();
					this.extractElements(n, e)
				}
				return 0 === e.size() ? null !== this.geomFactory ? this.geomFactory.createGeometryCollection(null) : null : this.geomFactory.buildGeometry(e)
			}, jsts.geom.util.GeometryCombiner.prototype.extractElements = function(t, e) {
				if (null !== t) for (var n = 0; n < t.getNumGeometries(); n++) {
					var i = t.getGeometryN(n);
					this.skipEmpty && i.isEmpty() || e.add(i)
				}
			}, jsts.geom.PrecisionModel = function(t) {
				return "number" == typeof t ? (this.modelType = jsts.geom.PrecisionModel.FIXED, void(this.scale = t)) : (this.modelType = t || jsts.geom.PrecisionModel.FLOATING, void(this.modelType === jsts.geom.PrecisionModel.FIXED && (this.scale = 1)))
			}, jsts.geom.PrecisionModel.FLOATING = "FLOATING", jsts.geom.PrecisionModel.FIXED = "FIXED", jsts.geom.PrecisionModel.FLOATING_SINGLE = "FLOATING_SINGLE", jsts.geom.PrecisionModel.prototype.scale = null, jsts.geom.PrecisionModel.prototype.modelType = null, jsts.geom.PrecisionModel.prototype.isFloating = function() {
				return this.modelType === jsts.geom.PrecisionModel.FLOATING || this.modelType === jsts.geom.PrecisionModel.FLOATING_SINLGE
			}, jsts.geom.PrecisionModel.prototype.getScale = function() {
				return this.scale
			}, jsts.geom.PrecisionModel.prototype.getType = function() {
				return this.modelType
			}, jsts.geom.PrecisionModel.prototype.equals = function(t) {
				return !0
			}, jsts.geom.PrecisionModel.prototype.makePrecise = function(t) {
				return t instanceof jsts.geom.Coordinate ? void this.makePrecise2(t) : isNaN(t) ? t : this.modelType === jsts.geom.PrecisionModel.FIXED ? Math.round(t * this.scale) / this.scale : t
			}, jsts.geom.PrecisionModel.prototype.makePrecise2 = function(t) {
				this.modelType !== jsts.geom.PrecisionModel.FLOATING && (t.x = this.makePrecise(t.x), t.y = this.makePrecise(t.y))
			}, jsts.geom.PrecisionModel.prototype.compareTo = function(t) {
				return 0
			}, jsts.geom.CoordinateFilter = function() {}, jsts.geom.CoordinateFilter.prototype.filter = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.simplify.DouglasPeuckerLineSimplifier = function(t) {
				this.pts = t, this.seg = new jsts.geom.LineSegment
			}, jsts.simplify.DouglasPeuckerLineSimplifier.prototype.pts = null, jsts.simplify.DouglasPeuckerLineSimplifier.prototype.usePt = null, jsts.simplify.DouglasPeuckerLineSimplifier.prototype.distanceTolerance = null, jsts.simplify.DouglasPeuckerLineSimplifier.simplify = function(t, e) {
				var n = new jsts.simplify.DouglasPeuckerLineSimplifier(t);
				return n.setDistanceTolerance(e), n.simplify()
			}, jsts.simplify.DouglasPeuckerLineSimplifier.prototype.setDistanceTolerance = function(t) {
				this.distanceTolerance = t
			}, jsts.simplify.DouglasPeuckerLineSimplifier.prototype.simplify = function() {
				this.usePt = [];
				for (var t = 0; t < this.pts.length; t++) this.usePt[t] = !0;
				this.simplifySection(0, this.pts.length - 1);
				for (var e = new jsts.geom.CoordinateList, n = 0; n < this.pts.length; n++) this.usePt[n] && e.add(new jsts.geom.Coordinate(this.pts[n]));
				return e.toCoordinateArray()
			}, jsts.simplify.DouglasPeuckerLineSimplifier.prototype.seg = null, jsts.simplify.DouglasPeuckerLineSimplifier.prototype.simplifySection = function(t, e) {
				if (t + 1 != e) {
					this.seg.p0 = this.pts[t], this.seg.p1 = this.pts[e];
					for (var n = -1, i = t, o = t + 1; e > o; o++) {
						var r = this.seg.distance(this.pts[o]);
						r > n && (n = r, i = o)
					}
					if (n <= this.distanceTolerance) for (var s = t + 1; e > s; s++) this.usePt[s] = !1;
					else this.simplifySection(t, i), this.simplifySection(i, e)
				}
			}, jsts.geomgraph.EdgeIntersection = function(t, e, n) {
				this.coord = new jsts.geom.Coordinate(t), this.segmentIndex = e, this.dist = n
			}, jsts.geomgraph.EdgeIntersection.prototype.coord = null, jsts.geomgraph.EdgeIntersection.prototype.segmentIndex = null, jsts.geomgraph.EdgeIntersection.prototype.dist = null, jsts.geomgraph.EdgeIntersection.prototype.getCoordinate = function() {
				return this.coord
			}, jsts.geomgraph.EdgeIntersection.prototype.getSegmentIndex = function() {
				return this.segmentIndex
			}, jsts.geomgraph.EdgeIntersection.prototype.getDistance = function() {
				return this.dist
			}, jsts.geomgraph.EdgeIntersection.prototype.compareTo = function(t) {
				return this.compare(t.segmentIndex, t.dist)
			}, jsts.geomgraph.EdgeIntersection.prototype.compare = function(t, e) {
				return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0
			}, jsts.geomgraph.EdgeIntersection.prototype.isEndPoint = function(t) {
				return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t
			}, jsts.geomgraph.EdgeIntersection.prototype.toString = function() {
				return "" + this.segmentIndex + this.dist
			}, function() {
				var t = jsts.geomgraph.EdgeIntersection,
					e = javascript.util.TreeMap;
				jsts.geomgraph.EdgeIntersectionList = function(t) {
					this.nodeMap = new e, this.edge = t
				}, jsts.geomgraph.EdgeIntersectionList.prototype.nodeMap = null, jsts.geomgraph.EdgeIntersectionList.prototype.edge = null, jsts.geomgraph.EdgeIntersectionList.prototype.isIntersection = function(t) {
					for (var e = this.iterator(); e.hasNext();) {
						var n = e.next();
						if (n.coord.equals(t)) return !0
					}
					return !1
				}, jsts.geomgraph.EdgeIntersectionList.prototype.add = function(e, n, i) {
					var o = new t(e, n, i),
						r = this.nodeMap.get(o);
					return null !== r ? r : (this.nodeMap.put(o, o), o)
				}, jsts.geomgraph.EdgeIntersectionList.prototype.iterator = function() {
					return this.nodeMap.values().iterator()
				}, jsts.geomgraph.EdgeIntersectionList.prototype.addEndpoints = function() {
					var t = this.edge.pts.length - 1;
					this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0)
				}, jsts.geomgraph.EdgeIntersectionList.prototype.addSplitEdges = function(t) {
					this.addEndpoints();
					for (var e = this.iterator(), n = e.next(); e.hasNext();) {
						var i = e.next(),
							o = this.createSplitEdge(n, i);
						t.add(o), n = i
					}
				}, jsts.geomgraph.EdgeIntersectionList.prototype.createSplitEdge = function(t, e) {
					var n = e.segmentIndex - t.segmentIndex + 2,
						i = this.edge.pts[e.segmentIndex],
						o = e.dist > 0 || !e.coord.equals2D(i);
					o || n--;
					var r = [],
						s = 0;
					r[s++] = new jsts.geom.Coordinate(t.coord);
					for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) r[s++] = this.edge.pts[a];
					return o && (r[s] = e.coord), new jsts.geomgraph.Edge(r, new jsts.geomgraph.Label(this.edge.label))
				}
			}(), function() {
				var t = function(t) {
						this.message = t
					};
				t.prototype = new Error, t.prototype.name = "AssertionFailedException", jsts.util.AssertionFailedException = t
			}(), function() {
				var t = jsts.util.AssertionFailedException;
				jsts.util.Assert = function() {}, jsts.util.Assert.isTrue = function(e, n) {
					if (!e) throw null === n ? new t : new t(n)
				}, jsts.util.Assert.equals = function(e, n, i) {
					if (!n.equals(e)) throw new t("Expected " + e + " but encountered " + n + (null != i ? ": " + i : ""))
				}, jsts.util.Assert.shouldNeverReachHere = function(e) {
					throw new t("Should never reach here" + (null != e ? ": " + e : ""))
				}
			}(), function() {
				var t = jsts.geom.Location,
					e = jsts.util.Assert,
					n = javascript.util.ArrayList;
				jsts.operation.relate.RelateComputer = function(t) {
					this.li = new jsts.algorithm.RobustLineIntersector, this.ptLocator = new jsts.algorithm.PointLocator, this.nodes = new jsts.geomgraph.NodeMap(new jsts.operation.relate.RelateNodeFactory), this.isolatedEdges = new n, this.arg = t
				}, jsts.operation.relate.RelateComputer.prototype.li = null, jsts.operation.relate.RelateComputer.prototype.ptLocator = null, jsts.operation.relate.RelateComputer.prototype.arg = null, jsts.operation.relate.RelateComputer.prototype.nodes = null, jsts.operation.relate.RelateComputer.prototype.im = null, jsts.operation.relate.RelateComputer.prototype.isolatedEdges = null, jsts.operation.relate.RelateComputer.prototype.invalidPoint = null, jsts.operation.relate.RelateComputer.prototype.computeIM = function() {
					var e = new jsts.geom.IntersectionMatrix;
					if (e.set(t.EXTERIOR, t.EXTERIOR, 2), !this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal())) return this.computeDisjointIM(e), e;
					this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1);
					var n = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !1);
					this.computeIntersectionNodes(0), this.computeIntersectionNodes(1), this.copyNodesAndLabels(0), this.copyNodesAndLabels(1), this.labelIsolatedNodes(), this.computeProperIntersectionIM(n, e);
					var i = new jsts.operation.relate.EdgeEndBuilder,
						o = i.computeEdgeEnds(this.arg[0].getEdgeIterator());
					this.insertEdgeEnds(o);
					var r = i.computeEdgeEnds(this.arg[1].getEdgeIterator());
					return this.insertEdgeEnds(r), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(e), e
				}, jsts.operation.relate.RelateComputer.prototype.insertEdgeEnds = function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var n = e.next();
						this.nodes.add(n)
					}
				}, jsts.operation.relate.RelateComputer.prototype.computeProperIntersectionIM = function(t, e) {
					var n = this.arg[0].getGeometry().getDimension(),
						i = this.arg[1].getGeometry().getDimension(),
						o = t.hasProperIntersection(),
						r = t.hasProperInteriorIntersection();
					2 === n && 2 === i ? o && e.setAtLeast("212101212") : 2 === n && 1 === i ? (o && e.setAtLeast("FFF0FFFF2"), r && e.setAtLeast("1FFFFF1FF")) : 1 === n && 2 === i ? (o && e.setAtLeast("F0FFFFFF2"), r && e.setAtLeast("1F1FFFFFF")) : 1 === n && 1 === i && r && e.setAtLeast("0FFFFFFFF")
				}, jsts.operation.relate.RelateComputer.prototype.copyNodesAndLabels = function(t) {
					for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
						var n = e.next(),
							i = this.nodes.addNode(n.getCoordinate());
						i.setLabel(t, n.getLabel().getLocation(t))
					}
				}, jsts.operation.relate.RelateComputer.prototype.computeIntersectionNodes = function(e) {
					for (var n = this.arg[e].getEdgeIterator(); n.hasNext();) for (var i = n.next(), o = i.getLabel().getLocation(e), r = i.getEdgeIntersectionList().iterator(); r.hasNext();) {
						var s = r.next(),
							a = this.nodes.addNode(s.coord);
						o === t.BOUNDARY ? a.setLabelBoundary(e) : a.getLabel().isNull(e) && a.setLabel(e, t.INTERIOR)
					}
				}, jsts.operation.relate.RelateComputer.prototype.labelIntersectionNodes = function(e) {
					for (var n = this.arg[e].getEdgeIterator(); n.hasNext();) for (var i = n.next(), o = i.getLabel().getLocation(e), r = i.getEdgeIntersectionList().iterator(); r.hasNext();) {
						var s = r.next(),
							a = this.nodes.find(s.coord);
						a.getLabel().isNull(e) && (o === t.BOUNDARY ? a.setLabelBoundary(e) : a.setLabel(e, t.INTERIOR))
					}
				}, jsts.operation.relate.RelateComputer.prototype.computeDisjointIM = function(e) {
					var n = this.arg[0].getGeometry();
					n.isEmpty() || (e.set(t.INTERIOR, t.EXTERIOR, n.getDimension()), e.set(t.BOUNDARY, t.EXTERIOR, n.getBoundaryDimension()));
					var i = this.arg[1].getGeometry();
					i.isEmpty() || (e.set(t.EXTERIOR, t.INTERIOR, i.getDimension()), e.set(t.EXTERIOR, t.BOUNDARY, i.getBoundaryDimension()))
				}, jsts.operation.relate.RelateComputer.prototype.labelNodeEdges = function() {
					for (var t = this.nodes.iterator(); t.hasNext();) {
						var e = t.next();
						e.getEdges().computeLabelling(this.arg)
					}
				}, jsts.operation.relate.RelateComputer.prototype.updateIM = function(t) {
					for (var e = this.isolatedEdges.iterator(); e.hasNext();) {
						var n = e.next();
						n.updateIM(t)
					}
					for (var i = this.nodes.iterator(); i.hasNext();) {
						var o = i.next();
						o.updateIM(t), o.updateIMFromEdges(t)
					}
				}, jsts.operation.relate.RelateComputer.prototype.labelIsolatedEdges = function(t, e) {
					for (var n = this.arg[t].getEdgeIterator(); n.hasNext();) {
						var i = n.next();
						i.isIsolated() && (this.labelIsolatedEdge(i, e, this.arg[e].getGeometry()), this.isolatedEdges.add(i))
					}
				}, jsts.operation.relate.RelateComputer.prototype.labelIsolatedEdge = function(e, n, i) {
					if (i.getDimension() > 0) {
						var o = this.ptLocator.locate(e.getCoordinate(), i);
						e.getLabel().setAllLocations(n, o)
					} else e.getLabel().setAllLocations(n, t.EXTERIOR)
				}, jsts.operation.relate.RelateComputer.prototype.labelIsolatedNodes = function() {
					for (var t = this.nodes.iterator(); t.hasNext();) {
						var n = t.next(),
							i = n.getLabel();
						e.isTrue(i.getGeometryCount() > 0, "node with empty label found"), n.isIsolated() && (i.isNull(0) ? this.labelIsolatedNode(n, 0) : this.labelIsolatedNode(n, 1))
					}
				}, jsts.operation.relate.RelateComputer.prototype.labelIsolatedNode = function(t, e) {
					var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());
					t.getLabel().setAllLocations(e, n)
				}
			}(), function() {
				var t = jsts.util.Assert;
				jsts.geomgraph.GraphComponent = function(t) {
					this.label = t
				}, jsts.geomgraph.GraphComponent.prototype.label = null, jsts.geomgraph.GraphComponent.prototype._isInResult = !1, jsts.geomgraph.GraphComponent.prototype._isCovered = !1, jsts.geomgraph.GraphComponent.prototype._isCoveredSet = !1, jsts.geomgraph.GraphComponent.prototype._isVisited = !1, jsts.geomgraph.GraphComponent.prototype.getLabel = function() {
					return this.label
				}, jsts.geomgraph.GraphComponent.prototype.setLabel = function(t) {
					return 2 === arguments.length ? void this.setLabel2.apply(this, arguments) : void(this.label = t)
				}, jsts.geomgraph.GraphComponent.prototype.setInResult = function(t) {
					this._isInResult = t
				}, jsts.geomgraph.GraphComponent.prototype.isInResult = function() {
					return this._isInResult
				}, jsts.geomgraph.GraphComponent.prototype.setCovered = function(t) {
					this._isCovered = t, this._isCoveredSet = !0
				}, jsts.geomgraph.GraphComponent.prototype.isCovered = function() {
					return this._isCovered
				}, jsts.geomgraph.GraphComponent.prototype.isCoveredSet = function() {
					return this._isCoveredSet
				}, jsts.geomgraph.GraphComponent.prototype.isVisited = function() {
					return this._isVisited
				}, jsts.geomgraph.GraphComponent.prototype.setVisited = function(t) {
					this._isVisited = t
				}, jsts.geomgraph.GraphComponent.prototype.getCoordinate = function() {
					throw new jsts.error.AbstractMethodInvocationError
				}, jsts.geomgraph.GraphComponent.prototype.computeIM = function() {
					throw new jsts.error.AbstractMethodInvocationError
				}, jsts.geomgraph.GraphComponent.prototype.isIsolated = function() {
					throw new jsts.error.AbstractMethodInvocationError
				}, jsts.geomgraph.GraphComponent.prototype.updateIM = function(e) {
					t.isTrue(this.label.getGeometryCount() >= 2, "found partial label"), this.computeIM(e)
				}
			}(), jsts.geomgraph.Node = function(t, e) {
				this.coord = t, this.edges = e, this.label = new jsts.geomgraph.Label(0, jsts.geom.Location.NONE)
			}, jsts.geomgraph.Node.prototype = new jsts.geomgraph.GraphComponent, jsts.geomgraph.Node.prototype.coord = null, jsts.geomgraph.Node.prototype.edges = null, jsts.geomgraph.Node.prototype.isIsolated = function() {
				return 1 == this.label.getGeometryCount()
			}, jsts.geomgraph.Node.prototype.setLabel2 = function(t, e) {
				null === this.label ? this.label = new jsts.geomgraph.Label(t, e) : this.label.setLocation(t, e)
			}, jsts.geomgraph.Node.prototype.setLabelBoundary = function(t) {
				var e = jsts.geom.Location.NONE;
				null !== this.label && (e = this.label.getLocation(t));
				var n;
				switch (e) {
				case jsts.geom.Location.BOUNDARY:
					n = jsts.geom.Location.INTERIOR;
					break;
				case jsts.geom.Location.INTERIOR:
					n = jsts.geom.Location.BOUNDARY;
					break;
				default:
					n = jsts.geom.Location.BOUNDARY
				}
				this.label.setLocation(t, n)
			}, jsts.geomgraph.Node.prototype.add = function(t) {
				this.edges.insert(t), t.setNode(this)
			}, jsts.geomgraph.Node.prototype.getCoordinate = function() {
				return this.coord
			}, jsts.geomgraph.Node.prototype.getEdges = function() {
				return this.edges
			}, jsts.geomgraph.Node.prototype.isIncidentEdgeInResult = function() {
				for (var t = this.getEdges().getEdges().iterator(); t.hasNext();) {
					var e = t.next();
					if (e.getEdge().isInResult()) return !0
				}
				return !1
			}, jsts.geom.Point = function(t, e) {
				this.factory = e, void 0 !== t && (this.coordinate = t)
			}, jsts.geom.Point.prototype = new jsts.geom.Geometry, jsts.geom.Point.constructor = jsts.geom.Point, jsts.geom.Point.CLASS_NAME = "jsts.geom.Point", jsts.geom.Point.prototype.coordinate = null, jsts.geom.Point.prototype.getX = function() {
				return this.coordinate.x
			}, jsts.geom.Point.prototype.getY = function() {
				return this.coordinate.y
			}, jsts.geom.Point.prototype.getCoordinate = function() {
				return this.coordinate
			}, jsts.geom.Point.prototype.getCoordinates = function() {
				return this.isEmpty() ? [] : [this.coordinate]
			}, jsts.geom.Point.prototype.getCoordinateSequence = function() {
				return this.isEmpty() ? [] : [this.coordinate]
			}, jsts.geom.Point.prototype.isEmpty = function() {
				return null === this.coordinate
			}, jsts.geom.Point.prototype.equalsExact = function(t, e) {
				return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.equal(t.getCoordinate(), this.getCoordinate(), e))
			}, jsts.geom.Point.prototype.getNumPoints = function() {
				return this.isEmpty() ? 0 : 1
			}, jsts.geom.Point.prototype.isSimple = function() {
				return !0
			}, jsts.geom.Point.prototype.getBoundary = function() {
				return new jsts.geom.GeometryCollection(null)
			}, jsts.geom.Point.prototype.computeEnvelopeInternal = function() {
				return this.isEmpty() ? new jsts.geom.Envelope : new jsts.geom.Envelope(this.coordinate)
			}, jsts.geom.Point.prototype.apply = function(t) {
				if (t instanceof jsts.geom.GeometryFilter || t instanceof jsts.geom.GeometryComponentFilter) t.filter(this);
				else if (t instanceof jsts.geom.CoordinateFilter) {
					if (this.isEmpty()) return;
					t.filter(this.getCoordinate())
				}
			}, jsts.geom.Point.prototype.clone = function() {
				return new jsts.geom.Point(this.coordinate.clone(), this.factory)
			}, jsts.geom.Point.prototype.getDimension = function() {
				return 0
			}, jsts.geom.Point.prototype.getBoundaryDimension = function() {
				return jsts.geom.Dimension.FALSE
			}, jsts.geom.Point.prototype.reverse = function() {
				return this.clone()
			}, jsts.geom.Point.prototype.isValid = function() {
				return !!jsts.operation.valid.IsValidOp.isValid(this.getCoordinate())
			}, jsts.geom.Point.prototype.normalize = function() {}, jsts.geom.Point.prototype.compareToSameClass = function(t) {
				var e = t;
				return this.getCoordinate().compareTo(e.getCoordinate())
			}, jsts.geom.Point.prototype.getGeometryType = function() {
				return "Point"
			}, jsts.geom.Point.prototype.hashCode = function() {
				return "Point_" + this.coordinate.hashCode()
			}, jsts.geom.Point.prototype.CLASS_NAME = "jsts.geom.Point", jsts.geom.Dimension = function() {}, jsts.geom.Dimension.P = 0, jsts.geom.Dimension.L = 1, jsts.geom.Dimension.A = 2, jsts.geom.Dimension.FALSE = -1, jsts.geom.Dimension.TRUE = -2, jsts.geom.Dimension.DONTCARE = -3, jsts.geom.Dimension.toDimensionSymbol = function(t) {
				switch (t) {
				case jsts.geom.Dimension.FALSE:
					return "F";
				case jsts.geom.Dimension.TRUE:
					return "T";
				case jsts.geom.Dimension.DONTCARE:
					return "*";
				case jsts.geom.Dimension.P:
					return "0";
				case jsts.geom.Dimension.L:
					return "1";
				case jsts.geom.Dimension.A:
					return "2"
				}
				throw new jsts.IllegalArgumentError("Unknown dimension value: " + t)
			}, jsts.geom.Dimension.toDimensionValue = function(t) {
				switch (t.toUpperCase()) {
				case "F":
					return jsts.geom.Dimension.FALSE;
				case "T":
					return jsts.geom.Dimension.TRUE;
				case "*":
					return jsts.geom.Dimension.DONTCARE;
				case "0":
					return jsts.geom.Dimension.P;
				case "1":
					return jsts.geom.Dimension.L;
				case "2":
					return jsts.geom.Dimension.A
				}
				throw new jsts.error.IllegalArgumentError("Unknown dimension symbol: " + t)
			}, function() {
				var t = jsts.geom.Dimension;
				jsts.geom.LineString = function(t, e) {
					this.factory = e, this.points = t || []
				}, jsts.geom.LineString.prototype = new jsts.geom.Geometry, jsts.geom.LineString.constructor = jsts.geom.LineString, jsts.geom.LineString.prototype.points = null, jsts.geom.LineString.prototype.getCoordinates = function() {
					return this.points
				}, jsts.geom.LineString.prototype.getCoordinateSequence = function() {
					return this.points
				}, jsts.geom.LineString.prototype.getCoordinateN = function(t) {
					return this.points[t]
				}, jsts.geom.LineString.prototype.getCoordinate = function() {
					return this.isEmpty() ? null : this.getCoordinateN(0)
				}, jsts.geom.LineString.prototype.getDimension = function() {
					return 1
				}, jsts.geom.LineString.prototype.getBoundaryDimension = function() {
					return this.isClosed() ? t.FALSE : 0
				}, jsts.geom.LineString.prototype.isEmpty = function() {
					return 0 === this.points.length
				}, jsts.geom.LineString.prototype.getNumPoints = function() {
					return this.points.length
				}, jsts.geom.LineString.prototype.getPointN = function(t) {
					return this.getFactory().createPoint(this.points[t])
				}, jsts.geom.LineString.prototype.getStartPoint = function() {
					return this.isEmpty() ? null : this.getPointN(0)
				}, jsts.geom.LineString.prototype.getEndPoint = function() {
					return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
				}, jsts.geom.LineString.prototype.isClosed = function() {
					return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.points.length - 1))
				}, jsts.geom.LineString.prototype.isRing = function() {
					return this.isClosed() && this.isSimple()
				}, jsts.geom.LineString.prototype.getGeometryType = function() {
					return "LineString"
				}, jsts.geom.LineString.prototype.getLength = function() {
					return jsts.algorithm.CGAlgorithms.computeLength(this.points)
				}, jsts.geom.LineString.prototype.getBoundary = function() {
					return new jsts.operation.BoundaryOp(this).getBoundary()
				}, jsts.geom.LineString.prototype.computeEnvelopeInternal = function() {
					if (this.isEmpty()) return new jsts.geom.Envelope;
					var t = new jsts.geom.Envelope;
					return this.points.forEach(function(e) {
						t.expandToInclude(e)
					}), t
				}, jsts.geom.LineString.prototype.equalsExact = function(t, e) {
					return !!this.isEquivalentClass(t) && (this.points.length === t.points.length && (!(!this.isEmpty() || !t.isEmpty()) || this.points.reduce(function(n, i, o) {
						return n && jsts.geom.Geometry.prototype.equal(i, t.points[o], e)
					})))
				}, jsts.geom.LineString.prototype.isEquivalentClass = function(t) {
					return t instanceof jsts.geom.LineString
				}, jsts.geom.LineString.prototype.compareToSameClass = function(t) {
					for (var e = t, n = 0, i = this.points.length, o = 0, r = e.points.length; i > n && r > o;) {
						var s = this.points[n].compareTo(e.points[o]);
						if (0 !== s) return s;
						n++, o++
					}
					return i > n ? 1 : r > o ? -1 : 0
				}, jsts.geom.LineString.prototype.apply = function(t) {
					if (t instanceof jsts.geom.GeometryFilter || t instanceof jsts.geom.GeometryComponentFilter) t.filter(this);
					else if (t instanceof jsts.geom.CoordinateFilter) for (var e = 0, n = this.points.length; n > e; e++) t.filter(this.points[e]);
					else t instanceof jsts.geom.CoordinateSequenceFilter && this.apply2.apply(this, arguments)
				}, jsts.geom.LineString.prototype.apply2 = function(t) {
					if (0 !== this.points.length) {
						for (var e = 0; e < this.points.length && (t.filter(this.points, e), !t.isDone()); e++);
						t.isGeometryChanged()
					}
				}, jsts.geom.LineString.prototype.clone = function() {
					for (var t = [], e = 0, n = this.points.length; n > e; e++) t.push(this.points[e].clone());
					return this.factory.createLineString(t)
				}, jsts.geom.LineString.prototype.normalize = function() {
					var t, e, n, i, o, r;
					for (r = this.points.length, e = parseInt(r / 2), t = 0; e > t; t++) if (n = r - 1 - t, i = this.points[t], o = this.points[n], !i.equals(o)) return void(i.compareTo(o) > 0 && this.points.reverse())
				}, jsts.geom.LineString.prototype.CLASS_NAME = "jsts.geom.LineString"
			}(), function() {
				jsts.geom.Polygon = function(t, e, n) {
					this.shell = t || n.createLinearRing(null), this.holes = e || [], this.factory = n
				}, jsts.geom.Polygon.prototype = new jsts.geom.Geometry, jsts.geom.Polygon.constructor = jsts.geom.Polygon, jsts.geom.Polygon.prototype.getCoordinate = function() {
					return this.shell.getCoordinate()
				}, jsts.geom.Polygon.prototype.getCoordinates = function() {
					if (this.isEmpty()) return [];
					for (var t = [], e = -1, n = this.shell.getCoordinates(), i = 0; i < n.length; i++) e++, t[e] = n[i];
					for (var o = 0; o < this.holes.length; o++) for (var r = this.holes[o].getCoordinates(), s = 0; s < r.length; s++) e++, t[e] = r[s];
					return t
				}, jsts.geom.Polygon.prototype.getNumPoints = function() {
					for (var t = this.shell.getNumPoints(), e = 0; e < this.holes.length; e++) t += this.holes[e].getNumPoints();
					return t
				}, jsts.geom.Polygon.prototype.isEmpty = function() {
					return this.shell.isEmpty()
				}, jsts.geom.Polygon.prototype.isRectangle = function() {
					if (0 != this.getNumInteriorRing()) return !1;
					if (null == this.shell) return !1;
					if (5 != this.shell.getNumPoints()) return !1;
					for (var t = this.shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; 5 > n; n++) {
						var i = t[n].x;
						if (i != e.getMinX() && i != e.getMaxX()) return !1;
						var o = t[n].y;
						if (o != e.getMinY() && o != e.getMaxY()) return !1
					}
					for (var r = t[0].x, s = t[0].y, n = 1; 4 >= n; n++) {
						var i = t[n].x,
							o = t[n].y,
							a = i != r,
							l = o != s;
						if (a == l) return !1;
						r = i, s = o
					}
					return !0
				}, jsts.geom.Polygon.prototype.getExteriorRing = function() {
					return this.shell
				}, jsts.geom.Polygon.prototype.getInteriorRingN = function(t) {
					return this.holes[t]
				}, jsts.geom.Polygon.prototype.getNumInteriorRing = function() {
					return this.holes.length
				}, jsts.geom.Polygon.prototype.getArea = function() {
					var t = 0;
					t += Math.abs(jsts.algorithm.CGAlgorithms.signedArea(this.shell.getCoordinateSequence()));
					for (var e = 0; e < this.holes.length; e++) t -= Math.abs(jsts.algorithm.CGAlgorithms.signedArea(this.holes[e].getCoordinateSequence()));
					return t
				}, jsts.geom.Polygon.prototype.getLength = function() {
					var t = 0;
					t += this.shell.getLength();
					for (var e = 0; e < this.holes.length; e++) t += this.holes[e].getLength();
					return t
				}, jsts.geom.Polygon.prototype.getBoundary = function() {
					if (this.isEmpty()) return this.getFactory().createMultiLineString(null);
					var t = [];
					t[0] = this.shell.clone();
					for (var e = 0, n = this.holes.length; n > e; e++) t[e + 1] = this.holes[e].clone();
					return t.length <= 1 ? t[0] : this.getFactory().createMultiLineString(t)
				}, jsts.geom.Polygon.prototype.computeEnvelopeInternal = function() {
					return this.shell.getEnvelopeInternal()
				}, jsts.geom.Polygon.prototype.getDimension = function() {
					return 2
				}, jsts.geom.Polygon.prototype.getBoundaryDimension = function() {
					return 1
				}, jsts.geom.Polygon.prototype.equalsExact = function(t, e) {
					if (!this.isEquivalentClass(t)) return !1;
					if (this.isEmpty() && t.isEmpty()) return !0;
					if (this.isEmpty() !== t.isEmpty()) return !1;
					if (!this.shell.equalsExact(t.shell, e)) return !1;
					if (this.holes.length !== t.holes.length) return !1;
					if (this.holes.length !== t.holes.length) return !1;
					for (var n = 0; n < this.holes.length; n++) if (!this.holes[n].equalsExact(t.holes[n], e)) return !1;
					return !0
				}, jsts.geom.Polygon.prototype.compareToSameClass = function(t) {
					return this.shell.compareToSameClass(t.shell)
				}, jsts.geom.Polygon.prototype.apply = function(t) {
					if (t instanceof jsts.geom.GeometryComponentFilter) {
						t.filter(this), this.shell.apply(t);
						for (var e = 0, n = this.holes.length; n > e; e++) this.holes[e].apply(t)
					} else if (t instanceof jsts.geom.GeometryFilter) t.filter(this);
					else if (t instanceof jsts.geom.CoordinateFilter) {
						this.shell.apply(t);
						for (var e = 0, n = this.holes.length; n > e; e++) this.holes[e].apply(t)
					} else t instanceof jsts.geom.CoordinateSequenceFilter && this.apply2.apply(this, arguments)
				}, jsts.geom.Polygon.prototype.apply2 = function(t) {
					if (this.shell.apply(t), !t.isDone()) for (var e = 0; e < this.holes.length && (this.holes[e].apply(t), !t.isDone()); e++);
					t.isGeometryChanged()
				}, jsts.geom.Polygon.prototype.clone = function() {
					for (var t = [], e = 0, n = this.holes.length; n > e; e++) t.push(this.holes[e].clone());
					return this.factory.createPolygon(this.shell.clone(), t)
				}, jsts.geom.Polygon.prototype.normalize = function() {
					this.normalize2(this.shell, !0);
					for (var t = 0, e = this.holes.length; e > t; t++) this.normalize2(this.holes[t], !1);
					this.holes.sort()
				}, jsts.geom.Polygon.prototype.normalize2 = function(t, e) {
					if (!t.isEmpty()) {
						var n = t.points.slice(0, t.points.length - 1),
							i = jsts.geom.CoordinateArrays.minCoordinate(t.points);
						jsts.geom.CoordinateArrays.scroll(n, i), t.points = n.concat(), t.points[n.length] = n[0], jsts.algorithm.CGAlgorithms.isCCW(t.points) === e && t.points.reverse()
					}
				}, jsts.geom.Polygon.prototype.getGeometryType = function() {
					return "Polygon"
				}, jsts.geom.Polygon.prototype.CLASS_NAME = "jsts.geom.Polygon"
			}(), function() {
				var t = jsts.geom.Geometry,
					e = javascript.util.TreeSet,
					n = javascript.util.Arrays;
				jsts.geom.GeometryCollection = function(t, e) {
					this.geometries = t || [], this.factory = e
				}, jsts.geom.GeometryCollection.prototype = new t, jsts.geom.GeometryCollection.constructor = jsts.geom.GeometryCollection, jsts.geom.GeometryCollection.prototype.isEmpty = function() {
					for (var t = 0, e = this.geometries.length; e > t; t++) {
						var n = this.getGeometryN(t);
						if (!n.isEmpty()) return !1
					}
					return !0
				}, jsts.geom.GeometryCollection.prototype.getArea = function() {
					for (var t = 0, e = 0, n = this.geometries.length; n > e; e++) t += this.getGeometryN(e).getArea();
					return t
				}, jsts.geom.GeometryCollection.prototype.getLength = function() {
					for (var t = 0, e = 0, n = this.geometries.length; n > e; e++) t += this.getGeometryN(e).getLength();
					return t
				}, jsts.geom.GeometryCollection.prototype.getCoordinate = function() {
					return this.isEmpty() ? null : this.getGeometryN(0).getCoordinate()
				}, jsts.geom.GeometryCollection.prototype.getCoordinates = function() {
					for (var t = [], e = -1, n = 0, i = this.geometries.length; i > n; n++) for (var o = this.getGeometryN(n), r = o.getCoordinates(), s = 0; s < r.length; s++) e++, t[e] = r[s];
					return t
				}, jsts.geom.GeometryCollection.prototype.getNumGeometries = function() {
					return this.geometries.length
				}, jsts.geom.GeometryCollection.prototype.getGeometryN = function(t) {
					var e = this.geometries[t];
					return e instanceof jsts.geom.Coordinate && (e = new jsts.geom.Point(e)), e
				}, jsts.geom.GeometryCollection.prototype.getNumPoints = function() {
					for (var t = 0, e = 0; e < this.geometries.length; e++) t += this.geometries[e].getNumPoints();
					return t
				}, jsts.geom.GeometryCollection.prototype.equalsExact = function(t, e) {
					if (!this.isEquivalentClass(t)) return !1;
					if (this.geometries.length !== t.geometries.length) return !1;
					for (var n = 0, i = this.geometries.length; i > n; n++) {
						var o = this.getGeometryN(n);
						if (!o.equalsExact(t.getGeometryN(n), e)) return !1
					}
					return !0
				}, jsts.geom.GeometryCollection.prototype.clone = function() {
					for (var t = [], e = 0, n = this.geometries.length; n > e; e++) t.push(this.geometries[e].clone());
					return this.factory.createGeometryCollection(t)
				}, jsts.geom.GeometryCollection.prototype.normalize = function() {
					for (var t = 0, e = this.geometries.length; e > t; t++) this.getGeometryN(t).normalize();
					this.geometries.sort()
				}, jsts.geom.GeometryCollection.prototype.compareToSameClass = function(t) {
					var i = new e(n.asList(this.geometries)),
						o = new e(n.asList(t.geometries));
					return this.compare(i, o)
				}, jsts.geom.GeometryCollection.prototype.apply = function(t) {
					if (t instanceof jsts.geom.GeometryFilter || t instanceof jsts.geom.GeometryComponentFilter) {
						t.filter(this);
						for (var e = 0, n = this.geometries.length; n > e; e++) this.getGeometryN(e).apply(t)
					} else if (t instanceof jsts.geom.CoordinateFilter) for (var e = 0, n = this.geometries.length; n > e; e++) this.getGeometryN(e).apply(t);
					else t instanceof jsts.geom.CoordinateSequenceFilter && this.apply2.apply(this, arguments)
				}, jsts.geom.GeometryCollection.prototype.apply2 = function(t) {
					if (0 != this.geometries.length) {
						for (var e = 0; e < this.geometries.length && (this.geometries[e].apply(t), !t.isDone()); e++);
						t.isGeometryChanged()
					}
				}, jsts.geom.GeometryCollection.prototype.getDimension = function() {
					for (var t = jsts.geom.Dimension.FALSE, e = 0, n = this.geometries.length; n > e; e++) {
						var i = this.getGeometryN(e);
						t = Math.max(t, i.getDimension())
					}
					return t
				}, jsts.geom.GeometryCollection.prototype.computeEnvelopeInternal = function() {
					for (var t = new jsts.geom.Envelope, e = 0, n = this.geometries.length; n > e; e++) {
						var i = this.getGeometryN(e);
						t.expandToInclude(i.getEnvelopeInternal())
					}
					return t
				}, jsts.geom.GeometryCollection.prototype.CLASS_NAME = "jsts.geom.GeometryCollection"
			}(), jsts.algorithm.Centroid = function(t) {
				this.areaBasePt = null, this.triangleCent3 = new jsts.geom.Coordinate, this.areasum2 = 0, this.cg3 = new jsts.geom.Coordinate, this.lineCentSum = new jsts.geom.Coordinate, this.totalLength = 0, this.ptCount = 0, this.ptCentSum = new jsts.geom.Coordinate, this.add(t)
			}, jsts.algorithm.Centroid.getCentroid = function(t) {
				var e = new jsts.algorithm.Centroid(t);
				return e.getCentroid()
			}, jsts.algorithm.Centroid.centroid3 = function(t, e, n, i) {
				i.x = t.x + e.x + n.x, i.y = t.y + e.y + n.y
			}, jsts.algorithm.Centroid.area2 = function(t, e, n) {
				return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y)
			}, jsts.algorithm.Centroid.prototype.add = function(t) {
				if (!t.isEmpty()) if (t instanceof jsts.geom.Point) this.addPoint(t.getCoordinate());
				else if (t instanceof jsts.geom.LineString) this.addLineSegments(t.getCoordinates());
				else if (t instanceof jsts.geom.Polygon) this.addPolygon(t);
				else if (t instanceof jsts.geom.GeometryCollection) for (var e = 0; e < t.getNumGeometries(); e++) this.add(t.getGeometryN(e))
			}, jsts.algorithm.Centroid.prototype.getCentroid = function() {
				var t = new jsts.geom.Coordinate;
				if (Math.abs(this.areasum2) > 0) t.x = this.cg3.x / 3 / this.areasum2, t.y = this.cg3.y / 3 / this.areasum2;
				else if (this.totalLength > 0) t.x = this.lineCentSum.x / this.totalLength, t.y = this.lineCentSum.y / this.totalLength;
				else {
					if (!(this.ptCount > 0)) return null;
					t.x = this.ptCentSum.x / this.ptCount, t.y = this.ptCentSum.y / this.ptCount
				}
				return t
			}, jsts.algorithm.Centroid.prototype.setBasePoint = function(t) {
				null === this.areaBasePt && (this.areaBasePt = t)
			}, jsts.algorithm.Centroid.prototype.addPolygon = function(t) {
				this.addShell(t.getExteriorRing().getCoordinates());
				for (var e = 0; e < t.getNumInteriorRing(); e++) this.addHole(t.getInteriorRingN(e).getCoordinates())
			}, jsts.algorithm.Centroid.prototype.addShell = function(t) {
				t.length > 0 && this.setBasePoint(t[0]);
				for (var e = !jsts.algorithm.CGAlgorithms.isCCW(t), n = 0; n < t.length - 1; n++) this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);
				this.addLineSegments(t)
			}, jsts.algorithm.Centroid.prototype.addHole = function(t) {
				for (var e = jsts.algorithm.CGAlgorithms.isCCW(t), n = 0; n < t.length - 1; n++) this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);
				this.addLineSegments(t)
			}, jsts.algorithm.Centroid.prototype.addTriangle = function(t, e, n, i) {
				var o = i ? 1 : -1;
				jsts.algorithm.Centroid.centroid3(t, e, n, this.triangleCent3);
				var r = jsts.algorithm.Centroid.area2(t, e, n);
				this.cg3.x += o * r * this.triangleCent3.x, this.cg3.y += o * r * this.triangleCent3.y, this.areasum2 += o * r
			}, jsts.algorithm.Centroid.prototype.addLineSegments = function(t) {
				for (var e = 0, n = 0; n < t.length - 1; n++) {
					var i = t[n].distance(t[n + 1]);
					if (0 !== i) {
						e += i;
						var o = (t[n].x + t[n + 1].x) / 2;
						this.lineCentSum.x += i * o;
						var r = (t[n].y + t[n + 1].y) / 2;
						this.lineCentSum.y += i * r
					}
				}
				this.totalLength += e, 0 === e && t.length > 0 && this.addPoint(t[0])
			}, jsts.algorithm.Centroid.prototype.addPoint = function(t) {
				this.ptCount += 1, this.ptCentSum.x += t.x, this.ptCentSum.y += t.y
			}, function() {
				var t = function(t) {
						this.deList = new javascript.util.ArrayList, this.factory = t
					};
				t.findEdgeRingContaining = function(t, e) {
					for (var n = t.getRing(), i = n.getEnvelopeInternal(), o = n.getCoordinateN(0), r = null, s = null, a = e.iterator(); a.hasNext();) {
						var l = a.next(),
							u = l.getRing(),
							p = u.getEnvelopeInternal();
						null != r && (s = r.getRing().getEnvelopeInternal());
						var h = !1;
						p.equals(i) || (o = jsts.geom.CoordinateArrays.ptNotInList(n.getCoordinates(), u.getCoordinates()), p.contains(i) && jsts.algorithm.CGAlgorithms.isPointInRing(o, u.getCoordinates()) && (h = !0), h && (null == r || s.contains(p)) && (r = l))
					}
					return r
				}, t.ptNotInList = function(t, e) {
					for (var n = 0; n < t.length; n++) {
						var i = t[n];
						if (!isInList(i, e)) return i
					}
					return null
				}, t.isInList = function(t, e) {
					for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return !0;
					return !1
				}, t.prototype.factory = null, t.prototype.deList = null, t.prototype.ring = null, t.prototype.ringPts = null, t.prototype.holes = null, t.prototype.add = function(t) {
					this.deList.add(t)
				}, t.prototype.isHole = function() {
					var t = this.getRing();
					return jsts.algorithm.CGAlgorithms.isCCW(t.getCoordinates())
				}, t.prototype.addHole = function(t) {
					null == this.holes && (this.holes = new javascript.util.ArrayList), this.holes.add(t)
				}, t.prototype.getPolygon = function() {
					var t = null;
					if (null != this.holes) {
						t = [];
						for (var e = 0; e < this.holes.size(); e++) t[e] = this.holes.get(e)
					}
					var n = this.factory.createPolygon(this.ring, t);
					return n
				}, t.prototype.isValid = function() {
					return this.getCoordinates(), !(this.ringPts.length <= 3) && (this.getRing(), this.ring.isValid())
				}, t.prototype.getCoordinates = function() {
					if (null == this.ringPts) {
						for (var e = new jsts.geom.CoordinateList, n = this.deList.iterator(); n.hasNext();) {
							var i = n.next(),
								o = i.getEdge();
							t.addEdge(o.getLine().getCoordinates(), i.getEdgeDirection(), e)
						}
						this.ringPts = e.toCoordinateArray()
					}
					return this.ringPts
				}, t.prototype.getLineString = function() {
					return this.getCoordinates(), this.factory.createLineString(this.ringPts)
				}, t.prototype.getRing = function() {
					if (null != this.ring) return this.ring;
					this.getCoordinates(), this.ringPts.length < 3 && console.log(this.ringPts);
					try {
						this.ring = this.factory.createLinearRing(this.ringPts)
					} catch (t) {
						console.log(this.ringPts)
					}
					return this.ring
				}, t.addEdge = function(t, e, n) {
					if (e) for (var i = 0; i < t.length; i++) n.add(t[i], !1);
					else for (var i = t.length - 1; i >= 0; i--) n.add(t[i], !1)
				}, jsts.operation.polygonize.EdgeRing = t
			}(), function() {
				var t = function() {};
				t.setVisited = function(t, e) {
					for (; t.hasNext();) {
						var n = t.next();
						n.setVisited(e)
					}
				}, t.setMarked = function(t, e) {
					for (; t.hasNext();) {
						var n = t.next();
						n.setMarked(e)
					}
				}, t.getComponentWithVisitedState = function(t, e) {
					for (; t.hasNext();) {
						var n = t.next();
						if (n.isVisited() == e) return n
					}
					return null
				}, t.prototype._isMarked = !1, t.prototype._isVisited = !1, t.prototype.data, t.prototype.isVisited = function() {
					return this._isVisited
				}, t.prototype.setVisited = function(t) {
					this._isVisited = t
				}, t.prototype.isMarked = function() {
					return this._isMarked
				}, t.prototype.setMarked = function(t) {
					this._isMarked = t
				}, t.prototype.setContext = function(t) {
					this.data = t
				}, t.prototype.getContext = function() {
					return data
				}, t.prototype.setData = function(t) {
					this.data = t
				}, t.prototype.getData = function() {
					return data
				}, t.prototype.isRemoved = function() {
					throw new jsts.error.AbstractMethodInvocationError
				}, jsts.planargraph.GraphComponent = t
			}(), function() {
				var t = jsts.planargraph.GraphComponent,
					e = function(t, e) {
						void 0 !== t && this.setDirectedEdges(t, e)
					};
				e.prototype = new t, e.prototype.dirEdge = null, e.prototype.setDirectedEdges = function(t, e) {
					this.dirEdge = [t, e], t.setEdge(this), e.setEdge(this), t.setSym(e), e.setSym(t), t.getFromNode().addOutEdge(t), e.getFromNode().addOutEdge(e)
				}, e.prototype.getDirEdge = function(t) {
					return t instanceof jsts.planargraph.Node && this.getDirEdge2(t), this.dirEdge[t]
				}, e.prototype.getDirEdge2 = function(t) {
					return this.dirEdge[0].getFromNode() == t ? this.dirEdge[0] : this.dirEdge[1].getFromNode() == t ? this.dirEdge[1] : null
				}, e.prototype.getOppositeNode = function(t) {
					return this.dirEdge[0].getFromNode() == t ? this.dirEdge[0].getToNode() : this.dirEdge[1].getFromNode() == t ? this.dirEdge[1].getToNode() : null
				}, e.prototype.remove = function() {
					this.dirEdge = null
				}, e.prototype.isRemoved = function() {
					return null == dirEdge
				}, jsts.planargraph.Edge = e
			}(), jsts.operation.polygonize.PolygonizeEdge = function(t) {
				this.line = t
			}, jsts.operation.polygonize.PolygonizeEdge.prototype = new jsts.planargraph.Edge, jsts.operation.polygonize.PolygonizeEdge.prototype.line = null, jsts.operation.polygonize.PolygonizeEdge.prototype.getLine = function() {
				return this.line
			}, function() {
				var t = javascript.util.ArrayList,
					e = jsts.planargraph.GraphComponent,
					n = function(t, e, n, i) {
						if (void 0 !== t) {
							this.from = t, this.to = e, this.edgeDirection = i, this.p0 = t.getCoordinate(), this.p1 = n;
							var o = this.p1.x - this.p0.x,
								r = this.p1.y - this.p0.y;
							this.quadrant = jsts.geomgraph.Quadrant.quadrant(o, r), this.angle = Math.atan2(r, o)
						}
					};
				n.prototype = new e, n.toEdges = function(e) {
					for (var n = new t, i = e.iterator(); i.hasNext();) n.add(i.next().parentEdge);
					return n
				}, n.prototype.parentEdge = null, n.prototype.from = null, n.prototype.to = null, n.prototype.p0 = null, n.prototype.p1 = null, n.prototype.sym = null, n.prototype.edgeDirection = null, n.prototype.quadrant = null, n.prototype.angle = null, n.prototype.getEdge = function() {
					return this.parentEdge
				}, n.prototype.setEdge = function(t) {
					this.parentEdge = t
				}, n.prototype.getQuadrant = function() {
					return this.quadrant
				}, n.prototype.getDirectionPt = function() {
					return this.p1
				}, n.prototype.getEdgeDirection = function() {
					return this.edgeDirection
				}, n.prototype.getFromNode = function() {
					return this.from
				}, n.prototype.getToNode = function() {
					return this.to
				}, n.prototype.getCoordinate = function() {
					return this.from.getCoordinate()
				}, n.prototype.getAngle = function() {
					return this.angle
				}, n.prototype.getSym = function() {
					return this.sym
				}, n.prototype.setSym = function(t) {
					this.sym = t
				}, n.prototype.remove = function() {
					this.sym = null, this.parentEdge = null
				}, n.prototype.isRemoved = function() {
					return null == this.parentEdge
				}, n.prototype.compareTo = function(t) {
					var e = t;
					return this.compareDirection(e)
				}, n.prototype.compareDirection = function(t) {
					return this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : jsts.algorithm.CGAlgorithms.computeOrientation(t.p0, t.p1, this.p1)
				}, jsts.planargraph.DirectedEdge = n
			}(), function() {
				var t = jsts.planargraph.DirectedEdge,
					e = function() {
						t.apply(this, arguments)
					};
				e.prototype = new t, e.prototype.edgeRing = null, e.prototype.next = null, e.prototype.label = -1, e.prototype.getLabel = function() {
					return this.label
				}, e.prototype.setLabel = function(t) {
					this.label = t
				}, e.prototype.getNext = function() {
					return this.next
				}, e.prototype.setNext = function(t) {
					this.next = t
				}, e.prototype.isInRing = function() {
					return null != this.edgeRing
				}, e.prototype.setRing = function(t) {
					this.edgeRing = t
				}, jsts.operation.polygonize.PolygonizeDirectedEdge = e
			}(), function() {
				var t = javascript.util.ArrayList,
					e = function() {
						this.outEdges = new t
					};
				e.prototype.outEdges = null, e.prototype.sorted = !1, e.prototype.add = function(t) {
					this.outEdges.add(t), this.sorted = !1
				}, e.prototype.remove = function(t) {
					this.outEdges.remove(t)
				}, e.prototype.iterator = function() {
					return this.sortEdges(), this.outEdges.iterator()
				}, e.prototype.getDegree = function() {
					return this.outEdges.size()
				}, e.prototype.getCoordinate = function() {
					var t = iterator();
					if (!t.hasNext()) return null;
					var e = t.next();
					return e.getCoordinate()
				}, e.prototype.getEdges = function() {
					return this.sortEdges(), this.outEdges
				}, e.prototype.sortEdges = function() {
					if (!this.sorted) {
						var t = this.outEdges.toArray();
						t.sort(function(t, e) {
							return t.compareTo(e)
						}), this.outEdges = javascript.util.Arrays.asList(t), this.sorted = !0
					}
				}, e.prototype.getIndex = function(t) {
					if (t instanceof jsts.planargraph.DirectedEdge) return this.getIndex2(t);
					if ("number" == typeof t) return this.getIndex3(t);
					this.sortEdges();
					for (var e = 0; e < this.outEdges.size(); e++) {
						var n = this.outEdges.get(e);
						if (n.getEdge() == t) return e
					}
					return -1
				}, e.prototype.getIndex2 = function(t) {
					this.sortEdges();
					for (var e = 0; e < this.outEdges.size(); e++) {
						var n = this.outEdges.get(e);
						if (n == t) return e
					}
					return -1
				}, e.prototype.getIndex3 = function(t) {
					var e = toInt(t % this.outEdges.size());
					return 0 > e && (e += this.outEdges.size()), e
				}, e.prototype.getNextEdge = function(t) {
					var e = this.getIndex(t);
					return this.outEdges.get(getIndex(e + 1))
				}, e.prototype.getNextCWEdge = function(t) {
					var e = this.getIndex(t);
					return this.outEdges.get(getIndex(e - 1))
				}, jsts.planargraph.DirectedEdgeStar = e
			}(), function() {
				var t = jsts.planargraph.GraphComponent,
					e = jsts.planargraph.DirectedEdgeStar,
					n = function(t, n) {
						this.pt = t, this.deStar = n || new e
					};
				n.prototype = new t, n.getEdgesBetween = function(t, e) {
					var n = DirectedEdge.toEdges(t.getOutEdges().getEdges()),
						i = new javascript.util.HashSet(n),
						o = DirectedEdge.toEdges(e.getOutEdges().getEdges());
					return i.retainAll(o), i
				}, n.prototype.pt = null, n.prototype.deStar = null, n.prototype.getCoordinate = function() {
					return this.pt
				}, n.prototype.addOutEdge = function(t) {
					this.deStar.add(t)
				}, n.prototype.getOutEdges = function() {
					return this.deStar
				}, n.prototype.getDegree = function() {
					return this.deStar.getDegree()
				}, n.prototype.getIndex = function(t) {
					return this.deStar.getIndex(t)
				}, n.prototype.remove = function(t) {
					return void 0 === t ? this.remove2() : void this.deStar.remove(t)
				}, n.prototype.remove2 = function() {
					this.pt = null
				}, n.prototype.isRemoved = function() {
					return null == this.pt
				}, jsts.planargraph.Node = n
			}(), function() {
				var t = function() {
						this.nodeMap = new javascript.util.TreeMap
					};
				t.prototype.nodeMap = null, t.prototype.add = function(t) {
					return this.nodeMap.put(t.getCoordinate(), t), t
				}, t.prototype.remove = function(t) {
					return this.nodeMap.remove(t)
				}, t.prototype.find = function(t) {
					return this.nodeMap.get(t)
				}, t.prototype.iterator = function() {
					return this.nodeMap.values().iterator()
				}, t.prototype.values = function() {
					return this.nodeMap.values()
				}, jsts.planargraph.NodeMap = t
			}(), function() {
				var t = javascript.util.ArrayList,
					e = function() {
						this.edges = new javascript.util.HashSet, this.dirEdges = new javascript.util.HashSet, this.nodeMap = new jsts.planargraph.NodeMap
					};
				e.prototype.edges = null, e.prototype.dirEdges = null, e.prototype.nodeMap = null, e.prototype.findNode = function(t) {
					return this.nodeMap.find(t)
				}, e.prototype.add = function(t) {
					return t instanceof jsts.planargraph.Edge ? this.add2(t) : t instanceof jsts.planargraph.DirectedEdge ? this.add3(t) : void this.nodeMap.add(t)
				}, e.prototype.add2 = function(t) {
					this.edges.add(t), this.add(t.getDirEdge(0)), this.add(t.getDirEdge(1))
				}, e.prototype.add3 = function(t) {
					this.dirEdges.add(t)
				}, e.prototype.nodeIterator = function() {
					return this.nodeMap.iterator()
				}, e.prototype.contains = function(t) {
					return t instanceof jsts.planargraph.DirectedEdge ? this.contains2(t) : this.edges.contains(t)
				}, e.prototype.contains2 = function(t) {
					return this.dirEdges.contains(t)
				}, e.prototype.getNodes = function() {
					return this.nodeMap.values()
				}, e.prototype.dirEdgeIterator = function() {
					return this.dirEdges.iterator()
				}, e.prototype.edgeIterator = function() {
					return this.edges.iterator()
				}, e.prototype.getEdges = function() {
					return this.edges
				}, e.prototype.remove = function(t) {
					return t instanceof jsts.planargraph.DirectedEdge ? this.remove2(t) : (this.remove(t.getDirEdge(0)), this.remove(t.getDirEdge(1)), this.edges.remove(t), void this.edge.remove())
				}, e.prototype.remove2 = function(t) {
					if (t instanceof jsts.planargraph.Node) return this.remove3(t);
					var e = t.getSym();
					null != e && e.setSym(null), t.getFromNode().remove(t), t.remove(), this.dirEdges.remove(t)
				}, e.prototype.remove3 = function(t) {
					for (var e = t.getOutEdges().getEdges(), n = e.iterator(); n.hasNext();) {
						var i = n.next(),
							o = i.getSym();
						null != o && this.remove(o), this.dirEdges.remove(i);
						var r = i.getEdge();
						null != r && this.edges.remove(r)
					}
					this.nodeMap.remove(t.getCoordinate()), t.remove()
				}, e.prototype.findNodesOfDegree = function(e) {
					for (var n = new t, i = this.nodeIterator(); i.hasNext();) {
						var o = i.next();
						o.getDegree() == e && n.add(o)
					}
					return n
				}, jsts.planargraph.PlanarGraph = e
			}(), function() {
				var t = javascript.util.ArrayList,
					e = javascript.util.Stack,
					n = javascript.util.HashSet,
					i = jsts.util.Assert,
					o = jsts.operation.polygonize.EdgeRing,
					r = jsts.operation.polygonize.PolygonizeEdge,
					s = jsts.operation.polygonize.PolygonizeDirectedEdge,
					a = jsts.planargraph.PlanarGraph,
					l = jsts.planargraph.Node,
					u = function(t) {
						a.apply(this), this.factory = t
					};
				u.prototype = new a, u.getDegreeNonDeleted = function(t) {
					for (var e = t.getOutEdges().getEdges(), n = 0, i = e.iterator(); i.hasNext();) {
						var o = i.next();
						o.isMarked() || n++
					}
					return n
				}, u.getDegree = function(t, e) {
					for (var n = t.getOutEdges().getEdges(), i = 0, o = n.iterator(); o.hasNext();) {
						var r = o.next();
						r.getLabel() == e && i++
					}
					return i
				}, u.deleteAllEdges = function(t) {
					for (var e = t.getOutEdges().getEdges(), n = e.iterator(); n.hasNext();) {
						var i = n.next();
						i.setMarked(!0);
						var o = i.getSym();
						null != o && o.setMarked(!0)
					}
				}, u.prototype.factory = null, u.prototype.addEdge = function(t) {
					if (!t.isEmpty()) {
						var e = jsts.geom.CoordinateArrays.removeRepeatedPoints(t.getCoordinates());
						if (!(e.length < 2)) {
							var n = e[0],
								i = e[e.length - 1],
								o = this.getNode(n),
								a = this.getNode(i),
								l = new s(o, a, e[1], (!0)),
								u = new s(a, o, e[e.length - 2], (!1)),
								p = new r(t);
							p.setDirectedEdges(l, u), this.add(p)
						}
					}
				}, u.prototype.getNode = function(t) {
					var e = this.findNode(t);
					return null == e && (e = new l(t), this.add(e)), e
				}, u.prototype.computeNextCWEdges = function() {
					for (var t = this.nodeIterator(); t.hasNext();) {
						var e = t.next();
						u.computeNextCWEdges(e)
					}
				}, u.prototype.convertMaximalToMinimalEdgeRings = function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var n = e.next(),
							i = n.getLabel(),
							o = u.findIntersectionNodes(n, i);
						if (null != o) for (var r = o.iterator(); r.hasNext();) {
							var s = r.next();
							u.computeNextCCWEdges(s, i)
						}
					}
				}, u.findIntersectionNodes = function(e, n) {
					var o = e,
						r = null;
					do {
						var s = o.getFromNode();
						u.getDegree(s, n) > 1 && (null == r && (r = new t), r.add(s)), o = o.getNext(), i.isTrue(null != o, "found null DE in ring"), i.isTrue(o == e || !o.isInRing(), "found DE already in ring")
					} while (o != e);
					return r
				}, u.prototype.getEdgeRings = function() {
					this.computeNextCWEdges(), u.label(this.dirEdges, -1);
					var e = u.findLabeledEdgeRings(this.dirEdges);
					this.convertMaximalToMinimalEdgeRings(e);
					for (var n = new t, i = this.dirEdges.iterator(); i.hasNext();) {
						var o = i.next();
						if (!o.isMarked() && !o.isInRing()) {
							var r = this.findEdgeRing(o);
							n.add(r)
						}
					}
					return n
				}, u.findLabeledEdgeRings = function(e) {
					for (var n = new t, i = 1, o = e.iterator(); o.hasNext();) {
						var r = o.next();
						if (!(r.isMarked() || r.getLabel() >= 0)) {
							n.add(r);
							var s = u.findDirEdgesInRing(r);
							u.label(s, i), i++
						}
					}
					return n
				}, u.prototype.deleteCutEdges = function() {
					this.computeNextCWEdges(), u.findLabeledEdgeRings(this.dirEdges);
					for (var e = new t, n = this.dirEdges.iterator(); n.hasNext();) {
						var i = n.next();
						if (!i.isMarked()) {
							var o = i.getSym();
							if (i.getLabel() == o.getLabel()) {
								i.setMarked(!0), o.setMarked(!0);
								var r = i.getEdge();
								e.add(r.getLine())
							}
						}
					}
					return e
				}, u.label = function(t, e) {
					for (var n = t.iterator(); n.hasNext();) {
						var i = n.next();
						i.setLabel(e)
					}
				}, u.computeNextCWEdges = function(t) {
					for (var e = t.getOutEdges(), n = null, i = null, o = e.getEdges().iterator(); o.hasNext();) {
						var r = o.next();
						if (!r.isMarked()) {
							if (null == n && (n = r), null != i) {
								var s = i.getSym();
								s.setNext(r)
							}
							i = r
						}
					}
					if (null != i) {
						var s = i.getSym();
						s.setNext(n)
					}
				}, u.computeNextCCWEdges = function(t, e) {
					for (var n = t.getOutEdges(), o = null, r = null, s = n.getEdges(), a = s.size() - 1; a >= 0; a--) {
						var l = s.get(a),
							u = l.getSym(),
							p = null;
						l.getLabel() == e && (p = l);
						var h = null;
						u.getLabel() == e && (h = u), (null != p || null != h) && (null != h && (r = h), null != p && (null != r && (r.setNext(p), r = null), null == o && (o = p)))
					}
					null != r && (i.isTrue(null != o), r.setNext(o))
				}, u.findDirEdgesInRing = function(e) {
					var n = e,
						o = new t;
					do o.add(n), n = n.getNext(), i.isTrue(null != n, "found null DE in ring"), i.isTrue(n == e || !n.isInRing(), "found DE already in ring");
					while (n != e);
					return o
				}, u.prototype.findEdgeRing = function(t) {
					var e = t,
						n = new o(this.factory);
					do n.add(e), e.setRing(n), e = e.getNext(), i.isTrue(null != e, "found null DE in ring"), i.isTrue(e == t || !e.isInRing(), "found DE already in ring");
					while (e != t);
					return n
				}, u.prototype.deleteDangles = function() {
					for (var t = this.findNodesOfDegree(1), i = new n, o = new e, r = t.iterator(); r.hasNext();) o.push(r.next());
					for (; !o.isEmpty();) {
						var s = o.pop();
						u.deleteAllEdges(s);
						for (var a = s.getOutEdges().getEdges(), r = a.iterator(); r.hasNext();) {
							var l = r.next();
							l.setMarked(!0);
							var p = l.getSym();
							null != p && p.setMarked(!0);
							var h = l.getEdge();
							i.add(h.getLine());
							var c = l.getToNode();
							1 == u.getDegreeNonDeleted(c) && o.push(c)
						}
					}
					return i
				}, u.prototype.computeDepthParity = function() {
					for (;;) {
						var t = null;
						if (null == t) return;
						this.computeDepthParity(t)
					}
				}, u.prototype.computeDepthParity = function() {}, jsts.operation.polygonize.PolygonizeGraph = u
			}(), jsts.index.strtree.Interval = function() {
				var t;
				return 1 === arguments.length ? (t = arguments[0], jsts.index.strtree.Interval(t.min, t.max)) : void(2 === arguments.length && (jsts.util.Assert.isTrue(this.min <= this.max), this.min = arguments[0], this.max = arguments[1]))
			}, jsts.index.strtree.Interval.prototype.min = null, jsts.index.strtree.Interval.prototype.max = null, jsts.index.strtree.Interval.prototype.getCentre = function() {
				return (this.min + this.max) / 2
			}, jsts.index.strtree.Interval.prototype.expandToInclude = function(t) {
				return this.max = Math.max(this.max, t.max), this.min = Math.min(this.min, t.min), this
			}, jsts.index.strtree.Interval.prototype.intersects = function(t) {
				return !(t.min > this.max || t.max < this.min)
			}, jsts.index.strtree.Interval.prototype.equals = function(t) {
				return t instanceof jsts.index.strtree.Interval && (other = t, this.min === other.min && this.max === other.max)
			}, jsts.geom.GeometryFactory = function(t) {
				this.precisionModel = t || new jsts.geom.PrecisionModel
			}, jsts.geom.GeometryFactory.prototype.precisionModel = null, jsts.geom.GeometryFactory.prototype.getPrecisionModel = function() {
				return this.precisionModel
			}, jsts.geom.GeometryFactory.prototype.createPoint = function(t) {
				var e = new jsts.geom.Point(t, this);
				return e
			}, jsts.geom.GeometryFactory.prototype.createLineString = function(t) {
				var e = new jsts.geom.LineString(t, this);
				return e
			}, jsts.geom.GeometryFactory.prototype.createLinearRing = function(t) {
				var e = new jsts.geom.LinearRing(t, this);
				return e
			}, jsts.geom.GeometryFactory.prototype.createPolygon = function(t, e) {
				var n = new jsts.geom.Polygon(t, e, this);
				return n
			}, jsts.geom.GeometryFactory.prototype.createMultiPoint = function(t) {
				if (t && t[0] instanceof jsts.geom.Coordinate) {
					var e, n = [];
					for (e = 0; e < t.length; e++) n.push(this.createPoint(t[e]));
					t = n
				}
				return new jsts.geom.MultiPoint(t, this)
			}, jsts.geom.GeometryFactory.prototype.createMultiLineString = function(t) {
				return new jsts.geom.MultiLineString(t, this)
			}, jsts.geom.GeometryFactory.prototype.createMultiPolygon = function(t) {
				return new jsts.geom.MultiPolygon(t, this)
			}, jsts.geom.GeometryFactory.prototype.buildGeometry = function(t) {
				for (var e = null, n = !1, i = !1, o = t.iterator(); o.hasNext();) {
					var r = o.next(),
						s = r.CLASS_NAME;
					null === e && (e = s), s !== e && (n = !0), r.isGeometryCollectionBase() && (i = !0)
				}
				if (null === e) return this.createGeometryCollection(null);
				if (n || i) return this.createGeometryCollection(t.toArray());
				var a = t.get(0),
					l = t.size() > 1;
				if (l) {
					if (a instanceof jsts.geom.Polygon) return this.createMultiPolygon(t.toArray());
					if (a instanceof jsts.geom.LineString) return this.createMultiLineString(t.toArray());
					if (a instanceof jsts.geom.Point) return this.createMultiPoint(t.toArray());
					jsts.util.Assert.shouldNeverReachHere("Unhandled class: " + a)
				}
				return a
			}, jsts.geom.GeometryFactory.prototype.createGeometryCollection = function(t) {
				return new jsts.geom.GeometryCollection(t, this)
			}, jsts.geom.GeometryFactory.prototype.toGeometry = function(t) {
				return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new jsts.geom.Coordinate(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new jsts.geom.Coordinate(t.getMinX(), t.getMinY()), new jsts.geom.Coordinate(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new jsts.geom.Coordinate(t.getMinX(), t.getMinY()), new jsts.geom.Coordinate(t.getMinX(), t.getMaxY()), new jsts.geom.Coordinate(t.getMaxX(), t.getMaxY()), new jsts.geom.Coordinate(t.getMaxX(), t.getMinY()), new jsts.geom.Coordinate(t.getMinX(), t.getMinY())]), null)
			}, jsts.geomgraph.NodeFactory = function() {}, jsts.geomgraph.NodeFactory.prototype.createNode = function(t) {
				return new jsts.geomgraph.Node(t, null)
			}, function() {
				jsts.geomgraph.Position = function() {}, jsts.geomgraph.Position.ON = 0, jsts.geomgraph.Position.LEFT = 1, jsts.geomgraph.Position.RIGHT = 2, jsts.geomgraph.Position.opposite = function(t) {
					return t === jsts.geomgraph.Position.LEFT ? jsts.geomgraph.Position.RIGHT : t === jsts.geomgraph.Position.RIGHT ? jsts.geomgraph.Position.LEFT : t
				}
			}(), jsts.geomgraph.TopologyLocation = function() {
				if (this.location = [], 3 === arguments.length) {
					var t = arguments[0],
						e = arguments[1],
						n = arguments[2];
					this.init(3), this.location[jsts.geomgraph.Position.ON] = t, this.location[jsts.geomgraph.Position.LEFT] = e, this.location[jsts.geomgraph.Position.RIGHT] = n
				} else if (arguments[0] instanceof jsts.geomgraph.TopologyLocation) {
					var i = arguments[0];
					if (this.init(i.location.length), null != i) for (var o = 0; o < this.location.length; o++) this.location[o] = i.location[o]
				} else if ("number" == typeof arguments[0]) {
					var t = arguments[0];
					this.init(1), this.location[jsts.geomgraph.Position.ON] = t
				} else if (arguments[0] instanceof Array) {
					var r = arguments[0];
					this.init(r.length)
				}
			}, jsts.geomgraph.TopologyLocation.prototype.location = null, jsts.geomgraph.TopologyLocation.prototype.init = function(t) {
				this.location[t - 1] = null, this.setAllLocations(jsts.geom.Location.NONE)
			}, jsts.geomgraph.TopologyLocation.prototype.get = function(t) {
				return t < this.location.length ? this.location[t] : jsts.geom.Location.NONE
			}, jsts.geomgraph.TopologyLocation.prototype.isNull = function() {
				for (var t = 0; t < this.location.length; t++) if (this.location[t] !== jsts.geom.Location.NONE) return !1;
				return !0
			}, jsts.geomgraph.TopologyLocation.prototype.isAnyNull = function() {
				for (var t = 0; t < this.location.length; t++) if (this.location[t] === jsts.geom.Location.NONE) return !0;
				return !1
			}, jsts.geomgraph.TopologyLocation.prototype.isEqualOnSide = function(t, e) {
				return this.location[e] == t.location[e]
			}, jsts.geomgraph.TopologyLocation.prototype.isArea = function() {
				return this.location.length > 1
			}, jsts.geomgraph.TopologyLocation.prototype.isLine = function() {
				return 1 === this.location.length
			}, jsts.geomgraph.TopologyLocation.prototype.flip = function() {
				if (!(this.location.length <= 1)) {
					var t = this.location[jsts.geomgraph.Position.LEFT];
					this.location[jsts.geomgraph.Position.LEFT] = this.location[jsts.geomgraph.Position.RIGHT], this.location[jsts.geomgraph.Position.RIGHT] = t
				}
			}, jsts.geomgraph.TopologyLocation.prototype.setAllLocations = function(t) {
				for (var e = 0; e < this.location.length; e++) this.location[e] = t
			}, jsts.geomgraph.TopologyLocation.prototype.setAllLocationsIfNull = function(t) {
				for (var e = 0; e < this.location.length; e++) this.location[e] === jsts.geom.Location.NONE && (this.location[e] = t)
			}, jsts.geomgraph.TopologyLocation.prototype.setLocation = function(t, e) {
				void 0 !== e ? this.location[t] = e : this.setLocation(jsts.geomgraph.Position.ON, t)
			}, jsts.geomgraph.TopologyLocation.prototype.getLocations = function() {
				return location
			}, jsts.geomgraph.TopologyLocation.prototype.setLocations = function(t, e, n) {
				this.location[jsts.geomgraph.Position.ON] = t, this.location[jsts.geomgraph.Position.LEFT] = e, this.location[jsts.geomgraph.Position.RIGHT] = n
			}, jsts.geomgraph.TopologyLocation.prototype.allPositionsEqual = function(t) {
				for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;
				return !0
			}, jsts.geomgraph.TopologyLocation.prototype.merge = function(t) {
				if (t.location.length > this.location.length) {
					var e = [];
					e[jsts.geomgraph.Position.ON] = this.location[jsts.geomgraph.Position.ON], e[jsts.geomgraph.Position.LEFT] = jsts.geom.Location.NONE, e[jsts.geomgraph.Position.RIGHT] = jsts.geom.Location.NONE, this.location = e
				}
				for (var n = 0; n < this.location.length; n++) this.location[n] === jsts.geom.Location.NONE && n < t.location.length && (this.location[n] = t.location[n])
			}, jsts.geomgraph.Label = function() {
				this.elt = [];
				var t, e, n, i, o;
				4 === arguments.length ? (t = arguments[0], e = arguments[1], n = arguments[2], o = arguments[3], this.elt[0] = new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE, jsts.geom.Location.NONE, jsts.geom.Location.NONE), this.elt[1] = new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE, jsts.geom.Location.NONE, jsts.geom.Location.NONE), this.elt[t].setLocations(e, n, o)) : 3 === arguments.length ? (e = arguments[0], n = arguments[1], o = arguments[2], this.elt[0] = new jsts.geomgraph.TopologyLocation(e, n, o), this.elt[1] = new jsts.geomgraph.TopologyLocation(e, n, o)) : 2 === arguments.length ? (t = arguments[0], e = arguments[1], this.elt[0] = new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE), this.elt[1] = new jsts.geomgraph.TopologyLocation(jsts.geom.Location.NONE), this.elt[t].setLocation(e)) : arguments[0] instanceof jsts.geomgraph.Label ? (i = arguments[0], this.elt[0] = new jsts.geomgraph.TopologyLocation(i.elt[0]), this.elt[1] = new jsts.geomgraph.TopologyLocation(i.elt[1])) : "number" == typeof arguments[0] && (e = arguments[0], this.elt[0] = new jsts.geomgraph.TopologyLocation(e), this.elt[1] = new jsts.geomgraph.TopologyLocation(e))
			}, jsts.geomgraph.Label.toLineLabel = function(t) {
				var e, n = new jsts.geomgraph.Label(jsts.geom.Location.NONE);
				for (e = 0; 2 > e; e++) n.setLocation(e, t.getLocation(e));
				return n
			}, jsts.geomgraph.Label.prototype.elt = null, jsts.geomgraph.Label.prototype.flip = function() {
				this.elt[0].flip(), this.elt[1].flip()
			}, jsts.geomgraph.Label.prototype.getLocation = function(t, e) {
				return 1 == arguments.length ? this.getLocation2.apply(this, arguments) : this.elt[t].get(e)
			}, jsts.geomgraph.Label.prototype.getLocation2 = function(t) {
				return this.elt[t].get(jsts.geomgraph.Position.ON)
			}, jsts.geomgraph.Label.prototype.setLocation = function(t, e, n) {
				return 2 == arguments.length ? void this.setLocation2.apply(this, arguments) : void this.elt[t].setLocation(e, n)
			}, jsts.geomgraph.Label.prototype.setLocation2 = function(t, e) {
				this.elt[t].setLocation(jsts.geomgraph.Position.ON, e)
			}, jsts.geomgraph.Label.prototype.setAllLocations = function(t, e) {
				this.elt[t].setAllLocations(e)
			}, jsts.geomgraph.Label.prototype.setAllLocationsIfNull = function(t, e) {
				return 1 == arguments.length ? void this.setAllLocationsIfNull2.apply(this, arguments) : void this.elt[t].setAllLocationsIfNull(e)
			}, jsts.geomgraph.Label.prototype.setAllLocationsIfNull2 = function(t) {
				this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t)
			}, jsts.geomgraph.Label.prototype.merge = function(t) {
				var e;
				for (e = 0; 2 > e; e++) null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new jsts.geomgraph.TopologyLocation(t.elt[e]) : this.elt[e].merge(t.elt[e])
			}, jsts.geomgraph.Label.prototype.getGeometryCount = function() {
				var t = 0;
				return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t
			}, jsts.geomgraph.Label.prototype.isNull = function(t) {
				return this.elt[t].isNull()
			}, jsts.geomgraph.Label.prototype.isAnyNull = function(t) {
				return this.elt[t].isAnyNull()
			}, jsts.geomgraph.Label.prototype.isArea = function() {
				return 1 == arguments.length ? this.isArea2(arguments[0]) : this.elt[0].isArea() || this.elt[1].isArea()
			}, jsts.geomgraph.Label.prototype.isArea2 = function(t) {
				return this.elt[t].isArea()
			}, jsts.geomgraph.Label.prototype.isLine = function(t) {
				return this.elt[t].isLine()
			}, jsts.geomgraph.Label.prototype.isEqualOnSide = function(t, e) {
				return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e)
			}, jsts.geomgraph.Label.prototype.allPositionsEqual = function(t, e) {
				return this.elt[t].allPositionsEqual(e)
			}, jsts.geomgraph.Label.prototype.toLine = function(t) {
				this.elt[t].isArea() && (this.elt[t] = new jsts.geomgraph.TopologyLocation(this.elt[t].location[0]))
			}, jsts.geomgraph.EdgeRing = function(t, e) {
				this.edges = [], this.pts = [], this.holes = [], this.label = new jsts.geomgraph.Label(jsts.geom.Location.NONE), this.geometryFactory = e, t && (this.computePoints(t), this.computeRing())
			}, jsts.geomgraph.EdgeRing.prototype.startDe = null, jsts.geomgraph.EdgeRing.prototype.maxNodeDegree = -1, jsts.geomgraph.EdgeRing.prototype.edges = null, jsts.geomgraph.EdgeRing.prototype.pts = null, jsts.geomgraph.EdgeRing.prototype.label = null, jsts.geomgraph.EdgeRing.prototype.ring = null, jsts.geomgraph.EdgeRing.prototype._isHole = null, jsts.geomgraph.EdgeRing.prototype.shell = null, jsts.geomgraph.EdgeRing.prototype.holes = null, jsts.geomgraph.EdgeRing.prototype.geometryFactory = null, jsts.geomgraph.EdgeRing.prototype.isIsolated = function() {
				return 1 == this.label.getGeometryCount()
			}, jsts.geomgraph.EdgeRing.prototype.isHole = function() {
				return this._isHole
			}, jsts.geomgraph.EdgeRing.prototype.getCoordinate = function(t) {
				return this.pts[t]
			}, jsts.geomgraph.EdgeRing.prototype.getLinearRing = function() {
				return this.ring
			}, jsts.geomgraph.EdgeRing.prototype.getLabel = function() {
				return this.label
			}, jsts.geomgraph.EdgeRing.prototype.isShell = function() {
				return null === this.shell
			}, jsts.geomgraph.EdgeRing.prototype.getShell = function() {
				return this.shell
			}, jsts.geomgraph.EdgeRing.prototype.setShell = function(t) {
				this.shell = t, null !== t && t.addHole(this)
			}, jsts.geomgraph.EdgeRing.prototype.addHole = function(t) {
				this.holes.push(t)
			}, jsts.geomgraph.EdgeRing.prototype.toPolygon = function() {
				for (var t = [], e = 0; e < this.holes.length; e++) t[e] = this.holes[e].getLinearRing();
				var n = this.geometryFactory.createPolygon(this.getLinearRing(), t);
				return n
			}, jsts.geomgraph.EdgeRing.prototype.computeRing = function() {
				if (null === this.ring) {
					for (var t = [], e = 0; e < this.pts.length; e++) t[e] = this.pts[e];
					this.ring = this.geometryFactory.createLinearRing(t), this._isHole = jsts.algorithm.CGAlgorithms.isCCW(this.ring.getCoordinates())
				}
			}, jsts.geomgraph.EdgeRing.prototype.getNext = function() {
				throw new jsts.error.AbstractInvocationError
			}, jsts.geomgraph.EdgeRing.prototype.setEdgeRing = function() {
				throw new jsts.error.AbstractInvocationError
			}, jsts.geomgraph.EdgeRing.prototype.getEdges = function() {
				return this.edges
			}, jsts.geomgraph.EdgeRing.prototype.computePoints = function(t) {
				this.startDe = t;
				var e = t,
					n = !0;
				do {
					if (null === e) throw new jsts.error.TopologyError("Found null DirectedEdge");
					if (e.getEdgeRing() === this) throw new jsts.error.TopologyError("Directed Edge visited twice during ring-building at " + e.getCoordinate());
					this.edges.push(e);
					var i = e.getLabel();
					jsts.util.Assert.isTrue(i.isArea()), this.mergeLabel(i), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e)
				} while (e !== this.startDe)
			}, jsts.geomgraph.EdgeRing.prototype.getMaxNodeDegree = function() {
				return this.maxNodeDegree < 0 && this.computeMaxNodeDegree(), this.maxNodeDegree
			}, jsts.geomgraph.EdgeRing.prototype.computeMaxNodeDegree = function() {
				this.maxNodeDegree = 0;
				var t = this.startDe;
				do {
					var e = t.getNode(),
						n = e.getEdges().getOutgoingDegree(this);
					n > this.maxNodeDegree && (this.maxNodeDegree = n), t = this.getNext(t)
				} while (t !== this.startDe);
				this.maxNodeDegree *= 2
			}, jsts.geomgraph.EdgeRing.prototype.setInResult = function() {
				var t = this.startDe;
				do t.getEdge().setInResult(!0), t = t.getNext();
				while (t != this.startDe)
			}, jsts.geomgraph.EdgeRing.prototype.mergeLabel = function(t) {
				this.mergeLabel2(t, 0), this.mergeLabel2(t, 1)
			}, jsts.geomgraph.EdgeRing.prototype.mergeLabel2 = function(t, e) {
				var n = t.getLocation(e, jsts.geomgraph.Position.RIGHT);
				if (n != jsts.geom.Location.NONE) return this.label.getLocation(e) === jsts.geom.Location.NONE ? void this.label.setLocation(e, n) : void 0
			}, jsts.geomgraph.EdgeRing.prototype.addPoints = function(t, e, n) {
				var i = t.getCoordinates();
				if (e) {
					var o = 1;
					n && (o = 0);
					for (var r = o; r < i.length; r++) this.pts.push(i[r])
				} else {
					var o = i.length - 2;
					n && (o = i.length - 1);
					for (var r = o; r >= 0; r--) this.pts.push(i[r])
				}
			}, jsts.geomgraph.EdgeRing.prototype.containsPoint = function(t) {
				var e = this.getLinearRing(),
					n = e.getEnvelopeInternal();
				if (!n.contains(t)) return !1;
				if (!jsts.algorithm.CGAlgorithms.isPointInRing(t, e.getCoordinates())) return !1;
				for (var i = 0; i < this.holes.length; i++) {
					var o = this.holes[i];
					if (o.containsPoint(t)) return !1
				}
				return !0
			}, function() {
				jsts.geom.LinearRing = function() {
					jsts.geom.LineString.apply(this, arguments)
				}, jsts.geom.LinearRing.prototype = new jsts.geom.LineString, jsts.geom.LinearRing.constructor = jsts.geom.LinearRing, jsts.geom.LinearRing.prototype.getBoundaryDimension = function() {
					return jsts.geom.Dimension.FALSE
				}, jsts.geom.LinearRing.prototype.isSimple = function() {
					return !0
				}, jsts.geom.LinearRing.prototype.getGeometryType = function() {
					return "LinearRing"
				}, jsts.geom.LinearRing.MINIMUM_VALID_SIZE = 4, jsts.geom.LinearRing.prototype.CLASS_NAME = "jsts.geom.LinearRing"
			}(), jsts.index.strtree.Boundable = function() {}, jsts.index.strtree.Boundable.prototype.getBounds = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.index.strtree.AbstractNode = function(t) {
				this.level = t, this.childBoundables = []
			}, jsts.index.strtree.AbstractNode.prototype = new jsts.index.strtree.Boundable, jsts.index.strtree.AbstractNode.constructor = jsts.index.strtree.AbstractNode, jsts.index.strtree.AbstractNode.prototype.childBoundables = null, jsts.index.strtree.AbstractNode.prototype.bounds = null, jsts.index.strtree.AbstractNode.prototype.level = null, jsts.index.strtree.AbstractNode.prototype.getChildBoundables = function() {
				return this.childBoundables
			}, jsts.index.strtree.AbstractNode.prototype.computeBounds = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.index.strtree.AbstractNode.prototype.getBounds = function() {
				return null === this.bounds && (this.bounds = this.computeBounds()), this.bounds
			}, jsts.index.strtree.AbstractNode.prototype.getLevel = function() {
				return this.level
			}, jsts.index.strtree.AbstractNode.prototype.addChildBoundable = function(t) {
				this.childBoundables.push(t)
			}, function() {
				jsts.noding.Noder = function() {}, jsts.noding.Noder.prototype.computeNodes = jsts.abstractFunc, jsts.noding.Noder.prototype.getNodedSubstrings = jsts.abstractFunc
			}(), function() {
				var t = jsts.noding.Noder;
				jsts.noding.SinglePassNoder = function() {}, jsts.noding.SinglePassNoder.prototype = new t, jsts.noding.SinglePassNoder.constructor = jsts.noding.SinglePassNoder, jsts.noding.SinglePassNoder.prototype.segInt = null, jsts.noding.SinglePassNoder.prototype.setSegmentIntersector = function(t) {
					this.segInt = t
				}
			}(), jsts.index.SpatialIndex = function() {}, jsts.index.SpatialIndex.prototype.insert = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.index.SpatialIndex.prototype.query = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.index.SpatialIndex.prototype.remove = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.index.strtree.AbstractSTRtree = function(t) {
				void 0 !== t && (this.itemBoundables = [], jsts.util.Assert.isTrue(t > 1, "Node capacity must be greater than 1"), this.nodeCapacity = t)
			}, jsts.index.strtree.AbstractSTRtree.IntersectsOp = function() {}, jsts.index.strtree.AbstractSTRtree.IntersectsOp.prototype.intersects = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.index.strtree.AbstractSTRtree.prototype.root = null, jsts.index.strtree.AbstractSTRtree.prototype.built = !1, jsts.index.strtree.AbstractSTRtree.prototype.itemBoundables = null, jsts.index.strtree.AbstractSTRtree.prototype.nodeCapacity = null, jsts.index.strtree.AbstractSTRtree.prototype.build = function() {
				jsts.util.Assert.isTrue(!this.built), this.root = 0 === this.itemBoundables.length ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1), this.built = !0
			}, jsts.index.strtree.AbstractSTRtree.prototype.createNode = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.index.strtree.AbstractSTRtree.prototype.createParentBoundables = function(t, e) {
				jsts.util.Assert.isTrue(!(0 === t.length));
				var n = [];
				n.push(this.createNode(e));
				for (var i = [], o = 0; o < t.length; o++) i.push(t[o]);
				i.sort(this.getComparator());
				for (var o = 0; o < i.length; o++) {
					var r = i[o];
					this.lastNode(n).getChildBoundables().length === this.getNodeCapacity() && n.push(this.createNode(e)), this.lastNode(n).addChildBoundable(r)
				}
				return n
			}, jsts.index.strtree.AbstractSTRtree.prototype.lastNode = function(t) {
				return t[t.length - 1]
			}, jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles = function(t, e) {
				return t > e ? 1 : e > t ? -1 : 0
			}, jsts.index.strtree.AbstractSTRtree.prototype.createHigherLevels = function(t, e) {
				jsts.util.Assert.isTrue(!(0 === t.length));
				var n = this.createParentBoundables(t, e + 1);
				return 1 === n.length ? n[0] : this.createHigherLevels(n, e + 1)
			}, jsts.index.strtree.AbstractSTRtree.prototype.getRoot = function() {
				return this.built || this.build(), this.root
			}, jsts.index.strtree.AbstractSTRtree.prototype.getNodeCapacity = function() {
				return this.nodeCapacity
			}, jsts.index.strtree.AbstractSTRtree.prototype.size = function() {
				return 1 === arguments.length ? this.size2(arguments[0]) : (this.built || this.build(), 0 === this.itemBoundables.length ? 0 : this.size2(root))
			}, jsts.index.strtree.AbstractSTRtree.prototype.size2 = function(t) {
				for (var e = 0, n = t.getChildBoundables(), i = 0; i < n.length; i++) {
					var o = n[i];
					o instanceof jsts.index.strtree.AbstractNode ? e += this.size(o) : o instanceof jsts.index.strtree.ItemBoundable && (e += 1)
				}
				return e
			}, jsts.index.strtree.AbstractSTRtree.prototype.depth = function() {
				return 1 === arguments.length ? this.depth2(arguments[0]) : (this.built || this.build(), 0 === this.itemBoundables.length ? 0 : this.depth2(root))
			}, jsts.index.strtree.AbstractSTRtree.prototype.depth2 = function() {
				for (var t = 0, e = node.getChildBoundables(), n = 0; n < e.length; n++) {
					var i = e[n];
					if (i instanceof jsts.index.strtree.AbstractNode) {
						var o = this.depth(i);
						o > t && (t = o)
					}
				}
				return t + 1
			}, jsts.index.strtree.AbstractSTRtree.prototype.insert = function(t, e) {
				jsts.util.Assert.isTrue(!this.built, "Cannot insert items into an STR packed R-tree after it has been built."), this.itemBoundables.push(new jsts.index.strtree.ItemBoundable(t, e))
			}, jsts.index.strtree.AbstractSTRtree.prototype.query = function(t) {
				arguments.length > 1 && this.query2.apply(this, arguments), this.built || this.build();
				var e = [];
				return 0 === this.itemBoundables.length ? (jsts.util.Assert.isTrue(null === this.root.getBounds()), e) : (this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.query3(t, this.root, e), e)
			}, jsts.index.strtree.AbstractSTRtree.prototype.query2 = function(t, e) {
				arguments.length > 2 && this.query3.apply(this, arguments), this.built || this.build(), 0 === this.itemBoundables.length && jsts.util.Assert.isTrue(null === this.root.getBounds()), this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.query4(t, this.root, e)
			}, jsts.index.strtree.AbstractSTRtree.prototype.query3 = function(t, e, n) {
				arguments[2] instanceof Array || this.query4.apply(this, arguments);
				for (var i = e.getChildBoundables(), o = 0; o < i.length; o++) {
					var r = i[o];
					this.getIntersectsOp().intersects(r.getBounds(), t) && (r instanceof jsts.index.strtree.AbstractNode ? this.query3(t, r, n) : r instanceof jsts.index.strtree.ItemBoundable ? n.push(r.getItem()) : jsts.util.Assert.shouldNeverReachHere())
				}
			}, jsts.index.strtree.AbstractSTRtree.prototype.query4 = function(t, e, n) {
				for (var i = e.getChildBoundables(), o = 0; o < i.length; o++) {
					var r = i[o];
					this.getIntersectsOp().intersects(r.getBounds(), t) && (r instanceof jsts.index.strtree.AbstractNode ? this.query4(t, r, n) : r instanceof jsts.index.strtree.ItemBoundable ? n.visitItem(r.getItem()) : jsts.util.Assert.shouldNeverReachHere())
				}
			}, jsts.index.strtree.AbstractSTRtree.prototype.getIntersectsOp = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.index.strtree.AbstractSTRtree.prototype.itemsTree = function() {
				if (1 === arguments.length) return this.itemsTree2.apply(this, arguments);
				this.built || this.build();
				var t = this.itemsTree2(this.root);
				return null === t ? [] : t
			}, jsts.index.strtree.AbstractSTRtree.prototype.itemsTree2 = function(t) {
				for (var e = [], n = t.getChildBoundables(), i = 0; i < n.length; i++) {
					var o = n[i];
					if (o instanceof jsts.index.strtree.AbstractNode) {
						var r = this.itemsTree(o);
						null != r && e.push(r)
					} else o instanceof jsts.index.strtree.ItemBoundable ? e.push(o.getItem()) : jsts.util.Assert.shouldNeverReachHere()
				}
				return e.length <= 0 ? null : e;
			}, jsts.index.strtree.AbstractSTRtree.prototype.remove = function(t, e) {
				return this.built || this.build(), 0 === this.itemBoundables.length && jsts.util.Assert.isTrue(null == this.root.getBounds()), !! this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.remove2(t, this.root, e)
			}, jsts.index.strtree.AbstractSTRtree.prototype.remove2 = function(t, e, n) {
				var i = this.removeItem(e, n);
				if (i) return !0;
				for (var o = null, r = e.getChildBoundables(), s = 0; s < r.length; s++) {
					var a = r[s];
					if (this.getIntersectsOp().intersects(a.getBounds(), t) && a instanceof jsts.index.strtree.AbstractNode && (i = this.remove(t, a, n))) {
						o = a;
						break
					}
				}
				return null != o && 0 === o.getChildBoundables().length && r.splice(r.indexOf(o), 1), i
			}, jsts.index.strtree.AbstractSTRtree.prototype.removeItem = function(t, e) {
				for (var n = null, i = t.getChildBoundables(), o = 0; o < i.length; o++) {
					var r = i[o];
					r instanceof jsts.index.strtree.ItemBoundable && r.getItem() === e && (n = r)
				}
				return null !== n && (i.splice(i.indexOf(n), 1), !0)
			}, jsts.index.strtree.AbstractSTRtree.prototype.boundablesAtLevel = function(t) {
				if (arguments.length > 1) return void this.boundablesAtLevel2.apply(this, arguments);
				var e = [];
				return this.boundablesAtLevel2(t, this.root, e), e
			}, jsts.index.strtree.AbstractSTRtree.prototype.boundablesAtLevel2 = function(t, e, n) {
				if (jsts.util.Assert.isTrue(t > -2), e.getLevel() === t) return void n.add(e);
				for (var i = node.getChildBoundables(), o = 0; o < i.length; o++) {
					var r = i[o];
					r instanceof jsts.index.strtree.AbstractNode ? this.boundablesAtLevel(t, r, n) : (jsts.util.Assert.isTrue(r instanceof jsts.index.strtree.ItemBoundable), -1 === t && n.add(r))
				}
			}, jsts.index.strtree.AbstractSTRtree.prototype.getComparator = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.index.strtree.STRtree = function(t) {
				t = t || jsts.index.strtree.STRtree.DEFAULT_NODE_CAPACITY, jsts.index.strtree.AbstractSTRtree.call(this, t)
			}, jsts.index.strtree.STRtree.prototype = new jsts.index.strtree.AbstractSTRtree, jsts.index.strtree.STRtree.constructor = jsts.index.strtree.STRtree, jsts.index.strtree.STRtree.prototype.xComparator = function(t, e) {
				return jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles(jsts.index.strtree.STRtree.prototype.centreX(t.getBounds()), jsts.index.strtree.STRtree.prototype.centreX(e.getBounds()))
			}, jsts.index.strtree.STRtree.prototype.yComparator = function(t, e) {
				return jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles(jsts.index.strtree.STRtree.prototype.centreY(t.getBounds()), jsts.index.strtree.STRtree.prototype.centreY(e.getBounds()))
			}, jsts.index.strtree.STRtree.prototype.centreX = function(t) {
				return jsts.index.strtree.STRtree.prototype.avg(t.getMinX(), t.getMaxX())
			}, jsts.index.strtree.STRtree.prototype.centreY = function(t) {
				return jsts.index.strtree.STRtree.prototype.avg(t.getMinY(), t.getMaxY())
			}, jsts.index.strtree.STRtree.prototype.avg = function(t, e) {
				return (t + e) / 2
			}, jsts.index.strtree.STRtree.prototype.intersectsOp = {
				intersects: function(t, e) {
					return t.intersects(e)
				}
			}, jsts.index.strtree.STRtree.prototype.createParentBoundables = function(t, e) {
				jsts.util.Assert.isTrue(!(0 === t.length));
				for (var n = Math.ceil(t.length / this.getNodeCapacity()), i = [], o = 0; o < t.length; o++) i.push(t[o]);
				i.sort(this.xComparator);
				var r = this.verticalSlices(i, Math.ceil(Math.sqrt(n)));
				return this.createParentBoundablesFromVerticalSlices(r, e)
			}, jsts.index.strtree.STRtree.prototype.createParentBoundablesFromVerticalSlices = function(t, e) {
				jsts.util.Assert.isTrue(t.length > 0);
				for (var n = [], i = 0; i < t.length; i++) n = n.concat(this.createParentBoundablesFromVerticalSlice(t[i], e));
				return n
			}, jsts.index.strtree.STRtree.prototype.createParentBoundablesFromVerticalSlice = function(t, e) {
				return jsts.index.strtree.AbstractSTRtree.prototype.createParentBoundables.call(this, t, e)
			}, jsts.index.strtree.STRtree.prototype.verticalSlices = function(t, e) {
				for (var n, i, o = Math.ceil(t.length / e), r = [], s = 0, a = 0; e > a; a++) for (r[a] = [], n = 0; s < t.length && o > n;) i = t[s++], r[a].push(i), n++;
				return r
			}, jsts.index.strtree.STRtree.DEFAULT_NODE_CAPACITY = 10, jsts.index.strtree.STRtree.prototype.createNode = function(t) {
				var e = new jsts.index.strtree.AbstractNode(t);
				return e.computeBounds = function() {
					for (var t = null, e = this.getChildBoundables(), n = 0; n < e.length; n++) {
						var i = e[n];
						null === t ? t = new jsts.geom.Envelope(i.getBounds()) : t.expandToInclude(i.getBounds())
					}
					return t
				}, e
			}, jsts.index.strtree.STRtree.prototype.getIntersectsOp = function() {
				return this.intersectsOp
			}, jsts.index.strtree.STRtree.prototype.insert = function(t, e) {
				t.isNull() || jsts.index.strtree.AbstractSTRtree.prototype.insert.call(this, t, e)
			}, jsts.index.strtree.STRtree.prototype.query = function() {
				return jsts.index.strtree.AbstractSTRtree.prototype.query.apply(this, arguments)
			}, jsts.index.strtree.STRtree.prototype.remove = function(t, e) {
				return jsts.index.strtree.AbstractSTRtree.prototype.remove.call(this, t, e)
			}, jsts.index.strtree.STRtree.prototype.size = function() {
				return jsts.index.strtree.AbstractSTRtree.prototype.size.call(this)
			}, jsts.index.strtree.STRtree.prototype.depth = function() {
				return jsts.index.strtree.AbstractSTRtree.prototype.depth.call(this)
			}, jsts.index.strtree.STRtree.prototype.getComparator = function() {
				return this.yComparator
			}, jsts.index.strtree.STRtree.prototype.nearestNeighbour = function(t) {
				var e = new jsts.index.strtree.BoundablePair(this.getRoot(), this.getRoot(), t);
				return this.nearestNeighbour4(e)
			}, jsts.index.strtree.STRtree.prototype.nearestNeighbour2 = function(t, e, n) {
				var i = new jsts.index.strtree.ItemBoundable(t, e),
					o = new jsts.index.strtree.BoundablePair(this.getRoot(), i, n);
				return this.nearestNeighbour4(o)[0]
			}, jsts.index.strtree.STRtree.prototype.nearestNeighbour3 = function(t, e) {
				var n = new jsts.index.strtree.BoundablePair(this.getRoot(), t.getRoot(), e);
				return this.nearestNeighbour4(n)
			}, jsts.index.strtree.STRtree.prototype.nearestNeighbour4 = function(t) {
				return this.nearestNeighbour5(t, Double.POSITIVE_INFINITY)
			}, jsts.index.strtree.STRtree.prototype.nearestNeighbour5 = function(t, e) {
				var n = e,
					i = null,
					o = [];
				for (o.push(t); !o.isEmpty() && n > 0;) {
					var r = o.pop(),
						s = r.getDistance();
					if (s >= n) break;
					r.isLeaves() ? (n = s, i = r) : r.expandToQueue(o, n)
				}
				return [i.getBoundable(0).getItem(), i.getBoundable(1).getItem()]
			}, jsts.noding.SegmentString = function() {}, jsts.noding.SegmentString.prototype.getData = jsts.abstractFunc, jsts.noding.SegmentString.prototype.setData = jsts.abstractFunc, jsts.noding.SegmentString.prototype.size = jsts.abstractFunc, jsts.noding.SegmentString.prototype.getCoordinate = jsts.abstractFunc, jsts.noding.SegmentString.prototype.getCoordinates = jsts.abstractFunc, jsts.noding.SegmentString.prototype.isClosed = jsts.abstractFunc, jsts.noding.NodableSegmentString = function() {}, jsts.noding.NodableSegmentString.prototype = new jsts.noding.SegmentString, jsts.noding.NodableSegmentString.prototype.addIntersection = jsts.abstractFunc, jsts.noding.NodedSegmentString = function(t, e) {
				this.nodeList = new jsts.noding.SegmentNodeList(this), this.pts = t, this.data = e
			}, jsts.noding.NodedSegmentString.prototype = new jsts.noding.NodableSegmentString, jsts.noding.NodedSegmentString.constructor = jsts.noding.NodedSegmentString, jsts.noding.NodedSegmentString.getNodedSubstrings = function(t) {
				if (2 === arguments.length) return void jsts.noding.NodedSegmentString.getNodedSubstrings2.apply(this, arguments);
				var e = new javascript.util.ArrayList;
				return jsts.noding.NodedSegmentString.getNodedSubstrings2(t, e), e
			}, jsts.noding.NodedSegmentString.getNodedSubstrings2 = function(t, e) {
				for (var n = t.iterator(); n.hasNext();) {
					var i = n.next();
					i.getNodeList().addSplitEdges(e)
				}
			}, jsts.noding.NodedSegmentString.prototype.nodeList = null, jsts.noding.NodedSegmentString.prototype.pts = null, jsts.noding.NodedSegmentString.prototype.data = null, jsts.noding.NodedSegmentString.prototype.getData = function() {
				return this.data
			}, jsts.noding.NodedSegmentString.prototype.setData = function(t) {
				this.data = t
			}, jsts.noding.NodedSegmentString.prototype.getNodeList = function() {
				return this.nodeList
			}, jsts.noding.NodedSegmentString.prototype.size = function() {
				return this.pts.length
			}, jsts.noding.NodedSegmentString.prototype.getCoordinate = function(t) {
				return this.pts[t]
			}, jsts.noding.NodedSegmentString.prototype.getCoordinates = function() {
				return this.pts
			}, jsts.noding.NodedSegmentString.prototype.isClosed = function() {
				return this.pts[0].equals(this.pts[this.pts.length - 1])
			}, jsts.noding.NodedSegmentString.prototype.getSegmentOctant = function(t) {
				return t === this.pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1))
			}, jsts.noding.NodedSegmentString.prototype.safeOctant = function(t, e) {
				return t.equals2D(e) ? 0 : jsts.noding.Octant.octant(t, e)
			}, jsts.noding.NodedSegmentString.prototype.addIntersections = function(t, e, n) {
				for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i)
			}, jsts.noding.NodedSegmentString.prototype.addIntersection = function(t, e, n, i) {
				if (t instanceof jsts.geom.Coordinate) return void this.addIntersection2.apply(this, arguments);
				var o = new jsts.geom.Coordinate(t.getIntersection(i));
				this.addIntersection2(o, e)
			}, jsts.noding.NodedSegmentString.prototype.addIntersection2 = function(t, e) {
				this.addIntersectionNode(t, e)
			}, jsts.noding.NodedSegmentString.prototype.addIntersectionNode = function(t, e) {
				var n = e,
					i = n + 1;
				if (i < this.pts.length) {
					var o = this.pts[i];
					t.equals2D(o) && (n = i)
				}
				var r = this.nodeList.add(t, n);
				return r
			}, jsts.noding.NodedSegmentString.prototype.toString = function() {
				var t = new jsts.geom.GeometryFactory;
				return (new jsts.io.WKTWriter).write(t.createLineString(this.pts))
			}, jsts.index.chain.MonotoneChainBuilder = function() {}, jsts.index.chain.MonotoneChainBuilder.toIntArray = function(t) {
				for (var e = [], n = 0; n < t.length; n++) e[n] = t[n];
				return e
			}, jsts.index.chain.MonotoneChainBuilder.getChains = function(t) {
				return 2 === arguments.length ? jsts.index.chain.MonotoneChainBuilder.getChains2.apply(this, arguments) : jsts.index.chain.MonotoneChainBuilder.getChains2(t, null)
			}, jsts.index.chain.MonotoneChainBuilder.getChains2 = function(t, e) {
				for (var n = [], i = jsts.index.chain.MonotoneChainBuilder.getChainStartIndices(t), o = 0; o < i.length - 1; o++) {
					var r = new jsts.index.chain.MonotoneChain(t, i[o], i[o + 1], e);
					n.push(r)
				}
				return n
			}, jsts.index.chain.MonotoneChainBuilder.getChainStartIndices = function(t) {
				var e = 0,
					n = [];
				n.push(e);
				do {
					var i = jsts.index.chain.MonotoneChainBuilder.findChainEnd(t, e);
					n.push(i), e = i
				} while (e < t.length - 1);
				var o = jsts.index.chain.MonotoneChainBuilder.toIntArray(n);
				return o
			}, jsts.index.chain.MonotoneChainBuilder.findChainEnd = function(t, e) {
				for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);) n++;
				if (n >= t.length - 1) return t.length - 1;
				for (var i = jsts.geomgraph.Quadrant.quadrant(t[n], t[n + 1]), o = e + 1; o < t.length;) {
					if (!t[o - 1].equals2D(t[o])) {
						var r = jsts.geomgraph.Quadrant.quadrant(t[o - 1], t[o]);
						if (r !== i) break
					}
					o++
				}
				return o - 1
			}, jsts.algorithm.LineIntersector = function() {
				this.inputLines = [
					[],
					[]
				], this.intPt = [null, null], this.pa = this.intPt[0], this.pb = this.intPt[1], this.result = jsts.algorithm.LineIntersector.NO_INTERSECTION
			}, jsts.algorithm.LineIntersector.NO_INTERSECTION = 0, jsts.algorithm.LineIntersector.POINT_INTERSECTION = 1, jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION = 2, jsts.algorithm.LineIntersector.prototype.setPrecisionModel = function(t) {
				this.precisionModel = t
			}, jsts.algorithm.LineIntersector.prototype.getEndpoint = function(t, e) {
				return this.inputLines[t][e]
			}, jsts.algorithm.LineIntersector.computeEdgeDistance = function(t, e, n) {
				var i = Math.abs(n.x - e.x),
					o = Math.abs(n.y - e.y),
					r = -1;
				if (t.equals(e)) r = 0;
				else if (t.equals(n)) r = i > o ? i : o;
				else {
					var s = Math.abs(t.x - e.x),
						a = Math.abs(t.y - e.y);
					r = i > o ? s : a, 0 !== r || t.equals(e) || (r = Math.max(s, a))
				}
				if (0 === r && !t.equals(e)) throw new jsts.error.IllegalArgumentError("Bad distance calculation");
				return r
			}, jsts.algorithm.LineIntersector.nonRobustComputeEdgeDistance = function(t, e) {
				var n = t.x - e.x,
					i = t.y - e.y,
					o = Math.sqrt(n * n + i * i);
				if (0 !== o || t.equals(e)) throw new jsts.error.IllegalArgumentError("Invalid distance calculation");
				return o
			}, jsts.algorithm.LineIntersector.prototype.result = null, jsts.algorithm.LineIntersector.prototype.inputLines = null, jsts.algorithm.LineIntersector.prototype.intPt = null, jsts.algorithm.LineIntersector.prototype.intLineIndex = null, jsts.algorithm.LineIntersector.prototype._isProper = null, jsts.algorithm.LineIntersector.prototype.pa = null, jsts.algorithm.LineIntersector.prototype.pb = null, jsts.algorithm.LineIntersector.prototype.precisionModel = null, jsts.algorithm.LineIntersector.prototype.computeIntersection = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.algorithm.LineIntersector.prototype.isCollinear = function() {
				return this.result === jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION
			}, jsts.algorithm.LineIntersector.prototype.computeIntersection = function(t, e, n, i) {
				this.inputLines[0][0] = t, this.inputLines[0][1] = e, this.inputLines[1][0] = n, this.inputLines[1][1] = i, this.result = this.computeIntersect(t, e, n, i)
			}, jsts.algorithm.LineIntersector.prototype.computeIntersect = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.algorithm.LineIntersector.prototype.isEndPoint = function() {
				return this.hasIntersection() && !this._isProper
			}, jsts.algorithm.LineIntersector.prototype.hasIntersection = function() {
				return this.result !== jsts.algorithm.LineIntersector.NO_INTERSECTION
			}, jsts.algorithm.LineIntersector.prototype.getIntersectionNum = function() {
				return this.result
			}, jsts.algorithm.LineIntersector.prototype.getIntersection = function(t) {
				return this.intPt[t]
			}, jsts.algorithm.LineIntersector.prototype.computeIntLineIndex = function() {
				null === this.intLineIndex && (this.intLineIndex = [
					[],
					[]
				], this.computeIntLineIndex(0), this.computeIntLineIndex(1))
			}, jsts.algorithm.LineIntersector.prototype.isIntersection = function(t) {
				var e;
				for (e = 0; e < this.result; e++) if (this.intPt[e].equals2D(t)) return !0;
				return !1
			}, jsts.algorithm.LineIntersector.prototype.isInteriorIntersection = function() {
				return 1 === arguments.length ? this.isInteriorIntersection2.apply(this, arguments) : !! this.isInteriorIntersection(0) || !! this.isInteriorIntersection(1)
			}, jsts.algorithm.LineIntersector.prototype.isInteriorIntersection2 = function(t) {
				var e;
				for (e = 0; e < this.result; e++) if (!this.intPt[e].equals2D(this.inputLines[t][0]) && !this.intPt[e].equals2D(this.inputLines[t][1])) return !0;
				return !1
			}, jsts.algorithm.LineIntersector.prototype.isProper = function() {
				return this.hasIntersection() && this._isProper
			}, jsts.algorithm.LineIntersector.prototype.getIntersectionAlongSegment = function(t, e) {
				return this.computeIntLineIndex(), this.intPt[intLineIndex[t][e]]
			}, jsts.algorithm.LineIntersector.prototype.getIndexAlongSegment = function(t, e) {
				return this.computeIntLineIndex(), this.intLineIndex[t][e]
			}, jsts.algorithm.LineIntersector.prototype.computeIntLineIndex = function(t) {
				var e = this.getEdgeDistance(t, 0),
					n = this.getEdgeDistance(t, 1);
				e > n ? (this.intLineIndex[t][0] = 0, this.intLineIndex[t][1] = 1) : (this.intLineIndex[t][0] = 1, this.intLineIndex[t][1] = 0)
			}, jsts.algorithm.LineIntersector.prototype.getEdgeDistance = function(t, e) {
				var n = jsts.algorithm.LineIntersector.computeEdgeDistance(this.intPt[e], this.inputLines[t][0], this.inputLines[t][1]);
				return n
			}, jsts.algorithm.RobustLineIntersector = function() {
				jsts.algorithm.RobustLineIntersector.prototype.constructor.call(this)
			}, jsts.algorithm.RobustLineIntersector.prototype = new jsts.algorithm.LineIntersector, jsts.algorithm.RobustLineIntersector.prototype.computeIntersection = function(t, e, n) {
				return 4 === arguments.length ? void jsts.algorithm.LineIntersector.prototype.computeIntersection.apply(this, arguments) : (this._isProper = !1, jsts.geom.Envelope.intersects(e, n, t) && 0 === jsts.algorithm.CGAlgorithms.orientationIndex(e, n, t) && 0 === jsts.algorithm.CGAlgorithms.orientationIndex(n, e, t) ? (this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), void(this.result = jsts.algorithm.LineIntersector.POINT_INTERSECTION)) : void(this.result = jsts.algorithm.LineIntersector.NO_INTERSECTION))
			}, jsts.algorithm.RobustLineIntersector.prototype.computeIntersect = function(t, e, n, i) {
				if (this._isProper = !1, !jsts.geom.Envelope.intersects(t, e, n, i)) return jsts.algorithm.LineIntersector.NO_INTERSECTION;
				var o = jsts.algorithm.CGAlgorithms.orientationIndex(t, e, n),
					r = jsts.algorithm.CGAlgorithms.orientationIndex(t, e, i);
				if (o > 0 && r > 0 || 0 > o && 0 > r) return jsts.algorithm.LineIntersector.NO_INTERSECTION;
				var s = jsts.algorithm.CGAlgorithms.orientationIndex(n, i, t),
					a = jsts.algorithm.CGAlgorithms.orientationIndex(n, i, e);
				if (s > 0 && a > 0 || 0 > s && 0 > a) return jsts.algorithm.LineIntersector.NO_INTERSECTION;
				var l = 0 === o && 0 === r && 0 === s && 0 === a;
				return l ? this.computeCollinearIntersection(t, e, n, i) : (0 === o || 0 === r || 0 === s || 0 === a ? (this._isProper = !1, t.equals2D(n) || t.equals2D(i) ? this.intPt[0] = t : e.equals2D(n) || e.equals2D(i) ? this.intPt[0] = e : 0 === o ? this.intPt[0] = new jsts.geom.Coordinate(n) : 0 === r ? this.intPt[0] = new jsts.geom.Coordinate(i) : 0 === s ? this.intPt[0] = new jsts.geom.Coordinate(t) : 0 === a && (this.intPt[0] = new jsts.geom.Coordinate(e))) : (this._isProper = !0, this.intPt[0] = this.intersection(t, e, n, i)), jsts.algorithm.LineIntersector.POINT_INTERSECTION)
			}, jsts.algorithm.RobustLineIntersector.prototype.computeCollinearIntersection = function(t, e, n, i) {
				var o = jsts.geom.Envelope.intersects(t, e, n),
					r = jsts.geom.Envelope.intersects(t, e, i),
					s = jsts.geom.Envelope.intersects(n, i, t),
					a = jsts.geom.Envelope.intersects(n, i, e);
				return o && r ? (this.intPt[0] = n, this.intPt[1] = i, jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION) : s && a ? (this.intPt[0] = t, this.intPt[1] = e, jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION) : o && s ? (this.intPt[0] = n, this.intPt[1] = t, !n.equals(t) || r || a ? jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION : jsts.algorithm.LineIntersector.POINT_INTERSECTION) : o && a ? (this.intPt[0] = n, this.intPt[1] = e, !n.equals(e) || r || s ? jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION : jsts.algorithm.LineIntersector.POINT_INTERSECTION) : r && s ? (this.intPt[0] = i, this.intPt[1] = t, !i.equals(t) || o || a ? jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION : jsts.algorithm.LineIntersector.POINT_INTERSECTION) : r && a ? (this.intPt[0] = i, this.intPt[1] = e, !i.equals(e) || o || s ? jsts.algorithm.LineIntersector.COLLINEAR_INTERSECTION : jsts.algorithm.LineIntersector.POINT_INTERSECTION) : jsts.algorithm.LineIntersector.NO_INTERSECTION
			}, jsts.algorithm.RobustLineIntersector.prototype.intersection = function(t, e, n, i) {
				var o = this.intersectionWithNormalization(t, e, n, i);
				return this.isInSegmentEnvelopes(o) || (o = jsts.algorithm.CentralEndpointIntersector.getIntersection(t, e, n, i)), null !== this.precisionModel && this.precisionModel.makePrecise(o), o
			}, jsts.algorithm.RobustLineIntersector.prototype.intersectionWithNormalization = function(t, e, n, i) {
				var o = new jsts.geom.Coordinate(t),
					r = new jsts.geom.Coordinate(e),
					s = new jsts.geom.Coordinate(n),
					a = new jsts.geom.Coordinate(i),
					l = new jsts.geom.Coordinate;
				this.normalizeToEnvCentre(o, r, s, a, l);
				var u = this.safeHCoordinateIntersection(o, r, s, a);
				return u.x += l.x, u.y += l.y, u
			}, jsts.algorithm.RobustLineIntersector.prototype.safeHCoordinateIntersection = function(t, e, n, i) {
				var o = null;
				try {
					o = jsts.algorithm.HCoordinate.intersection(t, e, n, i)
				} catch (r) {
					if (!(r instanceof jsts.error.NotRepresentableError)) throw r;
					o = jsts.algorithm.CentralEndpointIntersector.getIntersection(t, e, n, i)
				}
				return o
			}, jsts.algorithm.RobustLineIntersector.prototype.normalizeToMinimum = function(t, e, n, i, o) {
				o.x = this.smallestInAbsValue(t.x, e.x, n.x, i.x), o.y = this.smallestInAbsValue(t.y, e.y, n.y, i.y), t.x -= o.x, t.y -= o.y, e.x -= o.x, e.y -= o.y, n.x -= o.x, n.y -= o.y, i.x -= o.x, i.y -= o.y
			}, jsts.algorithm.RobustLineIntersector.prototype.normalizeToEnvCentre = function(t, e, n, i, o) {
				var r = t.x < e.x ? t.x : e.x,
					s = t.y < e.y ? t.y : e.y,
					a = t.x > e.x ? t.x : e.x,
					l = t.y > e.y ? t.y : e.y,
					u = n.x < i.x ? n.x : i.x,
					p = n.y < i.y ? n.y : i.y,
					h = n.x > i.x ? n.x : i.x,
					c = n.y > i.y ? n.y : i.y,
					g = r > u ? r : u,
					d = h > a ? a : h,
					f = s > p ? s : p,
					m = c > l ? l : c,
					y = (g + d) / 2,
					v = (f + m) / 2;
				o.x = y, o.y = v, t.x -= o.x, t.y -= o.y, e.x -= o.x, e.y -= o.y, n.x -= o.x, n.y -= o.y, i.x -= o.x, i.y -= o.y
			}, jsts.algorithm.RobustLineIntersector.prototype.smallestInAbsValue = function(t, e, n, i) {
				var o = t,
					r = Math.abs(o);
				return Math.abs(e) < r && (o = e, r = Math.abs(e)), Math.abs(n) < r && (o = n, r = Math.abs(n)), Math.abs(i) < r && (o = i), o
			}, jsts.algorithm.RobustLineIntersector.prototype.isInSegmentEnvelopes = function(t) {
				var e = new jsts.geom.Envelope(this.inputLines[0][0], this.inputLines[0][1]),
					n = new jsts.geom.Envelope(this.inputLines[1][0], this.inputLines[1][1]);
				return e.contains(t) && n.contains(t)
			}, jsts.algorithm.HCoordinate = function() {
				this.x = 0, this.y = 0, this.w = 1, 1 === arguments.length ? this.initFrom1Coordinate(arguments[0]) : 2 === arguments.length && arguments[0] instanceof jsts.geom.Coordinate ? this.initFrom2Coordinates(arguments[0], arguments[1]) : 2 === arguments.length && arguments[0] instanceof jsts.algorithm.HCoordinate ? this.initFrom2HCoordinates(arguments[0], arguments[1]) : 2 === arguments.length ? this.initFromXY(arguments[0], arguments[1]) : 3 === arguments.length ? this.initFromXYW(arguments[0], arguments[1], arguments[2]) : 4 === arguments.length && this.initFromXYW(arguments[0], arguments[1], arguments[2], arguments[3])
			}, jsts.algorithm.HCoordinate.intersection = function(t, e, n, i) {
				var o, r, s, a, l, u, p, h, c, g, d;
				if (o = t.y - e.y, r = e.x - t.x, s = t.x * e.y - e.x * t.y, a = n.y - i.y, l = i.x - n.x, u = n.x * i.y - i.x * n.y, p = r * u - l * s, h = a * s - o * u, c = o * l - a * r, g = p / c, d = h / c, !isFinite(g) || !isFinite(d)) throw new jsts.error.NotRepresentableError;
				return new jsts.geom.Coordinate(g, d)
			}, jsts.algorithm.HCoordinate.prototype.initFrom1Coordinate = function(t) {
				this.x = t.x, this.y = t.y, this.w = 1
			}, jsts.algorithm.HCoordinate.prototype.initFrom2Coordinates = function(t, e) {
				this.x = t.y - e.y, this.y = e.x - t.x, this.w = t.x * e.y - e.x * t.y
			}, jsts.algorithm.HCoordinate.prototype.initFrom2HCoordinates = function(t, e) {
				this.x = t.y * e.w - e.y * t.w, this.y = e.x * t.w - t.x * e.w, this.w = t.x * e.y - e.x * t.y
			}, jsts.algorithm.HCoordinate.prototype.initFromXYW = function(t, e, n) {
				this.x = t, this.y = e, this.w = n
			}, jsts.algorithm.HCoordinate.prototype.initFromXY = function(t, e) {
				this.x = t, this.y = e, this.w = 1
			}, jsts.algorithm.HCoordinate.prototype.initFrom4Coordinates = function(t, e, n, i) {
				var o, r, s, a, l, u;
				o = t.y - e.y, r = e.x - t.x, s = t.x * e.y - e.x * t.y, a = n.y - i.y, l = i.x - n.x, u = n.x * i.y - i.x * n.y, this.x = r * u - l * s, this.y = a * s - o * u, this.w = o * l - a * r
			}, jsts.algorithm.HCoordinate.prototype.getX = function() {
				var t = this.x / this.w;
				if (!isFinite(t)) throw new jsts.error.NotRepresentableError;
				return t
			}, jsts.algorithm.HCoordinate.prototype.getY = function() {
				var t = this.y / this.w;
				if (!isFinite(t)) throw new jsts.error.NotRepresentableError;
				return t
			}, jsts.algorithm.HCoordinate.prototype.getCoordinate = function() {
				var t = new jsts.geom.Coordinate;
				return t.x = this.getX(), t.y = this.getY(), t
			}, jsts.geom.LineSegment = function() {
				0 === arguments.length ? (this.p0 = new jsts.geom.Coordinate, this.p1 = new jsts.geom.Coordinate) : 1 === arguments.length ? (this.p0 = arguments[0].p0, this.p1 = arguments[0].p1) : 2 === arguments.length ? (this.p0 = arguments[0], this.p1 = arguments[1]) : 4 === arguments.length && (this.p0 = new jsts.geom.Coordinate(arguments[0], arguments[1]), this.p1 = new jsts.geom.Coordinate(arguments[2], arguments[3]))
			}, jsts.geom.LineSegment.prototype.p0 = null, jsts.geom.LineSegment.prototype.p1 = null, jsts.geom.LineSegment.midPoint = function(t, e) {
				return new jsts.geom.Coordinate((t.x + e.x) / 2, (t.y + e.y) / 2)
			}, jsts.geom.LineSegment.prototype.getCoordinate = function(t) {
				return 0 === t ? this.p0 : this.p1
			}, jsts.geom.LineSegment.prototype.getLength = function() {
				return this.p0.distance(this.p1)
			}, jsts.geom.LineSegment.prototype.isHorizontal = function() {
				return this.p0.y === this.p1.y
			}, jsts.geom.LineSegment.prototype.isVertical = function() {
				return this.p0.x === this.p1.x
			}, jsts.geom.LineSegment.prototype.orientationIndex = function(t) {
				return t instanceof jsts.geom.LineSegment ? this.orientationIndex1(t) : t instanceof jsts.geom.Coordinate ? this.orientationIndex2(t) : void 0
			}, jsts.geom.LineSegment.prototype.orientationIndex1 = function(t) {
				var e = jsts.algorithm.CGAlgorithms.orientationIndex(this.p0, this.p1, t.p0),
					n = jsts.algorithm.CGAlgorithms.orientationIndex(this.p0, this.p1, t.p1);
				return e >= 0 && n >= 0 ? Math.max(e, n) : 0 >= e && 0 >= n ? Math.max(e, n) : 0
			}, jsts.geom.LineSegment.prototype.orientationIndex2 = function(t) {
				return jsts.algorithm.CGAlgorithms.orientationIndex(this.p0, this.p1, t)
			}, jsts.geom.LineSegment.prototype.reverse = function() {
				var t = this.p0;
				this.p0 = this.p1, this.p1 = t
			}, jsts.geom.LineSegment.prototype.normalize = function() {
				this.p1.compareTo(this.p0) < 0 && this.reverse()
			}, jsts.geom.LineSegment.prototype.angle = function() {
				return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
			}, jsts.geom.LineSegment.prototype.midPoint = function() {
				return jsts.geom.LineSegment.midPoint(this.p0, this.p1)
			}, jsts.geom.LineSegment.prototype.distance = function(t) {
				return t instanceof jsts.geom.LineSegment ? this.distance1(t) : t instanceof jsts.geom.Coordinate ? this.distance2(t) : void 0
			}, jsts.geom.LineSegment.prototype.distance1 = function(t) {
				return jsts.algorithm.CGAlgorithms.distanceLineLine(this.p0, this.p1, t.p0, t.p1)
			}, jsts.geom.LineSegment.prototype.distance2 = function(t) {
				return jsts.algorithm.CGAlgorithms.distancePointLine(t, this.p0, this.p1)
			}, jsts.geom.LineSegment.prototype.pointAlong = function(t) {
				var e = new jsts.geom.Coordinate;
				return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e
			}, jsts.geom.LineSegment.prototype.pointAlongOffset = function(t, e) {
				var n = this.p0.x + t * (this.p1.x - this.p0.x),
					i = this.p0.y + t * (this.p1.y - this.p0.y),
					o = this.p1.x - this.p0.x,
					r = this.p1.y - this.p0.y,
					s = Math.sqrt(o * o + r * r),
					a = 0,
					l = 0;
				if (0 !== e) {
					if (0 >= s) throw "Cannot compute offset from zero-length line segment";
					a = e * o / s, l = e * r / s
				}
				var u = n - l,
					p = i + a,
					h = new jsts.geom.Coordinate(u, p);
				return h
			}, jsts.geom.LineSegment.prototype.projectionFactor = function(t) {
				if (t.equals(this.p0)) return 0;
				if (t.equals(this.p1)) return 1;
				var e = this.p1.x - this.p0.x,
					n = this.p1.y - this.p0.y,
					i = e * e + n * n,
					o = ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i;
				return o
			}, jsts.geom.LineSegment.prototype.segmentFraction = function(t) {
				var e = this.projectionFactor(t);
				return 0 > e ? e = 0 : (e > 1 || isNaN(e)) && (e = 1), e
			}, jsts.geom.LineSegment.prototype.project = function(t) {
				return t instanceof jsts.geom.Coordinate ? this.project1(t) : t instanceof jsts.geom.LineSegment ? this.project2(t) : void 0
			}, jsts.geom.LineSegment.prototype.project1 = function(t) {
				if (t.equals(this.p0) || t.equals(this.p1)) return new jsts.geom.Coordinate(t);
				var e = this.projectionFactor(t),
					n = new jsts.geom.Coordinate;
				return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n
			}, jsts.geom.LineSegment.prototype.project2 = function(t) {
				var e = this.projectionFactor(t.p0),
					n = this.projectionFactor(t.p1);
				if (e >= 1 && n >= 1) return null;
				if (0 >= e && 0 >= n) return null;
				var i = this.project(t.p0);
				0 > e && (i = p0), e > 1 && (i = p1);
				var o = this.project(t.p1);
				return 0 > n && (o = p0), n > 1 && (o = p1), new jsts.geom.LineSegment(i, o)
			}, jsts.geom.LineSegment.prototype.closestPoint = function(t) {
				var e = this.projectionFactor(t);
				if (e > 0 && 1 > e) return this.project(t);
				var n = this.p0.distance(t),
					i = this.p1.distance(t);
				return i > n ? this.p0 : this.p1
			}, jsts.geom.LineSegment.prototype.closestPoints = function(t) {
				var e = this.intersection(t);
				if (null !== e) return [e, e];
				var n, i = [],
					o = Number.MAX_VALUE,
					r = this.closestPoint(t.p0);
				o = r.distance(t.p0), i[0] = r, i[1] = t.p0;
				var s = this.closestPoint(t.p1);
				n = s.distance(t.p1), o > n && (o = n, i[0] = s, i[1] = t.p1);
				var a = t.closestPoint(this.p0);
				n = a.distance(this.p0), o > n && (o = n, i[0] = this.p0, i[1] = a);
				var l = t.closestPoint(this.p1);
				return n = l.distance(this.p1), o > n && (o = n, i[0] = this.p1, i[1] = l), i
			}, jsts.geom.LineSegment.prototype.intersection = function(t) {
				var e = new jsts.algorithm.RobustLineIntersector;
				return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null
			}, jsts.geom.LineSegment.prototype.setCoordinates = function(t) {
				return t instanceof jsts.geom.Coordinate ? void this.setCoordinates2.apply(this, arguments) : void this.setCoordinates2(t.p0, t.p1)
			}, jsts.geom.LineSegment.prototype.setCoordinates2 = function(t, e) {
				this.p0.x = t.x, this.p0.y = t.y, this.p1.x = e.x, this.p1.y = e.y
			}, jsts.geom.LineSegment.prototype.distancePerpendicular = function(t) {
				return jsts.algorithm.CGAlgorithms.distancePointLinePerpendicular(t, this.p0, this.p1)
			}, jsts.geom.LineSegment.prototype.lineIntersection = function(t) {
				try {
					var e = jsts.algorithm.HCoordinate.intersection(this.p0, this.p1, t.p0, t.p1);
					return e
				} catch (n) {}
				return null
			}, jsts.geom.LineSegment.prototype.toGeometry = function(t) {
				return t.createLineString([this.p0, this.p1])
			}, jsts.geom.LineSegment.prototype.equals = function(t) {
				return t instanceof jsts.geom.LineSegment && (this.p0.equals(t.p0) && this.p1.equals(t.p1))
			}, jsts.geom.LineSegment.prototype.compareTo = function(t) {
				var e = this.p0.compareTo(t.p0);
				return 0 !== e ? e : this.p1.compareTo(t.p1)
			}, jsts.geom.LineSegment.prototype.equalsTopo = function(t) {
				return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0)
			}, jsts.geom.LineSegment.prototype.toString = function() {
				return "LINESTRING(" + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")"
			}, jsts.index.chain.MonotoneChainOverlapAction = function() {
				this.tempEnv1 = new jsts.geom.Envelope, this.tempEnv2 = new jsts.geom.Envelope, this.overlapSeg1 = new jsts.geom.LineSegment, this.overlapSeg2 = new jsts.geom.LineSegment
			}, jsts.index.chain.MonotoneChainOverlapAction.prototype.tempEnv1 = null, jsts.index.chain.MonotoneChainOverlapAction.prototype.tempEnv2 = null, jsts.index.chain.MonotoneChainOverlapAction.prototype.overlapSeg1 = null, jsts.index.chain.MonotoneChainOverlapAction.prototype.overlapSeg2 = null, jsts.index.chain.MonotoneChainOverlapAction.prototype.overlap = function(t, e, n, i) {
				this.mc1.getLineSegment(e, this.overlapSeg1), this.mc2.getLineSegment(i, this.overlapSeg2), this.overlap2(this.overlapSeg1, this.overlapSeg2)
			}, jsts.index.chain.MonotoneChainOverlapAction.prototype.overlap2 = function() {}, function() {
				var t = jsts.index.chain.MonotoneChainOverlapAction,
					e = jsts.noding.SinglePassNoder,
					n = jsts.index.strtree.STRtree,
					i = jsts.noding.NodedSegmentString,
					o = jsts.index.chain.MonotoneChainBuilder,
					r = function(t) {
						this.si = t
					};
				r.prototype = new t, r.constructor = r, r.prototype.si = null, r.prototype.overlap = function(t, e, n, i) {
					var o = t.getContext(),
						r = n.getContext();
					this.si.processIntersections(o, e, r, i)
				}, jsts.noding.MCIndexNoder = function() {
					this.monoChains = [], this.index = new n
				}, jsts.noding.MCIndexNoder.prototype = new e, jsts.noding.MCIndexNoder.constructor = jsts.noding.MCIndexNoder, jsts.noding.MCIndexNoder.prototype.monoChains = null, jsts.noding.MCIndexNoder.prototype.index = null, jsts.noding.MCIndexNoder.prototype.idCounter = 0, jsts.noding.MCIndexNoder.prototype.nodedSegStrings = null, jsts.noding.MCIndexNoder.prototype.nOverlaps = 0, jsts.noding.MCIndexNoder.prototype.getMonotoneChains = function() {
					return this.monoChains
				}, jsts.noding.MCIndexNoder.prototype.getIndex = function() {
					return this.index
				}, jsts.noding.MCIndexNoder.prototype.getNodedSubstrings = function() {
					return i.getNodedSubstrings(this.nodedSegStrings)
				}, jsts.noding.MCIndexNoder.prototype.computeNodes = function(t) {
					this.nodedSegStrings = t;
					for (var e = t.iterator(); e.hasNext();) this.add(e.next());
					this.intersectChains()
				}, jsts.noding.MCIndexNoder.prototype.intersectChains = function() {
					for (var t = new r(this.segInt), e = 0; e < this.monoChains.length; e++) for (var n = this.monoChains[e], i = this.index.query(n.getEnvelope()), o = 0; o < i.length; o++) {
						var s = i[o];
						if (s.getId() > n.getId() && (n.computeOverlaps(s, t), this.nOverlaps++), this.segInt.isDone()) return
					}
				}, jsts.noding.MCIndexNoder.prototype.add = function(t) {
					for (var e = o.getChains(t.getCoordinates(), t), n = 0; n < e.length; n++) {
						var i = e[n];
						i.setId(this.idCounter++), this.index.insert(i.getEnvelope(), i), this.monoChains.push(i)
					}
				}
			}(), jsts.simplify.LineSegmentIndex = function() {
				this.index = new jsts.index.quadtree.Quadtree
			}, jsts.simplify.LineSegmentIndex.prototype.index = null, jsts.simplify.LineSegmentIndex.prototype.add = function(t) {
				if (t instanceof jsts.geom.LineSegment) return void this.add2(t);
				for (var e = t.getSegments(), n = 0; n < e.length; n++) {
					var i = e[n];
					this.add2(i)
				}
			}, jsts.simplify.LineSegmentIndex.prototype.add2 = function(t) {
				this.index.insert(new jsts.geom.Envelope(t.p0, t.p1), t)
			}, jsts.simplify.LineSegmentIndex.prototype.remove = function(t) {
				this.index.remove(new jsts.geom.Envelope(t.p0, t.p1), t)
			}, jsts.simplify.LineSegmentIndex.prototype.query = function(t) {
				var e = new jsts.geom.Envelope(t.p0, t.p1),
					n = new jsts.simplify.LineSegmentIndex.LineSegmentVisitor(t);
				this.index.query(e, n);
				var i = n.getItems();
				return i
			}, jsts.simplify.LineSegmentIndex.LineSegmentVisitor = function(t) {
				this.items = [], this.querySeg = t
			}, jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype = new jsts.index.ItemVisitor, jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.querySeg = null, jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.items = null, jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.visitItem = function(t) {
				var e = t;
				jsts.geom.Envelope.intersects(e.p0, e.p1, this.querySeg.p0, this.querySeg.p1) && this.items.push(t)
			}, jsts.simplify.LineSegmentIndex.LineSegmentVisitor.prototype.getItems = function() {
				return this.items
			}, jsts.geomgraph.EdgeEndStar = function() {
				this.edgeMap = new javascript.util.TreeMap, this.edgeList = null, this.ptInAreaLocation = [jsts.geom.Location.NONE, jsts.geom.Location.NONE]
			}, jsts.geomgraph.EdgeEndStar.prototype.edgeMap = null, jsts.geomgraph.EdgeEndStar.prototype.edgeList = null, jsts.geomgraph.EdgeEndStar.prototype.ptInAreaLocation = null, jsts.geomgraph.EdgeEndStar.prototype.insert = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geomgraph.EdgeEndStar.prototype.insertEdgeEnd = function(t, e) {
				this.edgeMap.put(t, e), this.edgeList = null
			}, jsts.geomgraph.EdgeEndStar.prototype.getCoordinate = function() {
				var t = this.iterator();
				if (!t.hasNext()) return null;
				var e = t.next();
				return e.getCoordinate()
			}, jsts.geomgraph.EdgeEndStar.prototype.getDegree = function() {
				return this.edgeMap.size()
			}, jsts.geomgraph.EdgeEndStar.prototype.iterator = function() {
				return this.getEdges().iterator()
			}, jsts.geomgraph.EdgeEndStar.prototype.getEdges = function() {
				return null === this.edgeList && (this.edgeList = new javascript.util.ArrayList(this.edgeMap.values())), this.edgeList
			}, jsts.geomgraph.EdgeEndStar.prototype.getNextCW = function(t) {
				this.getEdges();
				var e = this.edgeList.indexOf(t),
					n = e - 1;
				return 0 === e && (n = this.edgeList.length - 1), this.edgeList[n]
			}, jsts.geomgraph.EdgeEndStar.prototype.computeLabelling = function(t) {
				this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
				for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (var i = n.next(), o = i.getLabel(), r = 0; 2 > r; r++) o.isLine(r) && o.getLocation(r) === jsts.geom.Location.BOUNDARY && (e[r] = !0);
				for (var n = this.iterator(); n.hasNext();) for (var i = n.next(), o = i.getLabel(), r = 0; 2 > r; r++) if (o.isAnyNull(r)) {
					var s = jsts.geom.Location.NONE;
					if (e[r]) s = jsts.geom.Location.EXTERIOR;
					else {
						var a = i.getCoordinate();
						s = this.getLocation(r, a, t)
					}
					o.setAllLocationsIfNull(r, s)
				}
			}, jsts.geomgraph.EdgeEndStar.prototype.computeEdgeEndLabels = function(t) {
				for (var e = this.iterator(); e.hasNext();) {
					var n = e.next();
					n.computeLabel(t)
				}
			}, jsts.geomgraph.EdgeEndStar.prototype.getLocation = function(t, e, n) {
				return this.ptInAreaLocation[t] === jsts.geom.Location.NONE && (this.ptInAreaLocation[t] = jsts.algorithm.locate.SimplePointInAreaLocator.locate(e, n[t].getGeometry())), this.ptInAreaLocation[t]
			}, jsts.geomgraph.EdgeEndStar.prototype.isAreaLabelsConsistent = function(t) {
				return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0)
			}, jsts.geomgraph.EdgeEndStar.prototype.checkAreaLabelsConsistent = function(t) {
				var e = this.getEdges();
				if (e.size() <= 0) return !0;
				var n = e.size() - 1,
					i = e.get(n).getLabel(),
					o = i.getLocation(t, jsts.geomgraph.Position.LEFT);
				jsts.util.Assert.isTrue(o != jsts.geom.Location.NONE, "Found unlabelled area edge");
				for (var r = o, s = this.iterator(); s.hasNext();) {
					var a = s.next(),
						l = a.getLabel();
					jsts.util.Assert.isTrue(l.isArea(t), "Found non-area edge");
					var u = l.getLocation(t, jsts.geomgraph.Position.LEFT),
						p = l.getLocation(t, jsts.geomgraph.Position.RIGHT);
					if (u === p) return !1;
					if (p !== r) return !1;
					r = u
				}
				return !0
			}, jsts.geomgraph.EdgeEndStar.prototype.propagateSideLabels = function(t) {
				for (var e = jsts.geom.Location.NONE, n = this.iterator(); n.hasNext();) {
					var i = n.next(),
						o = i.getLabel();
					o.isArea(t) && o.getLocation(t, jsts.geomgraph.Position.LEFT) !== jsts.geom.Location.NONE && (e = o.getLocation(t, jsts.geomgraph.Position.LEFT))
				}
				if (e !== jsts.geom.Location.NONE) for (var r = e, n = this.iterator(); n.hasNext();) {
					var i = n.next(),
						o = i.getLabel();
					if (o.getLocation(t, jsts.geomgraph.Position.ON) === jsts.geom.Location.NONE && o.setLocation(t, jsts.geomgraph.Position.ON, r), o.isArea(t)) {
						var s = o.getLocation(t, jsts.geomgraph.Position.LEFT),
							a = o.getLocation(t, jsts.geomgraph.Position.RIGHT);
						if (a !== jsts.geom.Location.NONE) {
							if (a !== r) throw new jsts.error.TopologyError("side location conflict", i.getCoordinate());
							s === jsts.geom.Location.NONE && jsts.util.Assert.shouldNeverReachHere("found single null side (at " + i.getCoordinate() + ")"), r = s
						} else jsts.util.Assert.isTrue(o.getLocation(t, jsts.geomgraph.Position.LEFT) === jsts.geom.Location.NONE, "found single null side"), o.setLocation(t, jsts.geomgraph.Position.RIGHT, r), o.setLocation(t, jsts.geomgraph.Position.LEFT, r)
					}
				}
			}, jsts.geomgraph.EdgeEndStar.prototype.findIndex = function(t) {
				this.iterator();
				for (var e = 0; e < this.edgeList.size(); e++) {
					var n = this.edgeList.get(e);
					if (n === t) return e
				}
				return -1
			}, jsts.operation.relate.EdgeEndBundleStar = function() {
				jsts.geomgraph.EdgeEndStar.apply(this, arguments)
			}, jsts.operation.relate.EdgeEndBundleStar.prototype = new jsts.geomgraph.EdgeEndStar, jsts.operation.relate.EdgeEndBundleStar.prototype.insert = function(t) {
				var e = this.edgeMap.get(t);
				null === e ? (e = new jsts.operation.relate.EdgeEndBundle(t), this.insertEdgeEnd(t, e)) : e.insert(t)
			}, jsts.operation.relate.EdgeEndBundleStar.prototype.updateIM = function(t) {
				for (var e = this.iterator(); e.hasNext();) {
					var n = e.next();
					n.updateIM(t)
				}
			}, jsts.index.ArrayListVisitor = function() {
				this.items = []
			}, jsts.index.ArrayListVisitor.prototype.visitItem = function(t) {
				this.items.push(t)
			}, jsts.index.ArrayListVisitor.prototype.getItems = function() {
				return this.items
			}, jsts.algorithm.distance.DistanceToPoint = function() {}, jsts.algorithm.distance.DistanceToPoint.computeDistance = function(t, e, n) {
				if (t instanceof jsts.geom.LineString) jsts.algorithm.distance.DistanceToPoint.computeDistance2(t, e, n);
				else if (t instanceof jsts.geom.Polygon) jsts.algorithm.distance.DistanceToPoint.computeDistance4(t, e, n);
				else if (t instanceof jsts.geom.GeometryCollection) for (var i = t, o = 0; o < i.getNumGeometries(); o++) {
					var r = i.getGeometryN(o);
					jsts.algorithm.distance.DistanceToPoint.computeDistance(r, e, n)
				} else n.setMinimum(t.getCoordinate(), e)
			}, jsts.algorithm.distance.DistanceToPoint.computeDistance2 = function(t, e, n) {
				for (var i = new jsts.geom.LineSegment, o = t.getCoordinates(), r = 0; r < o.length - 1; r++) {
					i.setCoordinates(o[r], o[r + 1]);
					var s = i.closestPoint(e);
					n.setMinimum(s, e)
				}
			}, jsts.algorithm.distance.DistanceToPoint.computeDistance3 = function(t, e, n) {
				var i = t.closestPoint(e);
				n.setMinimum(i, e)
			}, jsts.algorithm.distance.DistanceToPoint.computeDistance4 = function(t, e, n) {
				jsts.algorithm.distance.DistanceToPoint.computeDistance2(t.getExteriorRing(), e, n);
				for (var i = 0; i < t.getNumInteriorRing(); i++) jsts.algorithm.distance.DistanceToPoint.computeDistance2(t.getInteriorRingN(i), e, n)
			}, jsts.index.strtree.ItemBoundable = function(t, e) {
				this.bounds = t, this.item = e
			}, jsts.index.strtree.ItemBoundable.prototype = new jsts.index.strtree.Boundable, jsts.index.strtree.ItemBoundable.constructor = jsts.index.strtree.ItemBoundable, jsts.index.strtree.ItemBoundable.prototype.bounds = null, jsts.index.strtree.ItemBoundable.prototype.item = null, jsts.index.strtree.ItemBoundable.prototype.getBounds = function() {
				return this.bounds
			}, jsts.index.strtree.ItemBoundable.prototype.getItem = function() {
				return this.item
			}, function() {
				var t = javascript.util.ArrayList,
					e = javascript.util.TreeMap;
				jsts.geomgraph.EdgeList = function() {
					this.edges = new t, this.ocaMap = new e
				}, jsts.geomgraph.EdgeList.prototype.edges = null, jsts.geomgraph.EdgeList.prototype.ocaMap = null, jsts.geomgraph.EdgeList.prototype.add = function(t) {
					this.edges.add(t);
					var e = new jsts.noding.OrientedCoordinateArray(t.getCoordinates());
					this.ocaMap.put(e, t)
				}, jsts.geomgraph.EdgeList.prototype.addAll = function(t) {
					for (var e = t.iterator(); e.hasNext();) this.add(e.next())
				}, jsts.geomgraph.EdgeList.prototype.getEdges = function() {
					return this.edges
				}, jsts.geomgraph.EdgeList.prototype.findEqualEdge = function(t) {
					var e = new jsts.noding.OrientedCoordinateArray(t.getCoordinates()),
						n = this.ocaMap.get(e);
					return n
				}, jsts.geomgraph.EdgeList.prototype.getEdges = function() {
					return this.edges
				}, jsts.geomgraph.EdgeList.prototype.iterator = function() {
					return this.edges.iterator()
				}, jsts.geomgraph.EdgeList.prototype.get = function(t) {
					return this.edges.get(t)
				}, jsts.geomgraph.EdgeList.prototype.findEdgeIndex = function(t) {
					for (var e = 0; e < this.edges.size(); e++) if (this.edges.get(e).equals(t)) return e;
					return -1
				}
			}(), jsts.operation.IsSimpleOp = function(t) {
				this.geom = t
			}, jsts.operation.IsSimpleOp.prototype.geom = null, jsts.operation.IsSimpleOp.prototype.isClosedEndpointsInInterior = !0, jsts.operation.IsSimpleOp.prototype.nonSimpleLocation = null, jsts.operation.IsSimpleOp.prototype.IsSimpleOp = function(t) {
				this.geom = t
			}, jsts.operation.IsSimpleOp.prototype.isSimple = function() {
				return this.nonSimpleLocation = null, this.geom instanceof jsts.geom.LineString ? this.isSimpleLinearGeometry(this.geom) : this.geom instanceof jsts.geom.MultiLineString ? this.isSimpleLinearGeometry(this.geom) : !(this.geom instanceof jsts.geom.MultiPoint) || this.isSimpleMultiPoint(this.geom)
			}, jsts.operation.IsSimpleOp.prototype.isSimpleMultiPoint = function(t) {
				if (t.isEmpty()) return !0;
				for (var e = [], n = 0; n < t.getNumGeometries(); n++) {
					for (var i = t.getGeometryN(n), o = i.getCoordinate(), r = 0; r < e.length; r++) {
						var s = e[r];
						if (o.equals2D(s)) return this.nonSimpleLocation = o, !1
					}
					e.push(o)
				}
				return !0
			}, jsts.operation.IsSimpleOp.prototype.isSimpleLinearGeometry = function(t) {
				if (t.isEmpty()) return !0;
				var e = new jsts.geomgraph.GeometryGraph(0, t),
					n = new jsts.algorithm.RobustLineIntersector,
					i = e.computeSelfNodes(n, !0);
				return !i.hasIntersection() || (i.hasProperIntersection() ? (this.nonSimpleLocation = i.getProperIntersectionPoint(), !1) : !this.hasNonEndpointIntersection(e) && (!this.isClosedEndpointsInInterior || !this.hasClosedEndpointIntersection(e)))
			}, jsts.operation.IsSimpleOp.prototype.hasNonEndpointIntersection = function(t) {
				for (var e = t.getEdgeIterator(); e.hasNext();) for (var n = e.next(), i = n.getMaximumSegmentIndex(), o = n.getEdgeIntersectionList().iterator(); o.hasNext();) {
					var r = o.next();
					if (!r.isEndPoint(i)) return this.nonSimpleLocation = r.getCoordinate(), !0
				}
				return !1
			}, jsts.operation.IsSimpleOp.prototype.hasClosedEndpointIntersection = function(t) {
				for (var e = new javascript.util.TreeMap, n = t.getEdgeIterator(); n.hasNext();) {
					var i = n.next(),
						o = (i.getMaximumSegmentIndex(), i.isClosed()),
						r = i.getCoordinate(0);
					this.addEndpoint(e, r, o);
					var s = i.getCoordinate(i.getNumPoints() - 1);
					this.addEndpoint(e, s, o)
				}
				for (var n = e.values().iterator(); n.hasNext();) {
					var a = n.next();
					if (a.isClosed && 2 != a.degree) return this.nonSimpleLocation = a.getCoordinate(), !0
				}
				return !1
			}, jsts.operation.IsSimpleOp.EndpointInfo = function(t) {
				this.pt = t, this.isClosed = !1, this.degree = 0
			}, jsts.operation.IsSimpleOp.EndpointInfo.prototype.pt = null, jsts.operation.IsSimpleOp.EndpointInfo.prototype.isClosed = null, jsts.operation.IsSimpleOp.EndpointInfo.prototype.degree = null, jsts.operation.IsSimpleOp.EndpointInfo.prototype.getCoordinate = function() {
				return this.pt
			}, jsts.operation.IsSimpleOp.EndpointInfo.prototype.addEndpoint = function(t) {
				this.degree++, this.isClosed = this.isClosed || t
			}, jsts.operation.IsSimpleOp.prototype.addEndpoint = function(t, e, n) {
				var i = t.get(e);
				null === i && (i = new jsts.operation.IsSimpleOp.EndpointInfo(e), t.put(e, i)), i.addEndpoint(n)
			}, function() {
				var t = function() {
						this.snapTolerance = 0, this.seg = new jsts.geom.LineSegment, this.allowSnappingToSourceVertices = !1, this.isClosed = !1, this.srcPts = [], arguments[0] instanceof jsts.geom.LineString ? this.initFromLine.apply(this, arguments) : this.initFromPoints.apply(this, arguments)
					};
				t.prototype.initFromLine = function(t, e) {
					this.initFromPoints(t.getCoordinates(), e)
				}, t.prototype.initFromPoints = function(t, e) {
					this.srcPts = t, this.isClosed = this.calcIsClosed(t), this.snapTolerance = e
				}, t.prototype.setAllowSnappingToSourceVertices = function(t) {
					this.allowSnappingToSourceVertices = t
				}, t.prototype.calcIsClosed = function(t) {
					return !(t.length <= 1) && t[0].equals(t[t.length - 1])
				}, t.prototype.snapTo = function(t) {
					var e = new jsts.geom.CoordinateList(this.srcPts);
					return this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray()
				}, t.prototype.snapVertices = function(t, e) {
					var n, i, o = this.isClosed ? t.size() - 1 : t.size(),
						r = 0;
					for (r; o > r; r++) n = t.get(r), i = this.findSnapForVertex(n, e), null !== i && (t.set(r, new jsts.geom.Coordinate(i)), 0 === r && this.isClosed && t.set(t.size() - 1, new jsts.geom.Coordinate(i)))
				}, t.prototype.findSnapForVertex = function(t, e) {
					var n = 0,
						i = e.length;
					for (n = 0; i > n; n++) {
						if (t.equals(e[n])) return null;
						if (t.distance(e[n]) < this.snapTolerance) return e[n]
					}
					return null
				}, t.prototype.snapSegments = function(t, e) {
					if (0 !== e.length) {
						var n, i, o, r = e.length;
						for (e.length > 1 && e[0].equals2D(e[e.length - 1]) && (r = e.length - 1), n = 0; r > n; n++) i = e[n], o = this.findSegmentIndexToSnap(i, t), o >= 0 && t.add(o + 1, new jsts.geom.Coordinate(i), !1)
					}
				}, t.prototype.findSegmentIndexToSnap = function(t, e) {
					var n, i = Number.MAX_VALUE,
						o = -1,
						r = 0;
					for (r; r < e.size() - 1; r++) {
						if (this.seg.p0 = e.get(r), this.seg.p1 = e.get(r + 1), this.seg.p0.equals(t) || this.seg.p1.equals(t)) {
							if (this.allowSnappingToSourceVertices) continue;
							return -1
						}
						n = this.seg.distance(t), n < this.snapTolerance && i > n && (i = n, o = r)
					}
					return o
				}, jsts.operation.overlay.snap.LineStringSnapper = t
			}(), function() {
				var t = javascript.util.ArrayList,
					e = jsts.geom.GeometryComponentFilter,
					n = jsts.geom.LineString,
					i = jsts.operation.polygonize.EdgeRing,
					o = jsts.operation.polygonize.PolygonizeGraph,
					r = function() {
						var i = this,
							o = function() {};
						o.prototype = new e, o.prototype.filter = function(t) {
							t instanceof n && i.add(t)
						}, this.lineStringAdder = new o, this.dangles = new t, this.cutEdges = new t, this.invalidRingLines = new t
					};
				r.prototype.lineStringAdder = null, r.prototype.graph = null, r.prototype.dangles = null, r.prototype.cutEdges = null, r.prototype.invalidRingLines = null, r.prototype.holeList = null, r.prototype.shellList = null, r.prototype.polyList = null, r.prototype.add = function(t) {
					if (t instanceof jsts.geom.LineString) return this.add3(t);
					if (t instanceof jsts.geom.Geometry) return this.add2(t);
					for (var e = t.iterator(); e.hasNext();) {
						var n = e.next();
						this.add2(n)
					}
				}, r.prototype.add2 = function(t) {
					t.apply(this.lineStringAdder)
				}, r.prototype.add3 = function(t) {
					null == this.graph && (this.graph = new o(t.getFactory())), this.graph.addEdge(t)
				}, r.prototype.getPolygons = function() {
					return this.polygonize(), this.polyList
				}, r.prototype.getDangles = function() {
					return this.polygonize(), this.dangles
				}, r.prototype.getCutEdges = function() {
					return this.polygonize(), this.cutEdges
				}, r.prototype.getInvalidRingLines = function() {
					return this.polygonize(), this.invalidRingLines
				}, r.prototype.polygonize = function() {
					if (null == this.polyList && (this.polyList = new t, null != this.graph)) {
						this.dangles = this.graph.deleteDangles(), this.cutEdges = this.graph.deleteCutEdges();
						var e = this.graph.getEdgeRings(),
							n = new t;
						this.invalidRingLines = new t, this.findValidRings(e, n, this.invalidRingLines), this.findShellsAndHoles(n), r.assignHolesToShells(this.holeList, this.shellList), this.polyList = new t;
						for (var i = this.shellList.iterator(); i.hasNext();) {
							var o = i.next();
							this.polyList.add(o.getPolygon())
						}
					}
				}, r.prototype.findValidRings = function(t, e, n) {
					for (var i = t.iterator(); i.hasNext();) {
						var o = i.next();
						o.isValid() ? e.add(o) : n.add(o.getLineString())
					}
				}, r.prototype.findShellsAndHoles = function(e) {
					this.holeList = new t, this.shellList = new t;
					for (var n = e.iterator(); n.hasNext();) {
						var i = n.next();
						i.isHole() ? this.holeList.add(i) : this.shellList.add(i)
					}
				}, r.assignHolesToShells = function(t, e) {
					for (var n = t.iterator(); n.hasNext();) {
						var i = n.next();
						r.assignHoleToShell(i, e)
					}
				}, r.assignHoleToShell = function(t, e) {
					var n = i.findEdgeRingContaining(t, e);
					null != n && n.addHole(t.getRing())
				}, jsts.operation.polygonize.Polygonizer = r
			}(), function() {
				var t = javascript.util.ArrayList,
					e = function() {};
				e.prototype.inputGeom = null, e.prototype.factory = null, e.prototype.pruneEmptyGeometry = !0, e.prototype.preserveGeometryCollectionType = !0, e.prototype.preserveCollections = !1, e.prototype.reserveType = !1, e.prototype.getInputGeometry = function() {
					return this.inputGeom
				}, e.prototype.transform = function(t) {
					if (this.inputGeom = t, this.factory = t.getFactory(), t instanceof jsts.geom.Point) return this.transformPoint(t, null);
					if (t instanceof jsts.geom.MultiPoint) return this.transformMultiPoint(t, null);
					if (t instanceof jsts.geom.LinearRing) return this.transformLinearRing(t, null);
					if (t instanceof jsts.geom.LineString) return this.transformLineString(t, null);
					if (t instanceof jsts.geom.MultiLineString) return this.transformMultiLineString(t, null);
					if (t instanceof jsts.geom.Polygon) return this.transformPolygon(t, null);
					if (t instanceof jsts.geom.MultiPolygon) return this.transformMultiPolygon(t, null);
					if (t instanceof jsts.geom.GeometryCollection) return this.transformGeometryCollection(t, null);
					throw new jsts.error.IllegalArgumentException("Unknown Geometry subtype: " + t.getClass().getName())
				}, e.prototype.createCoordinateSequence = function(t) {
					return this.factory.getCoordinateSequenceFactory().create(t)
				}, e.prototype.copy = function(t) {
					return t.clone()
				}, e.prototype.transformCoordinates = function(t) {
					return this.copy(t)
				}, e.prototype.transformPoint = function(t) {
					return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t))
				}, e.prototype.transformMultiPoint = function(e) {
					for (var n = new t, i = 0; i < e.getNumGeometries(); i++) {
						var o = this.transformPoint(e.getGeometryN(i), e);
						null != o && (o.isEmpty() || n.add(o))
					}
					return this.factory.buildGeometry(n)
				}, e.prototype.transformLinearRing = function(t) {
					var e = this.transformCoordinates(t.getCoordinateSequence(), t),
						n = e.length;
					return n > 0 && 4 > n && !this.preserveType ? this.factory.createLineString(e) : this.factory.createLinearRing(e)
				}, e.prototype.transformLineString = function(t) {
					return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t))
				}, e.prototype.transformMultiLineString = function(e) {
					for (var n = new t, i = 0; i < e.getNumGeometries(); i++) {
						var o = this.transformLineString(e.getGeometryN(i), e);
						null != o && (o.isEmpty() || n.add(o))
					}
					return this.factory.buildGeometry(n)
				}, e.prototype.transformPolygon = function(e) {
					var n = !0,
						i = this.transformLinearRing(e.getExteriorRing(), e);
					null != i && i instanceof jsts.geom.LinearRing && !i.isEmpty() || (n = !1);
					for (var o = new t, r = 0; r < e.getNumInteriorRing(); r++) {
						var s = this.transformLinearRing(e.getInteriorRingN(r), e);
						null == s || s.isEmpty() || (s instanceof jsts.geom.LinearRing || (n = !1), o.add(s))
					}
					if (n) return this.factory.createPolygon(i, o.toArray());
					var a = new t;
					return null != i && a.add(i), a.addAll(o), this.factory.buildGeometry(a)
				}, e.prototype.transformMultiPolygon = function(e) {
					for (var n = new t, i = 0; i < e.getNumGeometries(); i++) {
						var o = this.transformPolygon(e.getGeometryN(i), e);
						null != o && (o.isEmpty() || n.add(o))
					}
					return this.factory.buildGeometry(n)
				}, e.prototype.transformGeometryCollection = function(e) {
					for (var n = new t, i = 0; i < e.getNumGeometries(); i++) {
						var o = this.transform(e.getGeometryN(i));
						null != o && (this.pruneEmptyGeometry && o.isEmpty() || n.add(o))
					}
					return this.preserveGeometryCollectionType ? this.factory.createGeometryCollection(GeometryFactory.toGeometryArray(n)) : this.factory.buildGeometry(n)
				}, jsts.geom.util.GeometryTransformer = e
			}(), function() {
				var t = jsts.operation.overlay.snap.LineStringSnapper,
					e = jsts.geom.PrecisionModel,
					n = javascript.util.TreeSet,
					i = function(t, e, n) {
						this.snapTolerance = t, this.snapPts = e, this.isSelfSnap = n || !1
					};
				i.prototype = new jsts.geom.util.GeometryTransformer, i.prototype.snapTolerance = null, i.prototype.snapPts = null, i.prototype.isSelfSnap = !1, i.prototype.transformCoordinates = function(t) {
					var e = t,
						n = this.snapLine(e, this.snapPts);
					return n
				}, i.prototype.snapLine = function(e, n) {
					var i = new t(e, this.snapTolerance);
					return i.setAllowSnappingToSourceVertices(this.isSelfSnap), i.snapTo(n)
				};
				var o = function(t) {
						this.srcGeom = t
					};
				o.SNAP_PRECISION_FACTOR = 1e-9, o.computeOverlaySnapTolerance = function(t) {
					if (2 === arguments.length) return o.computeOverlaySnapTolerance2.apply(this, arguments);
					var n = this.computeSizeBasedSnapTolerance(t),
						i = t.getPrecisionModel();
					if (i.getType() == e.FIXED) {
						var r = 1 / i.getScale() * 2 / 1.415;
						r > n && (n = r)
					}
					return n
				}, o.computeSizeBasedSnapTolerance = function(t) {
					var e = t.getEnvelopeInternal(),
						n = Math.min(e.getHeight(), e.getWidth()),
						i = n * o.SNAP_PRECISION_FACTOR;
					return i
				}, o.computeOverlaySnapTolerance2 = function(t, e) {
					return Math.min(this.computeOverlaySnapTolerance(t), this.computeOverlaySnapTolerance(e))
				}, o.snap = function(t, e, n) {
					var i = [],
						r = new o(t);
					i[0] = r.snapTo(e, n);
					var s = new o(e);
					return i[1] = s.snapTo(i[0], n), i
				}, o.snapToSelf = function(t, e, n) {
					var i = new o(t);
					return i.snapToSelf(e, n)
				}, o.prototype.srcGeom = null, o.prototype.snapTo = function(t, e) {
					var n = this.extractTargetCoordinates(t),
						o = new i(e, n);
					return o.transform(this.srcGeom)
				}, o.prototype.snapToSelf = function(t, e) {
					var n = this.extractTargetCoordinates(srcGeom),
						o = new i(t, n, (!0)),
						r = o.transform(srcGeom),
						s = r;
					return e && s instanceof Polygonal && (s = r.buffer(0)), s
				}, o.prototype.extractTargetCoordinates = function(t) {
					for (var e = new n, i = t.getCoordinates(), o = 0; o < i.length; o++) e.add(i[o]);
					return e.toArray()
				}, o.prototype.computeSnapTolerance = function(t) {
					var e = this.computeMinimumSegmentLength(t),
						n = e / 10;
					return n
				}, o.prototype.computeMinimumSegmentLength = function(t) {
					for (var e = Number.MAX_VALUE, n = 0; n < t.length - 1; n++) {
						var i = t[n].distance(t[n + 1]);
						e > i && (e = i)
					}
					return e
				}, jsts.operation.overlay.snap.GeometrySnapper = o
			}(), jsts.algorithm.PointLocator = function(t) {
				this.boundaryRule = t ? t : jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE
			}, jsts.algorithm.PointLocator.prototype.boundaryRule = null, jsts.algorithm.PointLocator.prototype.isIn = null, jsts.algorithm.PointLocator.prototype.numBoundaries = null, jsts.algorithm.PointLocator.prototype.intersects = function(t, e) {
				return this.locate(t, e) !== jsts.geom.Location.EXTERIOR
			}, jsts.algorithm.PointLocator.prototype.locate = function(t, e) {
				return e.isEmpty() ? jsts.geom.Location.EXTERIOR : e instanceof jsts.geom.Point ? this.locate2(t, e) : e instanceof jsts.geom.LineString ? this.locate3(t, e) : e instanceof jsts.geom.Polygon ? this.locate4(t, e) : (this.isIn = !1, this.numBoundaries = 0, this.computeLocation(t, e), this.boundaryRule.isInBoundary(this.numBoundaries) ? jsts.geom.Location.BOUNDARY : this.numBoundaries > 0 || this.isIn ? jsts.geom.Location.INTERIOR : jsts.geom.Location.EXTERIOR)
			}, jsts.algorithm.PointLocator.prototype.computeLocation = function(t, e) {
				if (e instanceof jsts.geom.Point || e instanceof jsts.geom.LineString || e instanceof jsts.geom.Polygon) this.updateLocationInfo(this.locate(t, e));
				else if (e instanceof jsts.geom.MultiLineString) for (var n = e, i = 0; i < n.getNumGeometries(); i++) {
					var o = n.getGeometryN(i);
					this.updateLocationInfo(this.locate(t, o))
				} else if (e instanceof jsts.geom.MultiPolygon) for (var r = e, i = 0; i < r.getNumGeometries(); i++) {
					var s = r.getGeometryN(i);
					this.updateLocationInfo(this.locate(t, s))
				} else if (e instanceof jsts.geom.MultiPoint || e instanceof jsts.geom.GeometryCollection) for (var i = 0; i < e.getNumGeometries(); i++) {
					var a = e.getGeometryN(i);
					a !== e && this.computeLocation(t, a)
				}
			}, jsts.algorithm.PointLocator.prototype.updateLocationInfo = function(t) {
				t === jsts.geom.Location.INTERIOR && (this.isIn = !0), t === jsts.geom.Location.BOUNDARY && this.numBoundaries++
			}, jsts.algorithm.PointLocator.prototype.locate2 = function(t, e) {
				var n = e.getCoordinate();
				return n.equals2D(t) ? jsts.geom.Location.INTERIOR : jsts.geom.Location.EXTERIOR
			}, jsts.algorithm.PointLocator.prototype.locate3 = function(t, e) {
				if (!e.getEnvelopeInternal().intersects(t)) return jsts.geom.Location.EXTERIOR;
				var n = e.getCoordinates();
				return e.isClosed() || !t.equals(n[0]) && !t.equals(n[n.length - 1]) ? jsts.algorithm.CGAlgorithms.isOnLine(t, n) ? jsts.geom.Location.INTERIOR : jsts.geom.Location.EXTERIOR : jsts.geom.Location.BOUNDARY
			}, jsts.algorithm.PointLocator.prototype.locateInPolygonRing = function(t, e) {
				return e.getEnvelopeInternal().intersects(t) ? jsts.algorithm.CGAlgorithms.locatePointInRing(t, e.getCoordinates()) : jsts.geom.Location.EXTERIOR
			}, jsts.algorithm.PointLocator.prototype.locate4 = function(t, e) {
				if (e.isEmpty()) return jsts.geom.Location.EXTERIOR;
				var n = e.getExteriorRing(),
					i = this.locateInPolygonRing(t, n);
				if (i === jsts.geom.Location.EXTERIOR) return jsts.geom.Location.EXTERIOR;
				if (i === jsts.geom.Location.BOUNDARY) return jsts.geom.Location.BOUNDARY;
				for (var o = 0; o < e.getNumInteriorRing(); o++) {
					var r = e.getInteriorRingN(o),
						s = this.locateInPolygonRing(t, r);
					if (s === jsts.geom.Location.INTERIOR) return jsts.geom.Location.EXTERIOR;
					if (s === jsts.geom.Location.BOUNDARY) return jsts.geom.Location.BOUNDARY
				}
				return jsts.geom.Location.INTERIOR
			}, function() {
				var t = jsts.geom.Location,
					e = javascript.util.ArrayList,
					n = javascript.util.TreeMap;
				jsts.geomgraph.NodeMap = function(t) {
					this.nodeMap = new n, this.nodeFact = t
				}, jsts.geomgraph.NodeMap.prototype.nodeMap = null, jsts.geomgraph.NodeMap.prototype.nodeFact = null, jsts.geomgraph.NodeMap.prototype.addNode = function(t) {
					var e, n;
					if (t instanceof jsts.geom.Coordinate) return n = t, e = this.nodeMap.get(n), null === e && (e = this.nodeFact.createNode(n), this.nodeMap.put(n, e)), e;
					if (t instanceof jsts.geomgraph.Node) {
						var i = t;
						return n = i.getCoordinate(), e = this.nodeMap.get(n), null === e ? (this.nodeMap.put(n, i), i) : (e.mergeLabel(i), e)
					}
				}, jsts.geomgraph.NodeMap.prototype.add = function(t) {
					var e = t.getCoordinate(),
						n = this.addNode(e);
					n.add(t)
				}, jsts.geomgraph.NodeMap.prototype.find = function(t) {
					return this.nodeMap.get(t)
				}, jsts.geomgraph.NodeMap.prototype.values = function() {
					return this.nodeMap.values()
				}, jsts.geomgraph.NodeMap.prototype.iterator = function() {
					return this.values().iterator()
				}, jsts.geomgraph.NodeMap.prototype.getBoundaryNodes = function(n) {
					for (var i = new e, o = this.iterator(); o.hasNext();) {
						var r = o.next();
						r.getLabel().getLocation(n) === t.BOUNDARY && i.add(r)
					}
					return i
				}
			}(), function() {
				var t = javascript.util.ArrayList;
				jsts.geomgraph.PlanarGraph = function(e) {
					this.edges = new t, this.edgeEndList = new t, this.nodes = new jsts.geomgraph.NodeMap(e || new jsts.geomgraph.NodeFactory)
				}, jsts.geomgraph.PlanarGraph.prototype.edges = null, jsts.geomgraph.PlanarGraph.prototype.nodes = null, jsts.geomgraph.PlanarGraph.prototype.edgeEndList = null, jsts.geomgraph.PlanarGraph.linkResultDirectedEdges = function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var n = e.next();
						n.getEdges().linkResultDirectedEdges()
					}
				}, jsts.geomgraph.PlanarGraph.prototype.getEdgeIterator = function() {
					return this.edges.iterator()
				}, jsts.geomgraph.PlanarGraph.prototype.getEdgeEnds = function() {
					return this.edgeEndList
				}, jsts.geomgraph.PlanarGraph.prototype.isBoundaryNode = function(t, e) {
					var n = this.nodes.find(e);
					if (null === n) return !1;
					var i = n.getLabel();
					return null !== i && i.getLocation(t) === jsts.geom.Location.BOUNDARY
				}, jsts.geomgraph.PlanarGraph.prototype.insertEdge = function(t) {
					this.edges.add(t)
				}, jsts.geomgraph.PlanarGraph.prototype.add = function(t) {
					this.nodes.add(t), this.edgeEndList.add(t)
				}, jsts.geomgraph.PlanarGraph.prototype.getNodeIterator = function() {
					return this.nodes.iterator()
				}, jsts.geomgraph.PlanarGraph.prototype.getNodes = function() {
					return this.nodes.values()
				}, jsts.geomgraph.PlanarGraph.prototype.addNode = function(t) {
					return this.nodes.addNode(t)
				}, jsts.geomgraph.PlanarGraph.prototype.addEdges = function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var n = e.next();
						this.edges.add(n);
						var i = new jsts.geomgraph.DirectedEdge(n, (!0)),
							o = new jsts.geomgraph.DirectedEdge(n, (!1));
						i.setSym(o), o.setSym(i), this.add(i), this.add(o)
					}
				}, jsts.geomgraph.PlanarGraph.prototype.linkResultDirectedEdges = function() {
					for (var t = this.nodes.iterator(); t.hasNext();) {
						var e = t.next();
						e.getEdges().linkResultDirectedEdges()
					}
				}, jsts.geomgraph.PlanarGraph.prototype.findEdgeInSameDirection = function(t, e) {
					var n, i, o = 0,
						r = this.edges.size();
					for (o; r > o; o++) {
						if (n = this.edges.get(o), i = n.getCoordinates(), this.matchInSameDirection(t, e, i[0], i[1])) return n;
						if (this.matchInSameDirection(t, e, i[i.length - 1], i[i.length - 2])) return n
					}
					return null
				}, jsts.geomgraph.PlanarGraph.prototype.matchInSameDirection = function(t, e, n, i) {
					return !(!t.equals(n) || jsts.algorithm.CGAlgorithms.computeOrientation(t, e, i) !== jsts.algorithm.CGAlgorithms.COLLINEAR || jsts.geomgraph.Quadrant.quadrant(t, e) !== jsts.geomgraph.Quadrant.quadrant(n, i))
				}, jsts.geomgraph.PlanarGraph.prototype.findEdgeEnd = function(t) {
					for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {
						var n = e.next();
						if (n.getEdge() === t) return n
					}
					return null
				}
			}(), jsts.noding.SegmentIntersector = function() {}, jsts.noding.SegmentIntersector.prototype.processIntersections = jsts.abstractFunc, jsts.noding.SegmentIntersector.prototype.isDone = jsts.abstractFunc, function() {
				var t = jsts.noding.SegmentIntersector,
					e = javascript.util.ArrayList;
				jsts.noding.InteriorIntersectionFinder = function(t) {
					this.li = t, this.intersections = new e, this.interiorIntersection = null
				}, jsts.noding.InteriorIntersectionFinder.prototype = new t, jsts.noding.InteriorIntersectionFinder.constructor = jsts.noding.InteriorIntersectionFinder, jsts.noding.InteriorIntersectionFinder.prototype.findAllIntersections = !1, jsts.noding.InteriorIntersectionFinder.prototype.isCheckEndSegmentsOnly = !1, jsts.noding.InteriorIntersectionFinder.prototype.li = null, jsts.noding.InteriorIntersectionFinder.prototype.interiorIntersection = null, jsts.noding.InteriorIntersectionFinder.prototype.intSegments = null, jsts.noding.InteriorIntersectionFinder.prototype.intersections = null, jsts.noding.InteriorIntersectionFinder.prototype.setFindAllIntersections = function(t) {
					this.findAllIntersections = t
				}, jsts.noding.InteriorIntersectionFinder.prototype.getIntersections = function() {
					return intersections
				}, jsts.noding.InteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function(t) {
					this.isCheckEndSegmentsOnly = t
				}, jsts.noding.InteriorIntersectionFinder.prototype.hasIntersection = function() {
					return null != this.interiorIntersection
				}, jsts.noding.InteriorIntersectionFinder.prototype.getInteriorIntersection = function() {
					return this.interiorIntersection
				}, jsts.noding.InteriorIntersectionFinder.prototype.getIntersectionSegments = function() {
					return this.intSegments
				}, jsts.noding.InteriorIntersectionFinder.prototype.processIntersections = function(t, e, n, i) {
					if (!this.hasIntersection() && (t != n || e != i)) {
						if (this.isCheckEndSegmentsOnly) {
							var o = this.isEndSegment(t, e) || isEndSegment(n, i);
							if (!o) return
						}
						var r = t.getCoordinates()[e],
							s = t.getCoordinates()[e + 1],
							a = n.getCoordinates()[i],
							l = n.getCoordinates()[i + 1];
						this.li.computeIntersection(r, s, a, l), this.li.hasIntersection() && this.li.isInteriorIntersection() && (this.intSegments = [], this.intSegments[0] = r, this.intSegments[1] = s, this.intSegments[2] = a, this.intSegments[3] = l, this.interiorIntersection = this.li.getIntersection(0), this.intersections.add(this.interiorIntersection))
					}
				}, jsts.noding.InteriorIntersectionFinder.prototype.isEndSegment = function(t, e) {
					return 0 == e || e >= t.size() - 2
				}, jsts.noding.InteriorIntersectionFinder.prototype.isDone = function() {
					return !this.findAllIntersections && null != this.interiorIntersection
				}
			}(), function() {
				var t = jsts.algorithm.RobustLineIntersector,
					e = jsts.noding.InteriorIntersectionFinder,
					n = jsts.noding.MCIndexNoder;
				jsts.noding.FastNodingValidator = function(e) {
					this.li = new t, this.segStrings = e
				}, jsts.noding.FastNodingValidator.prototype.li = null, jsts.noding.FastNodingValidator.prototype.segStrings = null, jsts.noding.FastNodingValidator.prototype.findAllIntersections = !1, jsts.noding.FastNodingValidator.prototype.segInt = null, jsts.noding.FastNodingValidator.prototype._isValid = !0, jsts.noding.FastNodingValidator.prototype.setFindAllIntersections = function(t) {
					this.findAllIntersections = t
				}, jsts.noding.FastNodingValidator.prototype.getIntersections = function() {
					return segInt.getIntersections()
				}, jsts.noding.FastNodingValidator.prototype.isValid = function() {
					return this.execute(), this._isValid
				}, jsts.noding.FastNodingValidator.prototype.getErrorMessage = function() {
					if (this._isValid) return "no intersections found";
					var t = this.segInt.getIntersectionSegments();
					return "found non-noded intersection between " + jsts.io.WKTWriter.toLineString(t[0], t[1]) + " and " + jsts.io.WKTWriter.toLineString(t[2], t[3])
				}, jsts.noding.FastNodingValidator.prototype.checkValid = function() {
					if (this.execute(), !this._isValid) throw new jsts.error.TopologyError(this.getErrorMessage(), this.segInt.getInteriorIntersection())
				}, jsts.noding.FastNodingValidator.prototype.execute = function() {
					null == this.segInt && this.checkInteriorIntersections()
				}, jsts.noding.FastNodingValidator.prototype.checkInteriorIntersections = function() {
					this._isValid = !0, this.segInt = new e(this.li), this.segInt.setFindAllIntersections(this.findAllIntersections);
					var t = new n;
					return t.setSegmentIntersector(this.segInt), t.computeNodes(this.segStrings), this.segInt.hasIntersection() ? void(this._isValid = !1) : void 0
				}
			}(), function() {
				jsts.noding.BasicSegmentString = function(t, e) {
					this.pts = t, this.data = e
				}, jsts.noding.BasicSegmentString.prototype = new jsts.noding.SegmentString, jsts.noding.BasicSegmentString.prototype.pts = null, jsts.noding.BasicSegmentString.prototype.data = null, jsts.noding.BasicSegmentString.prototype.getData = function() {
					return this.data
				}, jsts.noding.BasicSegmentString.prototype.setData = function(t) {
					this.data = t
				}, jsts.noding.BasicSegmentString.prototype.size = function() {
					return this.pts.length
				}, jsts.noding.BasicSegmentString.prototype.getCoordinate = function(t) {
					return this.pts[t]
				}, jsts.noding.BasicSegmentString.prototype.getCoordinates = function() {
					return this.pts
				}, jsts.noding.BasicSegmentString.prototype.isClosed = function() {
					return this.pts[0].equals(this.pts[this.pts.length - 1])
				}, jsts.noding.BasicSegmentString.prototype.getSegmentOctant = function(t) {
					return t == this.pts.length - 1 ? -1 : jsts.noding.Octant.octant(this.getCoordinate(t), this.getCoordinate(t + 1));
				}
			}(), function() {
				var t = jsts.noding.FastNodingValidator,
					e = jsts.noding.BasicSegmentString,
					n = javascript.util.ArrayList;
				jsts.geomgraph.EdgeNodingValidator = function(e) {
					this.nv = new t(jsts.geomgraph.EdgeNodingValidator.toSegmentStrings(e))
				}, jsts.geomgraph.EdgeNodingValidator.checkValid = function(t) {
					var e = new jsts.geomgraph.EdgeNodingValidator(t);
					e.checkValid()
				}, jsts.geomgraph.EdgeNodingValidator.toSegmentStrings = function(t) {
					for (var i = new n, o = t.iterator(); o.hasNext();) {
						var r = o.next();
						i.add(new e(r.getCoordinates(), r))
					}
					return i
				}, jsts.geomgraph.EdgeNodingValidator.prototype.nv = null, jsts.geomgraph.EdgeNodingValidator.prototype.checkValid = function() {
					this.nv.checkValid()
				}
			}(), jsts.operation.GeometryGraphOperation = function(t, e, n) {
				if (this.li = new jsts.algorithm.RobustLineIntersector, this.arg = [], void 0 !== t) {
					if (void 0 === e) return this.setComputationPrecision(t.getPrecisionModel()), void(this.arg[0] = new jsts.geomgraph.GeometryGraph(0, t));
					n = n || jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE, this.setComputationPrecision(t.getPrecisionModel().compareTo(e.getPrecisionModel()) >= 0 ? t.getPrecisionModel() : e.getPrecisionModel()), this.arg[0] = new jsts.geomgraph.GeometryGraph(0, t, n), this.arg[1] = new jsts.geomgraph.GeometryGraph(1, e, n)
				}
			}, jsts.operation.GeometryGraphOperation.prototype.li = null, jsts.operation.GeometryGraphOperation.prototype.resultPrecisionModel = null, jsts.operation.GeometryGraphOperation.prototype.arg = null, jsts.operation.GeometryGraphOperation.prototype.getArgGeometry = function(t) {
				return arg[t].getGeometry()
			}, jsts.operation.GeometryGraphOperation.prototype.setComputationPrecision = function(t) {
				this.resultPrecisionModel = t, this.li.setPrecisionModel(this.resultPrecisionModel)
			}, jsts.operation.overlay.OverlayNodeFactory = function() {}, jsts.operation.overlay.OverlayNodeFactory.prototype = new jsts.geomgraph.NodeFactory, jsts.operation.overlay.OverlayNodeFactory.constructor = jsts.operation.overlay.OverlayNodeFactory, jsts.operation.overlay.OverlayNodeFactory.prototype.createNode = function(t) {
				return new jsts.geomgraph.Node(t, new jsts.geomgraph.DirectedEdgeStar)
			}, jsts.operation.overlay.PolygonBuilder = function(t) {
				this.shellList = [], this.geometryFactory = t
			}, jsts.operation.overlay.PolygonBuilder.prototype.geometryFactory = null, jsts.operation.overlay.PolygonBuilder.prototype.shellList = null, jsts.operation.overlay.PolygonBuilder.prototype.add = function(t) {
				return 2 === arguments.length ? void this.add2.apply(this, arguments) : void this.add2(t.getEdgeEnds(), t.getNodes())
			}, jsts.operation.overlay.PolygonBuilder.prototype.add2 = function(t, e) {
				jsts.geomgraph.PlanarGraph.linkResultDirectedEdges(e);
				var n = this.buildMaximalEdgeRings(t),
					i = [],
					o = this.buildMinimalEdgeRings(n, this.shellList, i);
				this.sortShellsAndHoles(o, this.shellList, i), this.placeFreeHoles(this.shellList, i)
			}, jsts.operation.overlay.PolygonBuilder.prototype.getPolygons = function() {
				var t = this.computePolygons(this.shellList);
				return t
			}, jsts.operation.overlay.PolygonBuilder.prototype.buildMaximalEdgeRings = function(t) {
				for (var e = [], n = t.iterator(); n.hasNext();) {
					var i = n.next();
					if (i.isInResult() && i.getLabel().isArea() && null == i.getEdgeRing()) {
						var o = new jsts.operation.overlay.MaximalEdgeRing(i, this.geometryFactory);
						e.push(o), o.setInResult()
					}
				}
				return e
			}, jsts.operation.overlay.PolygonBuilder.prototype.buildMinimalEdgeRings = function(t, e, n) {
				for (var i = [], o = 0; o < t.length; o++) {
					var r = t[o];
					if (r.getMaxNodeDegree() > 2) {
						r.linkDirectedEdgesForMinimalEdgeRings();
						var s = r.buildMinimalRings(),
							a = this.findShell(s);
						null !== a ? (this.placePolygonHoles(a, s), e.push(a)) : n = n.concat(s)
					} else i.push(r)
				}
				return i
			}, jsts.operation.overlay.PolygonBuilder.prototype.findShell = function(t) {
				for (var e = 0, n = null, i = 0; i < t.length; i++) {
					var o = t[i];
					o.isHole() || (n = o, e++)
				}
				return jsts.util.Assert.isTrue(1 >= e, "found two shells in MinimalEdgeRing list"), n
			}, jsts.operation.overlay.PolygonBuilder.prototype.placePolygonHoles = function(t, e) {
				for (var n = 0; n < e.length; n++) {
					var i = e[n];
					i.isHole() && i.setShell(t)
				}
			}, jsts.operation.overlay.PolygonBuilder.prototype.sortShellsAndHoles = function(t, e, n) {
				for (var i = 0; i < t.length; i++) {
					var o = t[i];
					o.isHole() ? n.push(o) : e.push(o)
				}
			}, jsts.operation.overlay.PolygonBuilder.prototype.placeFreeHoles = function(t, e) {
				for (var n = 0; n < e.length; n++) {
					var i = e[n];
					if (null == i.getShell()) {
						var o = this.findEdgeRingContaining(i, t);
						if (null === o) throw new jsts.error.TopologyError("unable to assign hole to a shell", i.getCoordinate(0));
						i.setShell(o)
					}
				}
			}, jsts.operation.overlay.PolygonBuilder.prototype.findEdgeRingContaining = function(t, e) {
				for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), o = n.getCoordinateN(0), r = null, s = null, a = 0; a < e.length; a++) {
					var l = e[a],
						u = l.getLinearRing(),
						p = u.getEnvelopeInternal();
					null !== r && (s = r.getLinearRing().getEnvelopeInternal());
					var h = !1;
					p.contains(i) && jsts.algorithm.CGAlgorithms.isPointInRing(o, u.getCoordinates()) && (h = !0), h && (null == r || s.contains(p)) && (r = l)
				}
				return r
			}, jsts.operation.overlay.PolygonBuilder.prototype.computePolygons = function(t) {
				for (var e = new javascript.util.ArrayList, n = 0; n < t.length; n++) {
					var i = t[n],
						o = i.toPolygon(this.geometryFactory);
					e.add(o)
				}
				return e
			}, jsts.operation.overlay.PolygonBuilder.prototype.containsPoint = function(t) {
				for (var e = 0; e < this.shellList.length; e++) {
					var n = this.shellList[e];
					if (n.containsPoint(t)) return !0
				}
				return !1
			}, function() {
				var t = jsts.util.Assert,
					e = javascript.util.ArrayList,
					n = function(t, n, i) {
						this.lineEdgesList = new e, this.resultLineList = new e, this.op = t, this.geometryFactory = n, this.ptLocator = i
					};
				n.prototype.op = null, n.prototype.geometryFactory = null, n.prototype.ptLocator = null, n.prototype.lineEdgesList = null, n.prototype.resultLineList = null, n.prototype.build = function(t) {
					return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this.resultLineList
				}, n.prototype.findCoveredLineEdges = function() {
					for (var t = this.op.getGraph().getNodes().iterator(); t.hasNext();) {
						var e = t.next();
						e.getEdges().findCoveredLineEdges()
					}
					for (var n = this.op.getGraph().getEdgeEnds().iterator(); n.hasNext();) {
						var i = n.next(),
							o = i.getEdge();
						if (i.isLineEdge() && !o.isCoveredSet()) {
							var r = this.op.isCoveredByA(i.getCoordinate());
							o.setCovered(r)
						}
					}
				}, n.prototype.collectLines = function(t) {
					for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
						var n = e.next();
						this.collectLineEdge(n, t, this.lineEdgesList), this.collectBoundaryTouchEdge(n, t, this.lineEdgesList)
					}
				}, n.prototype.collectLineEdge = function(t, e, n) {
					var i = t.getLabel(),
						o = t.getEdge();
					t.isLineEdge() && (t.isVisited() || !jsts.operation.overlay.OverlayOp.isResultOfOp(i, e) || o.isCovered() || (n.add(o), t.setVisitedEdge(!0)))
				}, n.prototype.collectBoundaryTouchEdge = function(e, n, i) {
					var o = e.getLabel();
					e.isLineEdge() || e.isVisited() || e.isInteriorAreaEdge() || e.getEdge().isInResult() || (t.isTrue(!(e.isInResult() || e.getSym().isInResult()) || !e.getEdge().isInResult()), jsts.operation.overlay.OverlayOp.isResultOfOp(o, n) && n === jsts.operation.overlay.OverlayOp.INTERSECTION && (i.add(e.getEdge()), e.setVisitedEdge(!0)))
				}, n.prototype.buildLines = function() {
					for (var t = this.lineEdgesList.iterator(); t.hasNext();) {
						var e = t.next(),
							n = (e.getLabel(), this.geometryFactory.createLineString(e.getCoordinates()));
						this.resultLineList.add(n), e.setInResult(!0)
					}
				}, n.prototype.labelIsolatedLines = function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var n = e.next(),
							i = n.getLabel();
						n.isIsolated() && (i.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1))
					}
				}, n.prototype.labelIsolatedLine = function(t, e) {
					var n = ptLocator.locate(t.getCoordinate(), op.getArgGeometry(e));
					t.getLabel().setLocation(e, n)
				}, jsts.operation.overlay.LineBuilder = n
			}(), function() {
				var t = javascript.util.ArrayList,
					e = function(e, n) {
						this.resultPointList = new t, this.op = e, this.geometryFactory = n
					};
				e.prototype.op = null, e.prototype.geometryFactory = null, e.prototype.resultPointList = null, e.prototype.build = function(t) {
					return this.extractNonCoveredResultNodes(t), this.resultPointList
				}, e.prototype.extractNonCoveredResultNodes = function(t) {
					for (var e = this.op.getGraph().getNodes().iterator(); e.hasNext();) {
						var n = e.next();
						if (!(n.isInResult() || n.isIncidentEdgeInResult() || 0 !== n.getEdges().getDegree() && t !== jsts.operation.overlay.OverlayOp.INTERSECTION)) {
							var i = n.getLabel();
							jsts.operation.overlay.OverlayOp.isResultOfOp(i, t) && this.filterCoveredNodeToPoint(n)
						}
					}
				}, e.prototype.filterCoveredNodeToPoint = function(t) {
					var e = t.getCoordinate();
					if (!this.op.isCoveredByLA(e)) {
						var n = this.geometryFactory.createPoint(e);
						this.resultPointList.add(n)
					}
				}, jsts.operation.overlay.PointBuilder = e
			}(), function() {
				var t = jsts.algorithm.PointLocator,
					e = jsts.geom.Location,
					n = jsts.geomgraph.EdgeList,
					i = jsts.geomgraph.Label,
					o = jsts.geomgraph.PlanarGraph,
					r = jsts.geomgraph.Position,
					s = jsts.geomgraph.EdgeNodingValidator,
					a = jsts.operation.GeometryGraphOperation,
					l = jsts.operation.overlay.OverlayNodeFactory,
					u = jsts.operation.overlay.PolygonBuilder,
					p = jsts.operation.overlay.LineBuilder,
					h = jsts.operation.overlay.PointBuilder,
					c = jsts.util.Assert,
					g = javascript.util.ArrayList;
				jsts.operation.overlay.OverlayOp = function(e, i) {
					this.ptLocator = new t, this.edgeList = new n, this.resultPolyList = new g, this.resultLineList = new g, this.resultPointList = new g, a.call(this, e, i), this.graph = new o(new l), this.geomFact = e.getFactory()
				}, jsts.operation.overlay.OverlayOp.prototype = new a, jsts.operation.overlay.OverlayOp.constructor = jsts.operation.overlay.OverlayOp, jsts.operation.overlay.OverlayOp.INTERSECTION = 1, jsts.operation.overlay.OverlayOp.UNION = 2, jsts.operation.overlay.OverlayOp.DIFFERENCE = 3, jsts.operation.overlay.OverlayOp.SYMDIFFERENCE = 4, jsts.operation.overlay.OverlayOp.overlayOp = function(t, e, n) {
					var i = new jsts.operation.overlay.OverlayOp(t, e),
						o = i.getResultGeometry(n);
					return o
				}, jsts.operation.overlay.OverlayOp.isResultOfOp = function(t, e) {
					if (3 === arguments.length) return jsts.operation.overlay.OverlayOp.isResultOfOp2.apply(this, arguments);
					var n = t.getLocation(0),
						i = t.getLocation(1);
					return jsts.operation.overlay.OverlayOp.isResultOfOp2(n, i, e)
				}, jsts.operation.overlay.OverlayOp.isResultOfOp2 = function(t, n, i) {
					switch (t == e.BOUNDARY && (t = e.INTERIOR), n == e.BOUNDARY && (n = e.INTERIOR), i) {
					case jsts.operation.overlay.OverlayOp.INTERSECTION:
						return t == e.INTERIOR && n == e.INTERIOR;
					case jsts.operation.overlay.OverlayOp.UNION:
						return t == e.INTERIOR || n == e.INTERIOR;
					case jsts.operation.overlay.OverlayOp.DIFFERENCE:
						return t == e.INTERIOR && n != e.INTERIOR;
					case jsts.operation.overlay.OverlayOp.SYMDIFFERENCE:
						return t == e.INTERIOR && n != e.INTERIOR || t != e.INTERIOR && n == e.INTERIOR
					}
					return !1
				}, jsts.operation.overlay.OverlayOp.prototype.ptLocator = null, jsts.operation.overlay.OverlayOp.prototype.geomFact = null, jsts.operation.overlay.OverlayOp.prototype.resultGeom = null, jsts.operation.overlay.OverlayOp.prototype.graph = null, jsts.operation.overlay.OverlayOp.prototype.edgeList = null, jsts.operation.overlay.OverlayOp.prototype.resultPolyList = null, jsts.operation.overlay.OverlayOp.prototype.resultLineList = null, jsts.operation.overlay.OverlayOp.prototype.resultPointList = null, jsts.operation.overlay.OverlayOp.prototype.getResultGeometry = function(t) {
					return this.computeOverlay(t), this.resultGeom
				}, jsts.operation.overlay.OverlayOp.prototype.getGraph = function() {
					return this.graph
				}, jsts.operation.overlay.OverlayOp.prototype.computeOverlay = function(t) {
					this.copyPoints(0), this.copyPoints(1), this.arg[0].computeSelfNodes(this.li, !1), this.arg[1].computeSelfNodes(this.li, !1), this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !0);
					var e = new g;
					this.arg[0].computeSplitEdges(e), this.arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), s.checkValid(this.edgeList.getEdges()), this.graph.addEdges(this.edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges();
					var n = new u(this.geomFact);
					n.add(this.graph), this.resultPolyList = n.getPolygons();
					var i = new p(this, this.geomFact, this.ptLocator);
					this.resultLineList = i.build(t);
					var o = new h(this, this.geomFact, this.ptLocator);
					this.resultPointList = o.build(t), this.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, t)
				}, jsts.operation.overlay.OverlayOp.prototype.insertUniqueEdges = function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var n = e.next();
						this.insertUniqueEdge(n)
					}
				}, jsts.operation.overlay.OverlayOp.prototype.insertUniqueEdge = function(t) {
					var e = this.edgeList.findEqualEdge(t);
					if (null !== e) {
						var n = e.getLabel(),
							o = t.getLabel();
						e.isPointwiseEqual(t) || (o = new i(t.getLabel()), o.flip());
						var r = e.getDepth();
						r.isNull() && r.add(n), r.add(o), n.merge(o)
					} else this.edgeList.add(t)
				}, jsts.operation.overlay.OverlayOp.prototype.computeLabelsFromDepths = function() {
					for (var t = this.edgeList.iterator(); t.hasNext();) {
						var e = t.next(),
							n = e.getLabel(),
							i = e.getDepth();
						if (!i.isNull()) {
							i.normalize();
							for (var o = 0; 2 > o; o++) n.isNull(o) || !n.isArea() || i.isNull(o) || (0 == i.getDelta(o) ? n.toLine(o) : (c.isTrue(!i.isNull(o, r.LEFT), "depth of LEFT side has not been initialized"), n.setLocation(o, r.LEFT, i.getLocation(o, r.LEFT)), c.isTrue(!i.isNull(o, r.RIGHT), "depth of RIGHT side has not been initialized"), n.setLocation(o, r.RIGHT, i.getLocation(o, r.RIGHT))))
						}
					}
				}, jsts.operation.overlay.OverlayOp.prototype.replaceCollapsedEdges = function() {
					for (var t = new g, e = this.edgeList.iterator(); e.hasNext();) {
						var n = e.next();
						n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()))
					}
					this.edgeList.addAll(t)
				}, jsts.operation.overlay.OverlayOp.prototype.copyPoints = function(t) {
					for (var e = this.arg[t].getNodeIterator(); e.hasNext();) {
						var n = e.next(),
							i = this.graph.addNode(n.getCoordinate());
						i.setLabel(t, n.getLabel().getLocation(t))
					}
				}, jsts.operation.overlay.OverlayOp.prototype.computeLabelling = function() {
					for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
						var e = t.next();
						e.getEdges().computeLabelling(this.arg)
					}
					this.mergeSymLabels(), this.updateNodeLabelling()
				}, jsts.operation.overlay.OverlayOp.prototype.mergeSymLabels = function() {
					for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
						var e = t.next();
						e.getEdges().mergeSymLabels()
					}
				}, jsts.operation.overlay.OverlayOp.prototype.updateNodeLabelling = function() {
					for (var t = this.graph.getNodes().iterator(); t.hasNext();) {
						var e = t.next(),
							n = e.getEdges().getLabel();
						e.getLabel().merge(n)
					}
				}, jsts.operation.overlay.OverlayOp.prototype.labelIncompleteNodes = function() {
					for (var t = 0, e = this.graph.getNodes().iterator(); e.hasNext();) {
						var n = e.next(),
							i = n.getLabel();
						n.isIsolated() && (t++, i.isNull(0) ? this.labelIncompleteNode(n, 0) : this.labelIncompleteNode(n, 1)), n.getEdges().updateLabelling(i)
					}
				}, jsts.operation.overlay.OverlayOp.prototype.labelIncompleteNode = function(t, e) {
					var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());
					t.getLabel().setLocation(e, n)
				}, jsts.operation.overlay.OverlayOp.prototype.findResultAreaEdges = function(t) {
					for (var e = this.graph.getEdgeEnds().iterator(); e.hasNext();) {
						var n = e.next(),
							i = n.getLabel();
						i.isArea() && !n.isInteriorAreaEdge() && jsts.operation.overlay.OverlayOp.isResultOfOp(i.getLocation(0, r.RIGHT), i.getLocation(1, r.RIGHT), t) && n.setInResult(!0)
					}
				}, jsts.operation.overlay.OverlayOp.prototype.cancelDuplicateResultEdges = function() {
					for (var t = this.graph.getEdgeEnds().iterator(); t.hasNext();) {
						var e = t.next(),
							n = e.getSym();
						e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1))
					}
				}, jsts.operation.overlay.OverlayOp.prototype.isCoveredByLA = function(t) {
					return !!this.isCovered(t, this.resultLineList) || !! this.isCovered(t, this.resultPolyList)
				}, jsts.operation.overlay.OverlayOp.prototype.isCoveredByA = function(t) {
					return !!this.isCovered(t, this.resultPolyList)
				}, jsts.operation.overlay.OverlayOp.prototype.isCovered = function(t, n) {
					for (var i = n.iterator(); i.hasNext();) {
						var o = i.next(),
							r = this.ptLocator.locate(t, o);
						if (r != e.EXTERIOR) return !0
					}
					return !1
				}, jsts.operation.overlay.OverlayOp.prototype.computeGeometry = function(t, e, n) {
					var i = new g;
					return i.addAll(t), i.addAll(e), i.addAll(n), this.geomFact.buildGeometry(i)
				}, jsts.operation.overlay.OverlayOp.prototype.createEmptyResult = function(t) {
					var e = null;
					switch (resultDimension(t, this.arg[0].getGeometry(), this.arg[1].getGeometry())) {
					case -1:
						e = geomFact.createGeometryCollection();
						break;
					case 0:
						e = geomFact.createPoint(null);
						break;
					case 1:
						e = geomFact.createLineString(null);
						break;
					case 2:
						e = geomFact.createPolygon(null, null)
					}
					return e
				}, jsts.operation.overlay.OverlayOp.prototype.resultDimension = function(t, e, n) {
					var i = e.getDimension(),
						o = n.getDimension(),
						r = -1;
					switch (t) {
					case jsts.operation.overlay.OverlayOp.INTERSECTION:
						r = Math.min(i, o);
						break;
					case jsts.operation.overlay.OverlayOp.UNION:
						r = Math.max(i, o);
						break;
					case jsts.operation.overlay.OverlayOp.DIFFERENCE:
						r = i;
						break;
					case jsts.operation.overlay.OverlayOp.SYMDIFFERENCE:
						r = Math.max(i, o)
					}
					return r
				}
			}(), function() {
				var t = jsts.operation.overlay.OverlayOp,
					e = jsts.operation.overlay.snap.GeometrySnapper,
					n = function(t, e) {
						this.geom = [], this.geom[0] = t, this.geom[1] = e, this.computeSnapTolerance()
					};
				n.overlayOp = function(t, e, i) {
					var o = new n(t, e);
					return o.getResultGeometry(i)
				}, n.intersection = function(e, n) {
					return this.overlayOp(e, n, t.INTERSECTION)
				}, n.union = function(e, n) {
					return this.overlayOp(e, n, t.UNION)
				}, n.difference = function(e, n) {
					return overlayOp(e, n, t.DIFFERENCE)
				}, n.symDifference = function(e, n) {
					return overlayOp(e, n, t.SYMDIFFERENCE)
				}, n.prototype.geom = null, n.prototype.snapTolerance = null, n.prototype.computeSnapTolerance = function() {
					this.snapTolerance = e.computeOverlaySnapTolerance(this.geom[0], this.geom[1])
				}, n.prototype.getResultGeometry = function(e) {
					var n = this.snap(this.geom),
						i = t.overlayOp(n[0], n[1], e);
					return this.prepareResult(i)
				}, n.prototype.selfSnap = function(t) {
					var n = new e(t),
						i = n.snapTo(t, this.snapTolerance);
					return i
				}, n.prototype.snap = function(t) {
					var n = t,
						i = e.snap(n[0], n[1], this.snapTolerance);
					return i
				}, n.prototype.prepareResult = function(t) {
					return t
				}, n.prototype.cbr = null, n.prototype.removeCommonBits = function() {
					this.cbr = new jsts.precision.CommonBitsRemover, this.cbr.add(this.geom[0]), this.cbr.add(this.geom[1]);
					var t = [];
					return t[0] = cbr.removeCommonBits(this.geom[0].clone()), t[1] = cbr.removeCommonBits(this.geom[1].clone()), t
				}, jsts.operation.overlay.snap.SnapOverlayOp = n
			}(), jsts.geomgraph.index.EdgeSetIntersector = function() {}, jsts.geomgraph.index.EdgeSetIntersector.prototype.computeIntersections = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geomgraph.index.EdgeSetIntersector.prototype.computeIntersections2 = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geomgraph.index.SimpleMCSweepLineIntersector = function() {
				this.events = []
			}, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype = new jsts.geomgraph.index.EdgeSetIntersector, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.events = null, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.nOverlaps = 0, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.computeIntersections = function(t, e, n) {
				return e instanceof javascript.util.List ? void this.computeIntersections2.apply(this, arguments) : (n ? this.addList2(t, null) : this.addList(t), void this.computeIntersections3(e))
			}, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.computeIntersections2 = function(t, e, n) {
				this.addList2(t, t), this.addList2(e, e), this.computeIntersections3(n)
			}, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.add = function(t, e) {
				if (t instanceof javascript.util.List) return void this.addList.apply(this, arguments);
				for (var n = t.getMonotoneChainEdge(), i = n.getStartIndexes(), o = 0; o < i.length - 1; o++) {
					var r = new jsts.geomgraph.index.MonotoneChain(n, o),
						s = new jsts.geomgraph.index.SweepLineEvent(n.getMinX(o), r, e);
					this.events.push(s), this.events.push(new jsts.geomgraph.index.SweepLineEvent(n.getMaxX(o), s))
				}
			}, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.addList = function(t) {
				for (var e = t.iterator(); e.hasNext();) {
					var n = e.next();
					this.add(n, n)
				}
			}, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.addList2 = function(t, e) {
				for (var n = t.iterator(); n.hasNext();) {
					var i = n.next();
					this.add(i, e)
				}
			}, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.prepareEvents = function() {
				this.events.sort(function(t, e) {
					return t.compareTo(e)
				});
				for (var t = 0; t < this.events.length; t++) {
					var e = this.events[t];
					e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
				}
			}, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.computeIntersections3 = function(t) {
				this.nOverlaps = 0, this.prepareEvents();
				for (var e = 0; e < this.events.length; e++) {
					var n = this.events[e];
					n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t)
				}
			}, jsts.geomgraph.index.SimpleMCSweepLineIntersector.prototype.processOverlaps = function(t, e, n, i) {
				for (var o = n.getObject(), r = t; e > r; r++) {
					var s = this.events[r];
					if (s.isInsert()) {
						var a = s.getObject();
						n.isSameLabel(s) || (o.computeIntersections(a, i), this.nOverlaps++)
					}
				}
			}, jsts.algorithm.locate.SimplePointInAreaLocator = function(t) {
				this.geom = t
			}, jsts.algorithm.locate.SimplePointInAreaLocator.locate = function(t, e) {
				return e.isEmpty() ? jsts.geom.Location.EXTERIOR : jsts.algorithm.locate.SimplePointInAreaLocator.containsPoint(t, e) ? jsts.geom.Location.INTERIOR : jsts.geom.Location.EXTERIOR
			}, jsts.algorithm.locate.SimplePointInAreaLocator.containsPoint = function(t, e) {
				if (e instanceof jsts.geom.Polygon) return jsts.algorithm.locate.SimplePointInAreaLocator.containsPointInPolygon(t, e);
				if (e instanceof jsts.geom.GeometryCollection || e instanceof jsts.geom.MultiPoint || e instanceof jsts.geom.MultiLineString || e instanceof jsts.geom.MultiPolygon) for (var n = 0; n < e.geometries.length; n++) {
					var i = e.geometries[n];
					if (i !== e && jsts.algorithm.locate.SimplePointInAreaLocator.containsPoint(t, i)) return !0
				}
				return !1
			}, jsts.algorithm.locate.SimplePointInAreaLocator.containsPointInPolygon = function(t, e) {
				if (e.isEmpty()) return !1;
				var n = e.getExteriorRing();
				if (!jsts.algorithm.locate.SimplePointInAreaLocator.isPointInRing(t, n)) return !1;
				for (var i = 0; i < e.getNumInteriorRing(); i++) {
					var o = e.getInteriorRingN(i);
					if (jsts.algorithm.locate.SimplePointInAreaLocator.isPointInRing(t, o)) return !1
				}
				return !0
			}, jsts.algorithm.locate.SimplePointInAreaLocator.isPointInRing = function(t, e) {
				return !!e.getEnvelopeInternal().intersects(t) && jsts.algorithm.CGAlgorithms.isPointInRing(t, e.getCoordinates())
			}, jsts.algorithm.locate.SimplePointInAreaLocator.prototype.geom = null, jsts.algorithm.locate.SimplePointInAreaLocator.prototype.locate = function(t) {
				return jsts.algorithm.locate.SimplePointInAreaLocator.locate(t, geom)
			}, function() {
				var t = jsts.geom.Location,
					e = jsts.geomgraph.Position,
					n = jsts.geomgraph.EdgeEndStar,
					i = jsts.util.Assert;
				jsts.geomgraph.DirectedEdgeStar = function() {
					jsts.geomgraph.EdgeEndStar.call(this)
				}, jsts.geomgraph.DirectedEdgeStar.prototype = new n, jsts.geomgraph.DirectedEdgeStar.constructor = jsts.geomgraph.DirectedEdgeStar, jsts.geomgraph.DirectedEdgeStar.prototype.resultAreaEdgeList = null, jsts.geomgraph.DirectedEdgeStar.prototype.label = null, jsts.geomgraph.DirectedEdgeStar.prototype.insert = function(t) {
					var e = t;
					this.insertEdgeEnd(e, e)
				}, jsts.geomgraph.DirectedEdgeStar.prototype.getLabel = function() {
					return this.label
				}, jsts.geomgraph.DirectedEdgeStar.prototype.getOutgoingDegree = function() {
					for (var t = 0, e = this.iterator(); e.hasNext();) {
						var n = e.next();
						n.isInResult() && t++
					}
					return t
				}, jsts.geomgraph.DirectedEdgeStar.prototype.getOutgoingDegree = function(t) {
					for (var e = 0, n = this.iterator(); n.hasNext();) {
						var i = n.next();
						i.getEdgeRing() === t && e++
					}
					return e
				}, jsts.geomgraph.DirectedEdgeStar.prototype.getRightmostEdge = function() {
					var t = this.getEdges(),
						e = t.size();
					if (1 > e) return null;
					var n = t.get(0);
					if (1 == e) return n;
					var o = t.get(e - 1),
						r = n.getQuadrant(),
						s = o.getQuadrant();
					return jsts.geomgraph.Quadrant.isNorthern(r) && jsts.geomgraph.Quadrant.isNorthern(s) ? n : jsts.geomgraph.Quadrant.isNorthern(r) || jsts.geomgraph.Quadrant.isNorthern(s) ? 0 != n.getDy() ? n : 0 != o.getDy() ? o : (i.shouldNeverReachHere("found two horizontal edges incident on node"), null) : o
				}, jsts.geomgraph.DirectedEdgeStar.prototype.computeLabelling = function(e) {
					n.prototype.computeLabelling.call(this, e), this.label = new jsts.geomgraph.Label(t.NONE);
					for (var i = this.iterator(); i.hasNext();) for (var o = i.next(), r = o.getEdge(), s = r.getLabel(), a = 0; 2 > a; a++) {
						var l = s.getLocation(a);
						(l === t.INTERIOR || l === t.BOUNDARY) && this.label.setLocation(a, t.INTERIOR)
					}
				}, jsts.geomgraph.DirectedEdgeStar.prototype.mergeSymLabels = function() {
					for (var t = this.iterator(); t.hasNext();) {
						var e = t.next(),
							n = e.getLabel();
						n.merge(e.getSym().getLabel())
					}
				}, jsts.geomgraph.DirectedEdgeStar.prototype.updateLabelling = function(t) {
					for (var e = this.iterator(); e.hasNext();) {
						var n = e.next(),
							i = n.getLabel();
						i.setAllLocationsIfNull(0, t.getLocation(0)), i.setAllLocationsIfNull(1, t.getLocation(1))
					}
				}, jsts.geomgraph.DirectedEdgeStar.prototype.getResultAreaEdges = function() {
					if (null !== this.resultAreaEdgeList) return this.resultAreaEdgeList;
					this.resultAreaEdgeList = new javascript.util.ArrayList;
					for (var t = this.iterator(); t.hasNext();) {
						var e = t.next();
						(e.isInResult() || e.getSym().isInResult()) && this.resultAreaEdgeList.add(e)
					}
					return this.resultAreaEdgeList
				}, jsts.geomgraph.DirectedEdgeStar.prototype.SCANNING_FOR_INCOMING = 1, jsts.geomgraph.DirectedEdgeStar.prototype.LINKING_TO_OUTGOING = 2, jsts.geomgraph.DirectedEdgeStar.prototype.linkResultDirectedEdges = function() {
					this.getResultAreaEdges();
					for (var t = null, e = null, n = this.SCANNING_FOR_INCOMING, o = 0; o < this.resultAreaEdgeList.size(); o++) {
						var r = this.resultAreaEdgeList.get(o),
							s = r.getSym();
						if (r.getLabel().isArea()) switch (null === t && r.isInResult() && (t = r), n) {
						case this.SCANNING_FOR_INCOMING:
							if (!s.isInResult()) continue;
							e = s, n = this.LINKING_TO_OUTGOING;
							break;
						case this.LINKING_TO_OUTGOING:
							if (!r.isInResult()) continue;
							e.setNext(r), n = this.SCANNING_FOR_INCOMING
						}
					}
					if (n === this.LINKING_TO_OUTGOING) {
						if (null === t) throw new jsts.error.TopologyError("no outgoing dirEdge found", this.getCoordinate());
						i.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t)
					}
				}, jsts.geomgraph.DirectedEdgeStar.prototype.linkMinimalDirectedEdges = function(t) {
					for (var e = null, n = null, o = this.SCANNING_FOR_INCOMING, r = this.resultAreaEdgeList.size() - 1; r >= 0; r--) {
						var s = this.resultAreaEdgeList.get(r),
							a = s.getSym();
						switch (null === e && s.getEdgeRing() === t && (e = s), o) {
						case this.SCANNING_FOR_INCOMING:
							if (a.getEdgeRing() != t) continue;
							n = a, o = this.LINKING_TO_OUTGOING;
							break;
						case this.LINKING_TO_OUTGOING:
							if (s.getEdgeRing() !== t) continue;
							n.setNextMin(s), o = this.SCANNING_FOR_INCOMING
						}
					}
					o === this.LINKING_TO_OUTGOING && (i.isTrue(null !== e, "found null for first outgoing dirEdge"), i.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e))
				}, jsts.geomgraph.DirectedEdgeStar.prototype.linkAllDirectedEdges = function() {
					this.getEdges();
					for (var t = null, e = null, n = this.edgeList.size() - 1; n >= 0; n--) {
						var i = this.edgeList.get(n),
							o = i.getSym();
						null === e && (e = o), null !== t && o.setNext(t), t = i
					}
					e.setNext(t)
				}, jsts.geomgraph.DirectedEdgeStar.prototype.findCoveredLineEdges = function() {
					for (var e = t.NONE, n = this.iterator(); n.hasNext();) {
						var i = n.next(),
							o = i.getSym();
						if (!i.isLineEdge()) {
							if (i.isInResult()) {
								e = t.INTERIOR;
								break
							}
							if (o.isInResult()) {
								e = t.EXTERIOR;
								break
							}
						}
					}
					if (e !== t.NONE) for (var r = e, n = this.iterator(); n.hasNext();) {
						var i = n.next(),
							o = i.getSym();
						i.isLineEdge() ? i.getEdge().setCovered(r === t.INTERIOR) : (i.isInResult() && (r = t.EXTERIOR), o.isInResult() && (r = t.INTERIOR))
					}
				}, jsts.geomgraph.DirectedEdgeStar.prototype.computeDepths = function(t) {
					if (2 === arguments.length) return void this.computeDepths2.apply(this, arguments);
					var n = this.findIndex(t),
						i = (t.getLabel(), t.getDepth(e.LEFT)),
						o = t.getDepth(e.RIGHT),
						r = this.computeDepths2(n + 1, this.edgeList.size(), i),
						s = this.computeDepths2(0, n, r);
					if (s != o) throw new jsts.error.TopologyError("depth mismatch at " + t.getCoordinate())
				}, jsts.geomgraph.DirectedEdgeStar.prototype.computeDepths2 = function(t, n, i) {
					for (var o = i, r = t; n > r; r++) {
						var s = this.edgeList.get(r);
						s.getLabel(), s.setEdgeDepths(e.RIGHT, o), o = s.getDepth(e.LEFT)
					}
					return o
				}
			}(), jsts.algorithm.CentroidLine = function() {
				this.centSum = new jsts.geom.Coordinate
			}, jsts.algorithm.CentroidLine.prototype.centSum = null, jsts.algorithm.CentroidLine.prototype.totalLength = 0, jsts.algorithm.CentroidLine.prototype.add = function(t) {
				if (t instanceof Array) return void this.add2.apply(this, arguments);
				if (t instanceof jsts.geom.LineString) this.add(t.getCoordinates());
				else if (t instanceof jsts.geom.Polygon) {
					var e = t;
					this.add(e.getExteriorRing().getCoordinates());
					for (var n = 0; n < e.getNumInteriorRing(); n++) this.add(e.getInteriorRingN(n).getCoordinates())
				} else if (t instanceof jsts.geom.GeometryCollection || t instanceof jsts.geom.MultiPoint || t instanceof jsts.geom.MultiLineString || t instanceof jsts.geom.MultiPolygon) for (var i = t, n = 0; n < i.getNumGeometries(); n++) this.add(i.getGeometryN(n))
			}, jsts.algorithm.CentroidLine.prototype.getCentroid = function() {
				var t = new jsts.geom.Coordinate;
				return t.x = this.centSum.x / this.totalLength, t.y = this.centSum.y / this.totalLength, t
			}, jsts.algorithm.CentroidLine.prototype.add2 = function(t) {
				for (var e = 0; e < t.length - 1; e++) {
					var n = t[e].distance(t[e + 1]);
					this.totalLength += n;
					var i = (t[e].x + t[e + 1].x) / 2;
					this.centSum.x += n * i;
					var o = (t[e].y + t[e + 1].y) / 2;
					this.centSum.y += n * o
				}
			}, jsts.index.IntervalSize = function() {}, jsts.index.IntervalSize.MIN_BINARY_EXPONENT = -50, jsts.index.IntervalSize.isZeroWidth = function(t, e) {
				var n = e - t;
				if (0 === n) return !0;
				var i, o, r;
				return i = Math.max(Math.abs(t), Math.abs(e)), o = n / i, r = jsts.index.DoubleBits.exponent(o), r <= jsts.index.IntervalSize.MIN_BINARY_EXPONENT
			}, jsts.geomgraph.index.SimpleEdgeSetIntersector = function() {}, jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype = new jsts.geomgraph.index.EdgeSetIntersector, jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.nOverlaps = 0, jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.computeIntersections = function(t, e, n) {
				if (e instanceof javascript.util.List) return void this.computeIntersections2.apply(this, arguments);
				this.nOverlaps = 0;
				for (var i = t.iterator(); i.hasNext();) for (var o = i.next(), r = t.iterator(); r.hasNext();) {
					var s = r.next();
					(n || o != s) && this.computeIntersects(o, s, e)
				}
			}, jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.computeIntersections2 = function(t, e, n) {
				this.nOverlaps = 0;
				for (var i = t.iterator(); i.hasNext();) for (var o = i.next(), r = e.iterator(); r.hasNext();) {
					var s = r.next();
					this.computeIntersects(o, s, n)
				}
			}, jsts.geomgraph.index.SimpleEdgeSetIntersector.prototype.computeIntersects = function(t, e, n) {
				var i, o, r = t.getCoordinates(),
					s = e.getCoordinates();
				for (i = 0; i < r.length - 1; i++) for (o = 0; o < s.length - 1; o++) n.addIntersections(t, i, e, o)
			}, jsts.geomgraph.Edge = function(t, e) {
				this.pts = t, this.label = e, this.eiList = new jsts.geomgraph.EdgeIntersectionList(this), this.depth = new jsts.geomgraph.Depth
			}, jsts.geomgraph.Edge.prototype = new jsts.geomgraph.GraphComponent, jsts.geomgraph.Edge.constructor = jsts.geomgraph.Edge, jsts.geomgraph.Edge.updateIM = function(t, e) {
				e.setAtLeastIfValid(t.getLocation(0, jsts.geomgraph.Position.ON), t.getLocation(1, jsts.geomgraph.Position.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, jsts.geomgraph.Position.LEFT), t.getLocation(1, jsts.geomgraph.Position.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, jsts.geomgraph.Position.RIGHT), t.getLocation(1, jsts.geomgraph.Position.RIGHT), 2))
			}, jsts.geomgraph.Edge.prototype.pts = null, jsts.geomgraph.Edge.prototype.env = null, jsts.geomgraph.Edge.prototype.name = null, jsts.geomgraph.Edge.prototype.mce = null, jsts.geomgraph.Edge.prototype._isIsolated = !0, jsts.geomgraph.Edge.prototype.depth = null, jsts.geomgraph.Edge.prototype.depthDelta = 0, jsts.geomgraph.Edge.prototype.eiList = null, jsts.geomgraph.Edge.prototype.getNumPoints = function() {
				return this.pts.length
			}, jsts.geomgraph.Edge.prototype.getEnvelope = function() {
				if (null === this.env) {
					this.env = new jsts.geom.Envelope;
					for (var t = 0; t < this.pts.length; t++) this.env.expandToInclude(pts[t])
				}
				return env
			}, jsts.geomgraph.Edge.prototype.getDepth = function() {
				return this.depth
			}, jsts.geomgraph.Edge.prototype.getDepthDelta = function() {
				return this.depthDelta
			}, jsts.geomgraph.Edge.prototype.setDepthDelta = function(t) {
				this.depthDelta = t
			}, jsts.geomgraph.Edge.prototype.getCoordinates = function() {
				return this.pts
			}, jsts.geomgraph.Edge.prototype.getCoordinate = function(t) {
				return void 0 === t ? this.pts.length > 0 ? this.pts[0] : null : this.pts[t]
			}, jsts.geomgraph.Edge.prototype.isClosed = function() {
				return this.pts[0].equals(this.pts[this.pts.length - 1])
			}, jsts.geomgraph.Edge.prototype.setIsolated = function(t) {
				this._isIsolated = t
			}, jsts.geomgraph.Edge.prototype.isIsolated = function() {
				return this._isIsolated
			}, jsts.geomgraph.Edge.prototype.addIntersections = function(t, e, n) {
				for (var i = 0; i < t.getIntersectionNum(); i++) this.addIntersection(t, e, n, i)
			}, jsts.geomgraph.Edge.prototype.addIntersection = function(t, e, n, i) {
				var o = new jsts.geom.Coordinate(t.getIntersection(i)),
					r = e,
					s = t.getEdgeDistance(n, i),
					a = r + 1;
				if (a < this.pts.length) {
					var l = this.pts[a];
					o.equals2D(l) && (r = a, s = 0)
				}
				this.eiList.add(o, r, s)
			}, jsts.geomgraph.Edge.prototype.getMaximumSegmentIndex = function() {
				return this.pts.length - 1
			}, jsts.geomgraph.Edge.prototype.getEdgeIntersectionList = function() {
				return this.eiList
			}, jsts.geomgraph.Edge.prototype.getMonotoneChainEdge = function() {
				return null == this.mce && (this.mce = new jsts.geomgraph.index.MonotoneChainEdge(this)), this.mce
			}, jsts.geomgraph.Edge.prototype.isClosed = function() {
				return this.pts[0].equals(this.pts[this.pts.length - 1])
			}, jsts.geomgraph.Edge.prototype.isCollapsed = function() {
				return !!this.label.isArea() && (3 == this.pts.length && !! this.pts[0].equals(this.pts[2]))
			}, jsts.geomgraph.Edge.prototype.getCollapsedEdge = function() {
				var t = [];
				t[0] = this.pts[0], t[1] = this.pts[1];
				var e = new jsts.geomgraph.Edge(t, jsts.geomgraph.Label.toLineLabel(this.label));
				return e
			}, jsts.geomgraph.Edge.prototype.computeIM = function(t) {
				jsts.geomgraph.Edge.updateIM(this.label, t)
			}, jsts.geomgraph.Edge.prototype.isPointwiseEqual = function(t) {
				if (this.pts.length != t.pts.length) return !1;
				for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;
				return !0
			}, jsts.noding.Octant = function() {
				throw jsts.error.AbstractMethodInvocationError()
			}, jsts.noding.Octant.octant = function(t, e) {
				if (t instanceof jsts.geom.Coordinate) return jsts.noding.Octant.octant2.apply(this, arguments);
				if (0 === t && 0 === e) throw new jsts.error.IllegalArgumentError("Cannot compute the octant for point ( " + t + ", " + e + " )");
				var n = Math.abs(t),
					i = Math.abs(e);
				return t >= 0 ? e >= 0 ? n >= i ? 0 : 1 : n >= i ? 7 : 6 : e >= 0 ? n >= i ? 3 : 2 : n >= i ? 4 : 5
			}, jsts.noding.Octant.octant2 = function(t, e) {
				var n = e.x - t.x,
					i = e.y - t.y;
				if (0 === n && 0 === i) throw new jsts.error.IllegalArgumentError("Cannot compute the octant for two identical points " + t);
				return jsts.noding.Octant.octant(n, i)
			}, jsts.operation.union.UnionInteracting = function(t, e) {
				this.g0 = t, this.g1 = e, this.geomFactory = t.getFactory(), this.interacts0 = [], this.interacts1 = []
			}, jsts.operation.union.UnionInteracting.union = function(t, e) {
				var n = new jsts.operation.union.UnionInteracting(t, e);
				return n.union()
			}, jsts.operation.union.UnionInteracting.prototype.geomFactory = null, jsts.operation.union.UnionInteracting.prototype.g0 = null, jsts.operation.union.UnionInteracting.prototype.g1 = null, jsts.operation.union.UnionInteracting.prototype.interacts0 = null, jsts.operation.union.UnionInteracting.prototype.interacts1 = null, jsts.operation.union.UnionInteracting.prototype.union = function() {
				this.computeInteracting();
				var t = this.extractElements(this.g0, this.interacts0, !0),
					e = this.extractElements(this.g1, this.interacts1, !0);
				t.isEmpty() || e.isEmpty();
				var n = in0.union(e),
					i = this.extractElements(this.g0, this.interacts0, !1),
					o = this.extractElements(this.g1, this.interacts1, !1),
					r = jsts.geom.util.GeometryCombiner.combine(n, i, o);
				return r
			}, jsts.operation.union.UnionInteracting.prototype.bufferUnion = function(t, e) {
				var n = t.getFactory(),
					i = n.createGeometryCollection([t, e]),
					o = i.buffer(0);
				return o
			}, jsts.operation.union.UnionInteracting.prototype.computeInteracting = function(t) {
				if (t) {
					for (var e = !1, n = 0, i = g1.getNumGeometries(); i > n; n++) {
						var o = this.g1.getGeometryN(n),
							r = o.getEnvelopeInternal().intersects(t.getEnvelopeInternal());
						r && (this.interacts1[n] = !0, e = !0)
					}
					return e
				}
				for (var n = 0, i = this.g0.getNumGeometries(); i > n; n++) {
					var s = this.g0.getGeometryN(n);
					this.interacts0[n] = this.computeInteracting(s)
				}
			}, jsts.operation.union.UnionInteracting.prototype.extractElements = function(t, e, n) {
				for (var i = [], o = 0, r = t.getNumGeometries(); r > o; o++) {
					var s = t.getGeometryN(o);
					e[o] === n && i.push(s)
				}
				return this.geomFactory.buildGeometry(i)
			}, jsts.triangulate.quadedge.TrianglePredicate = function() {}, jsts.triangulate.quadedge.TrianglePredicate.isInCircleNonRobust = function(t, e, n, i) {
				var o = (t.x * t.x + t.y * t.y) * jsts.triangulate.quadedge.TrianglePredicate.triArea(e, n, i) - (e.x * e.x + e.y * e.y) * jsts.triangulate.quadedge.TrianglePredicate.triArea(t, n, i) + (n.x * n.x + n.y * n.y) * jsts.triangulate.quadedge.TrianglePredicate.triArea(t, e, i) - (i.x * i.x + i.y * i.y) * jsts.triangulate.quadedge.TrianglePredicate.triArea(t, e, n) > 0;
				return o
			}, jsts.triangulate.quadedge.TrianglePredicate.isInCircleNormalized = function(t, e, n, i) {
				var o, r, s, a, l, u, p, h, c, g, d, f, m;
				return o = t.x - i.x, r = t.y - i.y, s = e.x - i.x, a = e.y - i.y, l = n.x - i.x, u = n.y - i.y, p = o * a - s * r, h = s * u - l * a, c = l * r - o * u, g = o * o + r * r, d = s * s + a * a, f = l * l + u * u, m = g * h + d * c + f * p, m > 0
			}, jsts.triangulate.quadedge.TrianglePredicate.triArea = function(t, e, n) {
				return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x)
			}, jsts.triangulate.quadedge.TrianglePredicate.isInCircleRobust = function(t, e, n, i) {
				return jsts.triangulate.quadedge.TrianglePredicate.isInCircleNormalized(t, e, n, i)
			}, jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDSlow = function(t, e, n, i) {
				var o, r, s, a, l, u, p, h, c, g, d, f, m, y;
				return o = jsts.math.DD.valueOf(i.x), r = jsts.math.DD.valueOf(i.y), s = jsts.math.DD.valueOf(t.x), a = jsts.math.DD.valueOf(t.y), l = jsts.math.DD.valueOf(e.x), u = jsts.math.DD.valueOf(e.y), p = jsts.math.DD.valueOf(n.x), h = jsts.math.DD.valueOf(n.y), c = s.multiply(s).add(a.multiply(a)).multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(l, u, p, h, o, r)), g = l.multiply(l).add(u.multiply(u)).multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(s, a, p, h, o, r)), d = p.multiply(p).add(h.multiply(h)).multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(s, a, l, u, o, r)), f = o.multiply(o).add(r.multiply(r)).multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(s, a, l, u, p, h)), m = c.subtract(g).add(d).subtract(f), y = m.doubleValue() > 0
			}, jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow = function(t, e, n, i, o, r) {
				return n.subtract(t).multiply(r.subtract(e)).subtract(i.subtract(e).multiply(o.subtract(t)))
			}, jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDFast = function(t, e, n, i) {
				var o, r, s, a, l, u;
				return o = jsts.math.DD.sqr(t.x).selfAdd(jsts.math.DD.sqr(t.y)).selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(e, n, i)), r = jsts.math.DD.sqr(e.x).selfAdd(jsts.math.DD.sqr(e.y)).selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(t, n, i)), s = jsts.math.DD.sqr(n.x).selfAdd(jsts.math.DD.sqr(n.y)).selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(t, e, i)), a = jsts.math.DD.sqr(i.x).selfAdd(jsts.math.DD.sqr(i.y)).selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(t, e, n)), l = o.selfSubtract(r).selfAdd(s).selfSubtract(a), u = l.doubleValue() > 0
			}, jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast = function(t, e, n) {
				var i, o;
				return i = jsts.math.DD.valueOf(e.x).selfSubtract(t.x).selfMultiply(jsts.math.DD.valueOf(n.y).selfSubtract(t.y)), o = jsts.math.DD.valueOf(e.y).selSubtract(t.y).selfMultiply(jsts.math.DD.valueOf(n.x).selfSubtract(t.x)), i.selfSubtract(o)
			}, jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDNormalized = function(t, e, n, i) {
				var o, r, s, a, l, u, p, h, c, g, d, f, m, y;
				return o = jsts.math.DD.valueOf(t.x).selfSubtract(i.x), r = jsts.math.DD.valueOf(t.y).selfSubtract(i.y), s = jsts.math.DD.valueOf(e.x).selfSubtract(i.x), s = jsts.math.DD.valueOf(e.y).selfSubtract(i.y), l = jsts.math.DD.valueOf(n.x).selfSubtract(i.x), l = jsts.math.DD.valueOf(n.y).selfSubtract(i.y), p = o.multiply(a).selfSubtract(s.multiply(r)), h = s.multiply(u).selfSubtract(l.multiply(a)), c = l.multiply(r).selfSubtract(o.multiply(u)), g = o.multiply(o).selfAdd(r.multiply(r)), d = s.multiply(s).selfAdd(a.multiply(a)), f = l.multiply(l).selfAdd(u.multiply(u)), m = g.selfMultiply(h).selfAdd(d.selfMultiply(c)).selfAdd(f.selfMultiply(p)), y = m.doubleValue() > 0
			}, jsts.triangulate.quadedge.TrianglePredicate.isInCircleCC = function(t, e, n, i) {
				var o, r, s;
				return o = jsts.geom.Triangle.circumcentre(t, e, n), r = t.distance(o), s = i.distance(o) - r, 0 >= s
			}, jsts.operation.union.PointGeometryUnion = function(t, e) {
				this.pointGeom = t, this.otherGeom = e, this.geomFact = e.getFactory()
			}, jsts.operation.union.PointGeometryUnion.union = function(t, e) {
				var n = new jsts.operation.union.PointGeometryUnion(t, e);
				return n.union()
			}, jsts.operation.union.PointGeometryUnion.prototype.pointGeom = null, jsts.operation.union.PointGeometryUnion.prototype.otherGeom = null, jsts.operation.union.PointGeometryUnion.prototype.geomFact = null, jsts.operation.union.PointGeometryUnion.prototype.union = function() {
				for (var t = new jsts.algorithm.PointLocator, e = [], n = 0, i = this.pointGeom.getNumGeometries(); i > n; n++) {
					var o = this.pointGeom.getGeometryN(n),
						r = o.getCoordinate(),
						s = t.locate(r, this.otherGeom);
					if (s === jsts.geom.Location.EXTERIOR) {
						for (var a = !0, l = e.length; n--;) if (e[l].equals(r)) {
							a = !1;
							break
						}
						a && e.push(r)
					}
				}
				if (e.sort(function(t, e) {
					return t.compareTo(e)
				}), 0 === e.length) return this.otherGeom;
				var u = null,
					p = jsts.geom.CoordinateArrays.toCoordinateArray(e);
				return u = 1 === p.length ? this.geomFact.createPoint(p[0]) : this.geomFact.createMultiPoint(p), jsts.geom.util.GeometryCombiner.combine(u, this.otherGeom)
			}, jsts.noding.IntersectionFinderAdder = function(t) {
				this.li = t, this.interiorIntersections = new javascript.util.ArrayList
			}, jsts.noding.IntersectionFinderAdder.prototype = new jsts.noding.SegmentIntersector, jsts.noding.IntersectionFinderAdder.constructor = jsts.noding.IntersectionFinderAdder, jsts.noding.IntersectionFinderAdder.prototype.li = null, jsts.noding.IntersectionFinderAdder.prototype.interiorIntersections = null, jsts.noding.IntersectionFinderAdder.prototype.getInteriorIntersections = function() {
				return this.interiorIntersections
			}, jsts.noding.IntersectionFinderAdder.prototype.processIntersections = function(t, e, n, i) {
				if (t !== n || e !== i) {
					var o = t.getCoordinates()[e],
						r = t.getCoordinates()[e + 1],
						s = n.getCoordinates()[i],
						a = n.getCoordinates()[i + 1];
					if (this.li.computeIntersection(o, r, s, a), this.li.hasIntersection() && this.li.isInteriorIntersection()) {
						for (var l = 0; l < this.li.getIntersectionNum(); l++) this.interiorIntersections.add(this.li.getIntersection(l));
						t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1)
					}
				}
			}, jsts.noding.IntersectionFinderAdder.prototype.isDone = function() {
				return !1
			}, jsts.noding.snapround.MCIndexSnapRounder = function(t) {
				this.pm = t, this.li = new jsts.algorithm.RobustLineIntersector, this.li.setPrecisionModel(t), this.scaleFactor = t.getScale()
			}, jsts.noding.snapround.MCIndexSnapRounder.prototype = new jsts.noding.Noder, jsts.noding.snapround.MCIndexSnapRounder.constructor = jsts.noding.snapround.MCIndexSnapRounder, jsts.noding.snapround.MCIndexSnapRounder.prototype.pm = null, jsts.noding.snapround.MCIndexSnapRounder.prototype.li = null, jsts.noding.snapround.MCIndexSnapRounder.prototype.scaleFactor = null, jsts.noding.snapround.MCIndexSnapRounder.prototype.noder = null, jsts.noding.snapround.MCIndexSnapRounder.prototype.pointSnapper = null, jsts.noding.snapround.MCIndexSnapRounder.prototype.nodedSegStrings = null, jsts.noding.snapround.MCIndexSnapRounder.prototype.getNodedSubstrings = function() {
				return jsts.noding.NodedSegmentString.getNodedSubstrings(this.nodedSegStrings)
			}, jsts.noding.snapround.MCIndexSnapRounder.prototype.computeNodes = function(t) {
				this.nodedSegStrings = t, this.noder = new jsts.noding.MCIndexNoder, this.pointSnapper = new jsts.noding.snapround.MCIndexPointSnapper(this.noder.getIndex()), this.snapRound(t, this.li)
			}, jsts.noding.snapround.MCIndexSnapRounder.prototype.snapRound = function(t, e) {
				var n = this.findInteriorIntersections(t, e);
				this.computeIntersectionSnaps(n), this.computeVertexSnaps(t)
			}, jsts.noding.snapround.MCIndexSnapRounder.prototype.findInteriorIntersections = function(t, e) {
				var n = new jsts.noding.IntersectionFinderAdder(e);
				return this.noder.setSegmentIntersector(n), this.noder.computeNodes(t), n.getInteriorIntersections()
			}, jsts.noding.snapround.MCIndexSnapRounder.prototype.computeIntersectionSnaps = function(t) {
				for (var e = t.iterator(); e.hasNext();) {
					var n = e.next(),
						i = new jsts.noding.snapround.HotPixel(n, this.scaleFactor, this.li);
					this.pointSnapper.snap(i)
				}
			}, jsts.noding.snapround.MCIndexSnapRounder.prototype.computeVertexSnaps = function(t) {
				if (t instanceof jsts.noding.NodedSegmentString) return void this.computeVertexSnaps2.apply(this, arguments);
				for (var e = t.iterator(); e.hasNext();) {
					var n = e.next();
					this.computeVertexSnaps(n)
				}
			}, jsts.noding.snapround.MCIndexSnapRounder.prototype.computeVertexSnaps2 = function(t) {
				for (var e = t.getCoordinates(), n = 0; n < e.length - 1; n++) {
					var i = new jsts.noding.snapround.HotPixel(e[n], this.scaleFactor, this.li),
						o = this.pointSnapper.snap(i, t, n);
					o && t.addIntersection(e[n], n)
				}
			}, jsts.operation.valid.ConnectedInteriorTester = function(t) {
				this.geomGraph = t, this.geometryFactory = new jsts.geom.GeometryFactory, this.disconnectedRingcoord = null
			}, jsts.operation.valid.ConnectedInteriorTester.findDifferentPoint = function(t, e) {
				var n = 0,
					i = t.length;
				for (n; i > n; n++) if (!t[n].equals(e)) return t[n];
				return null
			}, jsts.operation.valid.ConnectedInteriorTester.prototype.getCoordinate = function() {
				return this.disconnectedRingcoord
			}, jsts.operation.valid.ConnectedInteriorTester.prototype.isInteriorsConnected = function() {
				var t = new javascript.util.ArrayList;
				this.geomGraph.computeSplitEdges(t);
				var e = new jsts.geomgraph.PlanarGraph(new jsts.operation.overlay.OverlayNodeFactory);
				e.addEdges(t), this.setInteriorEdgesInResult(e), e.linkResultDirectedEdges();
				var n = this.buildEdgeRings(e.getEdgeEnds());
				return this.visitShellInteriors(this.geomGraph.getGeometry(), e), !this.hasUnvisitedShellEdge(n)
			}, jsts.operation.valid.ConnectedInteriorTester.prototype.setInteriorEdgesInResult = function(t) {
				for (var e, n = t.getEdgeEnds().iterator(); n.hasNext();) e = n.next(), e.getLabel().getLocation(0, jsts.geomgraph.Position.RIGHT) == jsts.geom.Location.INTERIOR && e.setInResult(!0)
			}, jsts.operation.valid.ConnectedInteriorTester.prototype.buildEdgeRings = function(t) {
				for (var e = new javascript.util.ArrayList, n = t.iterator(); n.hasNext();) {
					var i = n.next();
					if (i.isInResult() && null == i.getEdgeRing()) {
						var o = new jsts.operation.overlay.MaximalEdgeRing(i, this.geometryFactory);
						o.linkDirectedEdgesForMinimalEdgeRings();
						var r = o.buildMinimalRings(),
							s = 0,
							a = r.length;
						for (s; a > s; s++) e.add(r[s])
					}
				}
				return e
			}, jsts.operation.valid.ConnectedInteriorTester.prototype.visitShellInteriors = function(t, e) {
				if (t instanceof jsts.geom.Polygon) {
					var n = t;
					this.visitInteriorRing(n.getExteriorRing(), e)
				}
				if (t instanceof jsts.geom.MultiPolygon) for (var i = t, o = 0; o < i.getNumGeometries(); o++) {
					var n = i.getGeometryN(o);
					this.visitInteriorRing(n.getExteriorRing(), e)
				}
			}, jsts.operation.valid.ConnectedInteriorTester.prototype.visitInteriorRing = function(t, e) {
				var n = t.getCoordinates(),
					i = n[0],
					o = jsts.operation.valid.ConnectedInteriorTester.findDifferentPoint(n, i),
					r = e.findEdgeInSameDirection(i, o),
					s = e.findEdgeEnd(r),
					a = null;
				s.getLabel().getLocation(0, jsts.geomgraph.Position.RIGHT) == jsts.geom.Location.INTERIOR ? a = s : s.getSym().getLabel().getLocation(0, jsts.geomgraph.Position.RIGHT) == jsts.geom.Location.INTERIOR && (a = s.getSym()), this.visitLinkedDirectedEdges(a)
			}, jsts.operation.valid.ConnectedInteriorTester.prototype.visitLinkedDirectedEdges = function(t) {
				var e = t,
					n = t;
				do n.setVisited(!0), n = n.getNext();
				while (n != e)
			}, jsts.operation.valid.ConnectedInteriorTester.prototype.hasUnvisitedShellEdge = function(t) {
				for (var e = 0; e < t.size(); e++) {
					var n = t.get(e);
					if (!n.isHole()) {
						var i = n.getEdges(),
							o = i[0];
						if (o.getLabel().getLocation(0, jsts.geomgraph.Position.RIGHT) == jsts.geom.Location.INTERIOR) for (var r = 0; r < i.length; r++) if (o = i[r], !o.isVisited()) return disconnectedRingcoord = o.getCoordinate(), !0
					}
				}
				return !1
			}, jsts.algorithm.InteriorPointLine = function(t) {
				this.centroid, this.minDistance = Number.MAX_VALUE, this.interiorPoint = null, this.centroid = t.getCentroid().getCoordinate(), this.addInterior(t), null == this.interiorPoint && this.addEndpoints(t)
			}, jsts.algorithm.InteriorPointLine.prototype.getInteriorPoint = function() {
				return this.interiorPoint
			}, jsts.algorithm.InteriorPointLine.prototype.addInterior = function(t) {
				if (t instanceof jsts.geom.LineString) this.addInteriorCoord(t.getCoordinates());
				else if (t instanceof jsts.geom.GeometryCollection) for (var e = 0; e < t.getNumGeometries(); e++) this.addInterior(t.getGeometryN(e))
			}, jsts.algorithm.InteriorPointLine.prototype.addInteriorCoord = function(t) {
				for (var e = 1; e < t.length - 1; e++) this.add(t[e])
			}, jsts.algorithm.InteriorPointLine.prototype.addEndpoints = function(t) {
				if (t instanceof jsts.geom.LineString) this.addEndpointsCoord(t.getCoordinates());
				else if (t instanceof jsts.geom.GeometryCollection) for (var e = 0; e < t.getNumGeometries(); e++) this.addEndpoints(t.getGeometryN(e))
			}, jsts.algorithm.InteriorPointLine.prototype.addEndpointsCoord = function(t) {
				this.add(t[0]), this.add(t[t.length - 1])
			}, jsts.algorithm.InteriorPointLine.prototype.add = function(t) {
				var e = t.distance(this.centroid);
				e < this.minDistance && (this.interiorPoint = new jsts.geom.Coordinate(t), this.minDistance = e)
			}, jsts.index.chain.MonotoneChainSelectAction = function() {
				this.tempEnv1 = new jsts.geom.Envelope, this.selectedSegment = new jsts.geom.LineSegment
			}, jsts.index.chain.MonotoneChainSelectAction.prototype.tempEnv1 = null, jsts.index.chain.MonotoneChainSelectAction.prototype.selectedSegment = null, jsts.index.chain.MonotoneChainSelectAction.prototype.select = function(t, e) {
				t.getLineSegment(e, this.selectedSegment), this.select2(this.selectedSegment)
			}, jsts.index.chain.MonotoneChainSelectAction.prototype.select2 = function() {}, jsts.algorithm.MCPointInRing = function(t) {
				this.ring = t, this.tree = null, this.crossings = 0, this.interval = new jsts.index.bintree.Interval, this.buildIndex()
			}, jsts.algorithm.MCPointInRing.MCSelecter = function(t, e) {
				this.parent = e, this.p = t
			}, jsts.algorithm.MCPointInRing.MCSelecter.prototype = new jsts.index.chain.MonotoneChainSelectAction, jsts.algorithm.MCPointInRing.MCSelecter.prototype.constructor = jsts.algorithm.MCPointInRing.MCSelecter, jsts.algorithm.MCPointInRing.MCSelecter.prototype.select2 = function(t) {
				this.parent.testLineSegment.apply(this.parent, [this.p, t])
			}, jsts.algorithm.MCPointInRing.prototype.buildIndex = function() {
				this.tree = new jsts.index.bintree.Bintree;
				for (var t = jsts.geom.CoordinateArrays.removeRepeatedPoints(this.ring.getCoordinates()), e = jsts.index.chain.MonotoneChainBuilder.getChains(t), n = 0; n < e.length; n++) {
					var i = e[n],
						o = i.getEnvelope();
					this.interval.min = o.getMinY(), this.interval.max = o.getMaxY(), this.tree.insert(this.interval, i)
				}
			}, jsts.algorithm.MCPointInRing.prototype.isInside = function(t) {
				this.crossings = 0;
				var e = new jsts.geom.Envelope((-Number.MAX_VALUE), Number.MAX_VALUE, t.y, t.y);
				this.interval.min = t.y, this.interval.max = t.y;
				for (var n = this.tree.query(this.interval), i = new jsts.algorithm.MCPointInRing.MCSelecter(t, this), o = n.iterator(); o.hasNext();) {
					var r = o.next();
					this.testMonotoneChain(e, i, r)
				}
				return this.crossings % 2 == 1
			}, jsts.algorithm.MCPointInRing.prototype.testMonotoneChain = function(t, e, n) {
				n.select(t, e)
			}, jsts.algorithm.MCPointInRing.prototype.testLineSegment = function(t, e) {
				var n, i, o, r, s, a, l;
				a = e.p0, l = e.p1, i = a.x - t.x, o = a.y - t.y, r = l.x - t.x, s = l.y - t.y, (o > 0 && 0 >= s || s > 0 && 0 >= o) && (n = jsts.algorithm.RobustDeterminant.signOfDet2x2(i, o, r, s) / (s - o), n > 0 && this.crossings++)
			}, jsts.operation.valid.TopologyValidationError = function(t, e) {
				this.errorType = t, this.pt = null, null != e && (this.pt = e.clone())
			}, jsts.operation.valid.TopologyValidationError.HOLE_OUTSIDE_SHELL = 2, jsts.operation.valid.TopologyValidationError.NESTED_HOLES = 3, jsts.operation.valid.TopologyValidationError.DISCONNECTED_INTERIOR = 4, jsts.operation.valid.TopologyValidationError.SELF_INTERSECTION = 5, jsts.operation.valid.TopologyValidationError.RING_SELF_INTERSECTION = 6, jsts.operation.valid.TopologyValidationError.NESTED_SHELLS = 7, jsts.operation.valid.TopologyValidationError.DUPLICATE_RINGS = 8, jsts.operation.valid.TopologyValidationError.TOO_FEW_POINTS = 9, jsts.operation.valid.TopologyValidationError.INVALID_COORDINATE = 10, jsts.operation.valid.TopologyValidationError.RING_NOT_CLOSED = 11, jsts.operation.valid.TopologyValidationError.prototype.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"], jsts.operation.valid.TopologyValidationError.prototype.getCoordinate = function() {
				return this.pt
			}, jsts.operation.valid.TopologyValidationError.prototype.getErrorType = function() {
				return this.errorType
			}, jsts.operation.valid.TopologyValidationError.prototype.getMessage = function() {
				return this.errMsg[this.errorType]
			}, jsts.operation.valid.TopologyValidationError.prototype.toString = function() {
				var t = "";
				return null != this.pt ? (t = " at or near point " + this.pt, this.getMessage() + t) : t
			}, function() {
				jsts.geom.MultiPolygon = function(t, e) {
					this.geometries = t || [], this.factory = e
				}, jsts.geom.MultiPolygon.prototype = new jsts.geom.GeometryCollection, jsts.geom.MultiPolygon.constructor = jsts.geom.MultiPolygon, jsts.geom.MultiPolygon.prototype.getBoundary = function() {
					if (this.isEmpty()) return this.getFactory().createMultiLineString(null);
					for (var t = [], e = 0; e < this.geometries.length; e++) for (var n = this.geometries[e], i = n.getBoundary(), o = 0; o < i.getNumGeometries(); o++) t.push(i.getGeometryN(o));
					return this.getFactory().createMultiLineString(t)
				}, jsts.geom.MultiPolygon.prototype.equalsExact = function(t, e) {
					return !!this.isEquivalentClass(t) && jsts.geom.GeometryCollection.prototype.equalsExact.call(this, t, e)
				}, jsts.geom.MultiPolygon.prototype.CLASS_NAME = "jsts.geom.MultiPolygon"
			}(), jsts.geom.CoordinateSequenceFilter = function() {}, jsts.geom.CoordinateSequenceFilter.prototype.filter = jsts.abstractFunc, jsts.geom.CoordinateSequenceFilter.prototype.isDone = jsts.abstractFunc, jsts.geom.CoordinateSequenceFilter.prototype.isGeometryChanged = jsts.abstractFunc, function() {
				var t = function() {
						if (this.min = 0, this.max = 0, 1 === arguments.length) {
							var t = arguments[0];
							this.init(t.min, t.max)
						} else 2 === arguments.length && this.init(arguments[0], arguments[1])
					};
				t.prototype.init = function(t, e) {
					this.min = t, this.max = e, t > e && (this.min = e, this.max = t)
				}, t.prototype.getMin = function() {
					return this.min
				}, t.prototype.getMax = function() {
					return this.max
				}, t.prototype.getWidth = function() {
					return this.max - this.min
				}, t.prototype.expandToInclude = function(t) {
					t.max > this.max && (this.max = t.max), t.min < this.min && (this.min = t.min)
				}, t.prototype.overlaps = function() {
					return 1 === arguments.length ? this.overlapsInterval.apply(this, arguments) : this.overlapsMinMax.apply(this, arguments)
				}, t.prototype.overlapsInterval = function(t) {
					return this.overlaps(t.min, t.max)
				}, t.prototype.overlapsMinMax = function(t, e) {
					return !(this.min > e || this.max < t)
				}, t.prototype.contains = function() {
					var t;
					return arguments[0] instanceof jsts.index.bintree.Interval ? (t = arguments[0], this.containsMinMax(t.min, t.max)) : 1 === arguments.length ? this.containsPoint(arguments[0]) : this.containsMinMax(arguments[0], arguments[1])
				}, t.prototype.containsMinMax = function(t, e) {
					return t >= this.min && e <= this.max
				}, t.prototype.containsPoint = function(t) {
					return t >= this.min && t <= this.max
				}, jsts.index.bintree.Interval = t
			}(), jsts.index.DoubleBits = function() {}, jsts.index.DoubleBits.powerOf2 = function(t) {
				return Math.pow(2, t)
			}, jsts.index.DoubleBits.exponent = function(t) {
				return jsts.index.DoubleBits.CVTFWD(64, t) - 1023
			}, jsts.index.DoubleBits.CVTFWD = function(t, e) {
				var n, i, o, r, s = "",
					a = {
						32: {
							d: 127,
							c: 128,
							b: 0,
							a: 0
						},
						64: {
							d: 32752,
							c: 0,
							b: 0,
							a: 0
						}
					},
					l = {
						32: 8,
						64: 11
					}[t];
				if (r || (n = 0 > e || 0 > 1 / e, isFinite(e) || (r = a[t], n && (r.d += 1 << t / 4 - 1), i = Math.pow(2, l) - 1, o = 0)), !r) {
					for (i = {
						32: 127,
						64: 1023
					}[t], o = Math.abs(e); o >= 2;) i++, o /= 2;
					for (; 1 > o && i > 0;) i--, o *= 2;
					0 >= i && (o /= 2, s = "Zero or Denormal"), 32 === t && i > 254 && (s = "Too big for Single", r = {
						d: n ? 255 : 127,
						c: 128,
						b: 0,
						a: 0
					}, i = Math.pow(2, l) - 1, o = 0)
				}
				return i
			}, function() {
				var t = jsts.index.DoubleBits,
					e = jsts.index.bintree.Interval,
					n = function(t) {
						this.pt = 0, this.level = 0, this.computeKey(t)
					};
				n.computeLevel = function(e) {
					var n, i = e.getWidth();
					return n = t.exponent(i) + 1
				}, n.prototype.getPoint = function() {
					return this.pt
				}, n.prototype.getLevel = function() {
					return this.level
				}, n.prototype.getInterval = function() {
					return this.interval
				}, n.prototype.computeKey = function(t) {
					for (this.level = n.computeLevel(t), this.interval = new e, this.computeInterval(this.level, t); !this.interval.contains(t);) this.level += 1, this.computeInterval(this.level, t)
				}, n.prototype.computeInterval = function(e, n) {
					var i = t.powerOf2(e);
					this.pt = Math.floor(n.getMin() / i) * i, this.interval.init(this.pt, this.pt + i)
				}, jsts.index.bintree.Key = n
			}(), jsts.operation.buffer.SubgraphDepthLocater = function(t) {
				this.subgraphs = [], this.seg = new jsts.geom.LineSegment, this.subgraphs = t
			}, jsts.operation.buffer.SubgraphDepthLocater.prototype.subgraphs = null, jsts.operation.buffer.SubgraphDepthLocater.prototype.seg = null, jsts.operation.buffer.SubgraphDepthLocater.prototype.getDepth = function(t) {
				var e = this.findStabbedSegments(t);
				if (0 === e.length) return 0;
				e.sort();
				var n = e[0];
				return n.leftDepth
			}, jsts.operation.buffer.SubgraphDepthLocater.prototype.findStabbedSegments = function(t) {
				if (3 === arguments.length) return void this.findStabbedSegments2.apply(this, arguments);
				for (var e = [], n = 0; n < this.subgraphs.length; n++) {
					var i = this.subgraphs[n],
						o = i.getEnvelope();
					t.y < o.getMinY() || t.y > o.getMaxY() || this.findStabbedSegments2(t, i.getDirectedEdges(), e)
				}
				return e
			}, jsts.operation.buffer.SubgraphDepthLocater.prototype.findStabbedSegments2 = function(t, e, n) {
				if (arguments[1] instanceof jsts.geomgraph.DirectedEdge) return void this.findStabbedSegments3(t, e, n);
				for (var i = e.iterator(); i.hasNext();) {
					var o = i.next();
					o.isForward() && this.findStabbedSegments3(t, o, n)
				}
			}, jsts.operation.buffer.SubgraphDepthLocater.prototype.findStabbedSegments3 = function(t, e, n) {
				for (var i = e.getEdge().getCoordinates(), o = 0; o < i.length - 1; o++) {
					this.seg.p0 = i[o], this.seg.p1 = i[o + 1], this.seg.p0.y > this.seg.p1.y && this.seg.reverse();
					var r = Math.max(this.seg.p0.x, this.seg.p1.x);
					if (!(r < t.x || this.seg.isHorizontal() || t.y < this.seg.p0.y || t.y > this.seg.p1.y || jsts.algorithm.CGAlgorithms.computeOrientation(this.seg.p0, this.seg.p1, t) === jsts.algorithm.CGAlgorithms.RIGHT)) {
						var s = e.getDepth(jsts.geomgraph.Position.LEFT);
						this.seg.p0.equals(i[o]) || (s = e.getDepth(jsts.geomgraph.Position.RIGHT));
						var a = new jsts.operation.buffer.SubgraphDepthLocater.DepthSegment(this.seg, s);
						n.push(a)
					}
				}
			}, jsts.operation.buffer.SubgraphDepthLocater.DepthSegment = function(t, e) {
				this.upwardSeg = new jsts.geom.LineSegment(t), this.leftDepth = e
			}, jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.upwardSeg = null, jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.leftDepth = null, jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.compareTo = function(t) {
				var e = t,
					n = this.upwardSeg.orientationIndex(e.upwardSeg);
				return 0 === n && (n = -1 * e.upwardSeg.orientationIndex(upwardSeg)), 0 !== n ? n : this.compareX(this.upwardSeg, e.upwardSeg)
			}, jsts.operation.buffer.SubgraphDepthLocater.DepthSegment.prototype.compareX = function(t, e) {
				var n = t.p0.compareTo(e.p0);
				return 0 !== n ? n : t.p1.compareTo(e.p1)
			}, jsts.noding.snapround.HotPixel = function(t, e, n) {
				this.corner = [], this.originalPt = t, this.pt = t, this.scaleFactor = e, this.li = n, 1 !== this.scaleFactor && (this.pt = new jsts.geom.Coordinate(this.scale(t.x), this.scale(t.y)), this.p0Scaled = new jsts.geom.Coordinate, this.p1Scaled = new jsts.geom.Coordinate), this.initCorners(this.pt)
			}, jsts.noding.snapround.HotPixel.prototype.li = null, jsts.noding.snapround.HotPixel.prototype.pt = null, jsts.noding.snapround.HotPixel.prototype.originalPt = null, jsts.noding.snapround.HotPixel.prototype.ptScaled = null, jsts.noding.snapround.HotPixel.prototype.p0Scaled = null, jsts.noding.snapround.HotPixel.prototype.p1Scaled = null, jsts.noding.snapround.HotPixel.prototype.scaleFactor = void 0, jsts.noding.snapround.HotPixel.prototype.minx = void 0, jsts.noding.snapround.HotPixel.prototype.maxx = void 0, jsts.noding.snapround.HotPixel.prototype.miny = void 0, jsts.noding.snapround.HotPixel.prototype.maxy = void 0, jsts.noding.snapround.HotPixel.prototype.corner = null, jsts.noding.snapround.HotPixel.prototype.safeEnv = null, jsts.noding.snapround.HotPixel.prototype.getCoordinate = function() {
				return this.originalPt
			}, jsts.noding.snapround.HotPixel.SAFE_ENV_EXPANSION_FACTOR = .75, jsts.noding.snapround.HotPixel.prototype.getSafeEnvelope = function() {
				if (null === this.safeEnv) {
					var t = jsts.noding.snapround.HotPixel.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;
					this.safeEnv = new jsts.geom.Envelope(this.originalPt.x - t, this.originalPt.x + t, this.originalPt.y - t, this.originalPt.y + t)
				}
				return this.safeEnv
			}, jsts.noding.snapround.HotPixel.prototype.initCorners = function(t) {
				var e = .5;
				this.minx = t.x - e, this.maxx = t.x + e, this.miny = t.y - e, this.maxy = t.y + e, this.corner[0] = new jsts.geom.Coordinate(this.maxx, this.maxy), this.corner[1] = new jsts.geom.Coordinate(this.minx, this.maxy), this.corner[2] = new jsts.geom.Coordinate(this.minx, this.miny), this.corner[3] = new jsts.geom.Coordinate(this.maxx, this.miny)
			}, jsts.noding.snapround.HotPixel.prototype.scale = function(t) {
				return Math.round(t * this.scaleFactor)
			}, jsts.noding.snapround.HotPixel.prototype.intersects = function(t, e) {
				return 1 === this.scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this.p0Scaled), this.copyScaled(e, this.p1Scaled), this.intersectsScaled(this.p0Scaled, this.p1Scaled))
			}, jsts.noding.snapround.HotPixel.prototype.copyScaled = function(t, e) {
				e.x = this.scale(t.x), e.y = this.scale(t.y)
			}, jsts.noding.snapround.HotPixel.prototype.intersectsScaled = function(t, e) {
				var n = Math.min(t.x, e.x),
					i = Math.max(t.x, e.x),
					o = Math.min(t.y, e.y),
					r = Math.max(t.y, e.y),
					s = this.maxx < n || this.minx > i || this.maxy < o || this.miny > r;
				if (s) return !1;
				var a = this.intersectsToleranceSquare(t, e);
				return jsts.util.Assert.isTrue(!(s && a), "Found bad envelope test"), a
			}, jsts.noding.snapround.HotPixel.prototype.intersectsToleranceSquare = function(t, e) {
				var n = !1,
					i = !1;
				return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !! this.li.isProper() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), !! this.li.isProper() || (this.li.hasIntersection() && (n = !0), this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), !! this.li.isProper() || (this.li.hasIntersection() && (i = !0), this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), !! this.li.isProper() || (!(!n || !i) || ( !! t.equals(this.pt) || !! e.equals(this.pt))))))
			}, jsts.noding.snapround.HotPixel.prototype.intersectsPixelClosure = function(t, e) {
				return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]), !! this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]), !! this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[2], this.corner[3]), !! this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[3], this.corner[0]), !! this.li.hasIntersection())))
			}, jsts.noding.snapround.HotPixel.prototype.addSnappedNode = function(t, e) {
				var n = t.getCoordinate(e),
					i = t.getCoordinate(e + 1);
				return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e), !0)
			}, jsts.operation.buffer.BufferInputLineSimplifier = function(t) {
				this.inputLine = t
			}, jsts.operation.buffer.BufferInputLineSimplifier.simplify = function(t, e) {
				var n = new jsts.operation.buffer.BufferInputLineSimplifier(t);
				return n.simplify(e)
			}, jsts.operation.buffer.BufferInputLineSimplifier.INIT = 0, jsts.operation.buffer.BufferInputLineSimplifier.DELETE = 1, jsts.operation.buffer.BufferInputLineSimplifier.KEEP = 1, jsts.operation.buffer.BufferInputLineSimplifier.prototype.inputLine = null, jsts.operation.buffer.BufferInputLineSimplifier.prototype.distanceTol = null, jsts.operation.buffer.BufferInputLineSimplifier.prototype.isDeleted = null, jsts.operation.buffer.BufferInputLineSimplifier.prototype.angleOrientation = jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE, jsts.operation.buffer.BufferInputLineSimplifier.prototype.simplify = function(t) {
				this.distanceTol = Math.abs(t), 0 > t && (this.angleOrientation = jsts.algorithm.CGAlgorithms.CLOCKWISE), this.isDeleted = [], this.isDeleted.length = this.inputLine.length;
				var e = !1;
				do e = this.deleteShallowConcavities();
				while (e);
				return this.collapseLine()
			}, jsts.operation.buffer.BufferInputLineSimplifier.prototype.deleteShallowConcavities = function() {
				for (var t = 1, e = (this.inputLine.length - 1, this.findNextNonDeletedIndex(t)), n = this.findNextNonDeletedIndex(e), i = !1; n < this.inputLine.length;) {
					var o = !1;
					this.isDeletable(t, e, n, this.distanceTol) && (this.isDeleted[e] = jsts.operation.buffer.BufferInputLineSimplifier.DELETE, o = !0, i = !0), t = o ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e)
				}
				return i
			}, jsts.operation.buffer.BufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function(t) {
				for (var e = t + 1; e < this.inputLine.length && this.isDeleted[e] === jsts.operation.buffer.BufferInputLineSimplifier.DELETE;) e++;
				return e
			}, jsts.operation.buffer.BufferInputLineSimplifier.prototype.collapseLine = function() {
				for (var t = [], e = 0; e < this.inputLine.length; e++) this.isDeleted[e] !== jsts.operation.buffer.BufferInputLineSimplifier.DELETE && t.push(this.inputLine[e]);
				return t
			}, jsts.operation.buffer.BufferInputLineSimplifier.prototype.isDeletable = function(t, e, n, i) {
				var o = this.inputLine[t],
					r = this.inputLine[e],
					s = this.inputLine[n];
				return !(!this.isConcave(o, r, s) || !this.isShallow(o, r, s, i)) && this.isShallowSampled(o, r, t, n, i);
			}, jsts.operation.buffer.BufferInputLineSimplifier.prototype.isShallowConcavity = function(t, e, n, i) {
				var o = jsts.algorithm.CGAlgorithms.computeOrientation(t, e, n),
					r = o === this.angleOrientation;
				if (!r) return !1;
				var s = jsts.algorithm.CGAlgorithms.distancePointLine(e, t, n);
				return i > s
			}, jsts.operation.buffer.BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10, jsts.operation.buffer.BufferInputLineSimplifier.prototype.isShallowSampled = function(t, e, n, i, o) {
				var r = parseInt((i - n) / jsts.operation.buffer.BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
				0 >= r && (r = 1);
				for (var s = n; i > s; s += r) if (!this.isShallow(t, e, this.inputLine[s], o)) return !1;
				return !0
			}, jsts.operation.buffer.BufferInputLineSimplifier.prototype.isShallow = function(t, e, n, i) {
				var o = jsts.algorithm.CGAlgorithms.distancePointLine(e, t, n);
				return i > o
			}, jsts.operation.buffer.BufferInputLineSimplifier.prototype.isConcave = function(t, e, n) {
				var i = jsts.algorithm.CGAlgorithms.computeOrientation(t, e, n),
					o = i === this.angleOrientation;
				return o
			}, jsts.geomgraph.index.SweepLineEvent = function(t, e, n) {
				return e instanceof jsts.geomgraph.index.SweepLineEvent ? (this.eventType = jsts.geomgraph.index.SweepLineEvent.DELETE, this.xValue = t, void(this.insertEvent = e)) : (this.eventType = jsts.geomgraph.index.SweepLineEvent.INSERT, this.label = n, this.xValue = t, void(this.obj = e))
			}, jsts.geomgraph.index.SweepLineEvent.INSERT = 1, jsts.geomgraph.index.SweepLineEvent.DELETE = 2, jsts.geomgraph.index.SweepLineEvent.prototype.label = null, jsts.geomgraph.index.SweepLineEvent.prototype.xValue = null, jsts.geomgraph.index.SweepLineEvent.prototype.eventType = null, jsts.geomgraph.index.SweepLineEvent.prototype.insertEvent = null, jsts.geomgraph.index.SweepLineEvent.prototype.deleteEventIndex = null, jsts.geomgraph.index.SweepLineEvent.prototype.obj = null, jsts.geomgraph.index.SweepLineEvent.prototype.isInsert = function() {
				return this.eventType == jsts.geomgraph.index.SweepLineEvent.INSERT
			}, jsts.geomgraph.index.SweepLineEvent.prototype.isDelete = function() {
				return this.eventType == jsts.geomgraph.index.SweepLineEvent.DELETE
			}, jsts.geomgraph.index.SweepLineEvent.prototype.getInsertEvent = function() {
				return this.insertEvent
			}, jsts.geomgraph.index.SweepLineEvent.prototype.getDeleteEventIndex = function() {
				return this.deleteEventIndex
			}, jsts.geomgraph.index.SweepLineEvent.prototype.setDeleteEventIndex = function(t) {
				this.deleteEventIndex = t
			}, jsts.geomgraph.index.SweepLineEvent.prototype.getObject = function() {
				return this.obj
			}, jsts.geomgraph.index.SweepLineEvent.prototype.isSameLabel = function(t) {
				return null != this.label && this.label == t.label
			}, jsts.geomgraph.index.SweepLineEvent.prototype.compareTo = function(t) {
				return this.xValue < t.xValue ? -1 : this.xValue > t.xValue ? 1 : this.eventType < t.eventType ? -1 : this.eventType > t.eventType ? 1 : 0
			}, jsts.geom.CoordinateList = function(t, e) {
				this.array = [], e = void 0 === e || e, void 0 !== t && this.add(t, e)
			}, jsts.geom.CoordinateList.prototype = new javascript.util.ArrayList, jsts.geom.CoordinateList.prototype.iterator = null, jsts.geom.CoordinateList.prototype.remove = null, jsts.geom.CoordinateList.prototype.get = function(t) {
				return this.array[t]
			}, jsts.geom.CoordinateList.prototype.set = function(t, e) {
				var n = this.array[t];
				return this.array[t] = e, n
			}, jsts.geom.CoordinateList.prototype.size = function() {
				return this.array.length
			}, jsts.geom.CoordinateList.prototype.add = function() {
				return arguments.length > 1 ? this.addCoordinates.apply(this, arguments) : this.array.push(arguments[0])
			}, jsts.geom.CoordinateList.prototype.addCoordinates = function(t, e, n) {
				if (t instanceof jsts.geom.Coordinate) return this.addCoordinate.apply(this, arguments);
				if ("number" == typeof t) return this.insertCoordinate.apply(this, arguments);
				if (n = n || !0) for (var i = 0; i < t.length; i++) this.addCoordinate(t[i], e);
				else for (var i = t.length - 1; i >= 0; i--) this.addCoordinate(t[i], e);
				return !0
			}, jsts.geom.CoordinateList.prototype.addCoordinate = function(t, e) {
				if (!e && this.size() >= 1) {
					var n = this.get(this.size() - 1);
					if (n.equals2D(t)) return
				}
				this.add(t)
			}, jsts.geom.CoordinateList.prototype.insertCoordinate = function(t, e, n) {
				if (!n) {
					var i = t > 0 ? t - 1 : -1;
					if (-1 !== i && this.get(i).equals2D(e)) return;
					var o = t < this.size() - 1 ? t + 1 : -1;
					if (-1 !== o && this.get(o).equals2D(e)) return
				}
				this.array.splice(t, 0, e)
			}, jsts.geom.CoordinateList.prototype.closeRing = function() {
				this.size() > 0 && this.addCoordinate(new jsts.geom.Coordinate(this.get(0)), !1)
			}, jsts.geom.CoordinateList.prototype.toArray = function() {
				return this.array
			}, jsts.geom.CoordinateList.prototype.toCoordinateArray = function() {
				return this.array
			}, jsts.operation.buffer.OffsetSegmentGenerator = function(t, e, n) {
				this.seg0 = new jsts.geom.LineSegment, this.seg1 = new jsts.geom.LineSegment, this.offset0 = new jsts.geom.LineSegment, this.offset1 = new jsts.geom.LineSegment, this.precisionModel = t, this.bufParams = e, this.li = new jsts.algorithm.RobustLineIntersector, this.filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(), this.bufParams.getQuadrantSegments() >= 8 && this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_ROUND && (this.closingSegLengthFactor = jsts.operation.buffer.OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n)
			}, jsts.operation.buffer.OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, jsts.operation.buffer.OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, jsts.operation.buffer.OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, jsts.operation.buffer.OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80, jsts.operation.buffer.OffsetSegmentGenerator.prototype.maxCurveSegmentError = 0, jsts.operation.buffer.OffsetSegmentGenerator.prototype.filletAngleQuantum = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.closingSegLengthFactor = 1, jsts.operation.buffer.OffsetSegmentGenerator.prototype.segList = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.distance = 0, jsts.operation.buffer.OffsetSegmentGenerator.prototype.precisionModel = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.bufParams = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.li = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.s0 = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.s1 = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.s2 = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.seg0 = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.seg1 = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.offset0 = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.offset1 = null, jsts.operation.buffer.OffsetSegmentGenerator.prototype.side = 0, jsts.operation.buffer.OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = !1, jsts.operation.buffer.OffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function() {
				return this.hasNarrowConcaveAngle
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.init = function(t) {
				this.distance = t, this.maxCurveSegmentError = this.distance * (1 - Math.cos(this.filletAngleQuantum / 2)), this.segList = new jsts.operation.buffer.OffsetSegmentString, this.segList.setPrecisionModel(this.precisionModel), this.segList.setMinimumVertexDistance(this.distance * jsts.operation.buffer.OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.initSideSegments = function(t, e, n) {
				this.s1 = t, this.s2 = e, this.side = n, this.seg1.setCoordinates(this.s1, this.s2), this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1)
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.getCoordinates = function() {
				return this.segList.getCoordinates()
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.closeRing = function() {
				this.segList.closeRing()
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addSegments = function(t, e) {
				this.segList.addPts(t, e)
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addFirstSegment = function() {
				this.segList.addPt(this.offset1.p0)
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addLastSegment = function() {
				this.segList.addPt(this.offset1.p1)
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addNextSegment = function(t, e) {
				if (this.s0 = this.s1, this.s1 = this.s2, this.s2 = t, this.seg0.setCoordinates(this.s0, this.s1), this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0), this.seg1.setCoordinates(this.s1, this.s2), this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1), !this.s1.equals(this.s2)) {
					var n = jsts.algorithm.CGAlgorithms.computeOrientation(this.s0, this.s1, this.s2),
						i = n === jsts.algorithm.CGAlgorithms.CLOCKWISE && this.side === jsts.geomgraph.Position.LEFT || n === jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE && this.side === jsts.geomgraph.Position.RIGHT;
					0 == n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e)
				}
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addCollinear = function(t) {
				this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2);
				var e = this.li.getIntersectionNum();
				e >= 2 && (this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_BEVEL || this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_MITRE ? (t && this.segList.addPt(this.offset0.p1), this.segList.addPt(this.offset1.p0)) : this.addFillet(this.s1, this.offset0.p1, this.offset1.p0, jsts.algorithm.CGAlgorithms.CLOCKWISE, this.distance))
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addOutsideTurn = function(t, e) {
				return this.offset0.p1.distance(this.offset1.p0) < this.distance * jsts.operation.buffer.OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR ? void this.segList.addPt(this.offset0.p1) : void(this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_MITRE ? this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance) : this.bufParams.getJoinStyle() === jsts.operation.buffer.BufferParameters.JOIN_BEVEL ? this.addBevelJoin(this.offset0, this.offset1) : (e && this.segList.addPt(this.offset0.p1), this.addFillet(this.s1, this.offset0.p1, this.offset1.p0, t, this.distance), this.segList.addPt(this.offset1.p0)))
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addInsideTurn = function() {
				if (this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1), this.li.hasIntersection()) this.segList.addPt(this.li.getIntersection(0));
				else if (this.hasNarrowConcaveAngle = !0, this.offset0.p1.distance(this.offset1.p0) < this.distance * jsts.operation.buffer.OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this.segList.addPt(this.offset0.p1);
				else {
					if (this.segList.addPt(this.offset0.p1), this.closingSegLengthFactor > 0) {
						var t = new jsts.geom.Coordinate((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));
						this.segList.addPt(t);
						var e = new jsts.geom.Coordinate((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));
						this.segList.addPt(e)
					} else this.segList.addPt(this.s1);
					this.segList.addPt(this.offset1.p0)
				}
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.computeOffsetSegment = function(t, e, n, i) {
				var o = e === jsts.geomgraph.Position.LEFT ? 1 : -1,
					r = t.p1.x - t.p0.x,
					s = t.p1.y - t.p0.y,
					a = Math.sqrt(r * r + s * s),
					l = o * n * r / a,
					u = o * n * s / a;
				i.p0.x = t.p0.x - u, i.p0.y = t.p0.y + l, i.p1.x = t.p1.x - u, i.p1.y = t.p1.y + l
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addLineEndCap = function(t, e) {
				var n = new jsts.geom.LineSegment(t, e),
					i = new jsts.geom.LineSegment;
				this.computeOffsetSegment(n, jsts.geomgraph.Position.LEFT, this.distance, i);
				var o = new jsts.geom.LineSegment;
				this.computeOffsetSegment(n, jsts.geomgraph.Position.RIGHT, this.distance, o);
				var r = e.x - t.x,
					s = e.y - t.y,
					a = Math.atan2(s, r);
				switch (this.bufParams.getEndCapStyle()) {
				case jsts.operation.buffer.BufferParameters.CAP_ROUND:
					this.segList.addPt(i.p1), this.addFillet(e, a + Math.PI / 2, a - Math.PI / 2, jsts.algorithm.CGAlgorithms.CLOCKWISE, this.distance), this.segList.addPt(o.p1);
					break;
				case jsts.operation.buffer.BufferParameters.CAP_FLAT:
					this.segList.addPt(i.p1), this.segList.addPt(o.p1);
					break;
				case jsts.operation.buffer.BufferParameters.CAP_SQUARE:
					var l = new jsts.geom.Coordinate;
					l.x = Math.abs(this.distance) * Math.cos(a), l.y = Math.abs(this.distance) * Math.sin(a);
					var u = new jsts.geom.Coordinate(i.p1.x + l.x, i.p1.y + l.y),
						p = new jsts.geom.Coordinate(o.p1.x + l.x, o.p1.y + l.y);
					this.segList.addPt(u), this.segList.addPt(p)
				}
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addMitreJoin = function(t, e, n, i) {
				var o = !0,
					r = null;
				try {
					r = jsts.algorithm.HCoordinate.intersection(e.p0, e.p1, n.p0, n.p1);
					var s = 0 >= i ? 1 : r.distance(t) / Math.abs(i);
					s > this.bufParams.getMitreLimit() && (this.isMitreWithinLimit = !1)
				} catch (a) {
					a instanceof jsts.error.NotRepresentableError && (r = new jsts.geom.Coordinate(0, 0), this.isMitreWithinLimit = !1)
				}
				o ? this.segList.addPt(r) : this.addLimitedMitreJoin(e, n, i, bufParams.getMitreLimit())
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addLimitedMitreJoin = function(t, e, n, i) {
				var o = this.seg0.p1,
					r = jsts.algorithm.Angle.angle(o, this.seg0.p0),
					s = (jsts.algorithm.Angle.angle(o, this.seg1.p1), jsts.algorithm.Angle.angleBetweenOriented(this.seg0.p0, o, this.seg1.p1)),
					a = s / 2,
					l = jsts.algorithm.Angle.normalize(r + a),
					u = jsts.algorithm.Angle.normalize(l + Math.PI),
					p = i * n,
					h = p * Math.abs(Math.sin(a)),
					c = n - h,
					g = o.x + p * Math.cos(u),
					d = o.y + p * Math.sin(u),
					f = new jsts.geom.Coordinate(g, d),
					m = new jsts.geom.LineSegment(o, f),
					y = m.pointAlongOffset(1, c),
					v = m.pointAlongOffset(1, -c);
				this.side == jsts.geomgraph.Position.LEFT ? (this.segList.addPt(y), this.segList.addPt(v)) : (this.segList.addPt(v), this.segList.addPt(y))
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addBevelJoin = function(t, e) {
				this.segList.addPt(t.p1), this.segList.addPt(e.p0)
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addFillet = function(t, e, n, i, o) {
				if (!(n instanceof jsts.geom.Coordinate)) return void this.addFillet2.apply(this, arguments);
				var r = e.x - t.x,
					s = e.y - t.y,
					a = Math.atan2(s, r),
					l = n.x - t.x,
					u = n.y - t.y,
					p = Math.atan2(u, l);
				i === jsts.algorithm.CGAlgorithms.CLOCKWISE ? p >= a && (a += 2 * Math.PI) : a >= p && (a -= 2 * Math.PI), this.segList.addPt(e), this.addFillet(t, a, p, i, o), this.segList.addPt(n)
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.addFillet2 = function(t, e, n, i, o) {
				var r = i === jsts.algorithm.CGAlgorithms.CLOCKWISE ? -1 : 1,
					s = Math.abs(e - n),
					a = parseInt(s / this.filletAngleQuantum + .5);
				if (!(1 > a)) {
					var l, u;
					l = 0, u = s / a;
					for (var p = l, h = new jsts.geom.Coordinate; s > p;) {
						var c = e + r * p;
						h.x = t.x + o * Math.cos(c), h.y = t.y + o * Math.sin(c), this.segList.addPt(h), p += u
					}
				}
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.createCircle = function(t) {
				var e = new jsts.geom.Coordinate(t.x + this.distance, t.y);
				this.segList.addPt(e), this.addFillet(t, 0, 2 * Math.PI, -1, this.distance), this.segList.closeRing()
			}, jsts.operation.buffer.OffsetSegmentGenerator.prototype.createSquare = function(t) {
				this.segList.addPt(new jsts.geom.Coordinate(t.x + distance, t.y + distance)), this.segList.addPt(new jsts.geom.Coordinate(t.x + distance, t.y - distance)), this.segList.addPt(new jsts.geom.Coordinate(t.x - distance, t.y - distance)), this.segList.addPt(new jsts.geom.Coordinate(t.x - distance, t.y + distance)), this.segList.closeRing()
			}, jsts.operation.overlay.MaximalEdgeRing = function(t, e) {
				jsts.geomgraph.EdgeRing.call(this, t, e)
			}, jsts.operation.overlay.MaximalEdgeRing.prototype = new jsts.geomgraph.EdgeRing, jsts.operation.overlay.MaximalEdgeRing.constructor = jsts.operation.overlay.MaximalEdgeRing, jsts.operation.overlay.MaximalEdgeRing.prototype.getNext = function(t) {
				return t.getNext()
			}, jsts.operation.overlay.MaximalEdgeRing.prototype.setEdgeRing = function(t, e) {
				t.setEdgeRing(e)
			}, jsts.operation.overlay.MaximalEdgeRing.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
				var t = this.startDe;
				do {
					var e = t.getNode();
					e.getEdges().linkMinimalDirectedEdges(this), t = t.getNext()
				} while (t != this.startDe)
			}, jsts.operation.overlay.MaximalEdgeRing.prototype.buildMinimalRings = function() {
				var t = [],
					e = this.startDe;
				do {
					if (null === e.getMinEdgeRing()) {
						var n = new jsts.operation.overlay.MinimalEdgeRing(e, this.geometryFactory);
						t.push(n)
					}
					e = e.getNext()
				} while (e != this.startDe);
				return t
			}, jsts.algorithm.CentroidPoint = function() {
				this.centSum = new jsts.geom.Coordinate
			}, jsts.algorithm.CentroidPoint.prototype.ptCount = 0, jsts.algorithm.CentroidPoint.prototype.centSum = null, jsts.algorithm.CentroidPoint.prototype.add = function(t) {
				if (t instanceof jsts.geom.Point) this.add2(t.getCoordinate());
				else if (t instanceof jsts.geom.GeometryCollection || t instanceof jsts.geom.MultiPoint || t instanceof jsts.geom.MultiLineString || t instanceof jsts.geom.MultiPolygon) for (var e = t, n = 0; n < e.getNumGeometries(); n++) this.add(e.getGeometryN(n))
			}, jsts.algorithm.CentroidPoint.prototype.add2 = function(t) {
				this.ptCount += 1, this.centSum.x += t.x, this.centSum.y += t.y
			}, jsts.algorithm.CentroidPoint.prototype.getCentroid = function() {
				var t = new jsts.geom.Coordinate;
				return t.x = this.centSum.x / this.ptCount, t.y = this.centSum.y / this.ptCount, t
			}, jsts.operation.distance.ConnectedElementLocationFilter = function(t) {
				this.locations = t
			}, jsts.operation.distance.ConnectedElementLocationFilter.prototype = new jsts.geom.GeometryFilter, jsts.operation.distance.ConnectedElementLocationFilter.prototype.locations = null, jsts.operation.distance.ConnectedElementLocationFilter.getLocations = function(t) {
				var e = [];
				return t.apply(new jsts.operation.distance.ConnectedElementLocationFilter(e)), e
			}, jsts.operation.distance.ConnectedElementLocationFilter.prototype.filter = function(t) {
				(t instanceof jsts.geom.Point || t instanceof jsts.geom.LineString || t instanceof jsts.geom.Polygon) && this.locations.push(new jsts.operation.distance.GeometryLocation(t, 0, t.getCoordinate()))
			}, jsts.geomgraph.index.MonotoneChainEdge = function(t) {
				this.e = t, this.pts = t.getCoordinates();
				var e = new jsts.geomgraph.index.MonotoneChainIndexer;
				this.startIndex = e.getChainStartIndices(this.pts)
			}, jsts.geomgraph.index.MonotoneChainEdge.prototype.e = null, jsts.geomgraph.index.MonotoneChainEdge.prototype.pts = null, jsts.geomgraph.index.MonotoneChainEdge.prototype.startIndex = null, jsts.geomgraph.index.MonotoneChainEdge.prototype.env1 = new jsts.geom.Envelope, jsts.geomgraph.index.MonotoneChainEdge.prototype.env2 = new jsts.geom.Envelope, jsts.geomgraph.index.MonotoneChainEdge.prototype.getCoordinates = function() {
				return this.pts
			}, jsts.geomgraph.index.MonotoneChainEdge.prototype.getStartIndexes = function() {
				return this.startIndex
			}, jsts.geomgraph.index.MonotoneChainEdge.prototype.getMinX = function(t) {
				var e = this.pts[this.startIndex[t]].x,
					n = this.pts[this.startIndex[t + 1]].x;
				return n > e ? e : n
			}, jsts.geomgraph.index.MonotoneChainEdge.prototype.getMaxX = function(t) {
				var e = this.pts[this.startIndex[t]].x,
					n = this.pts[this.startIndex[t + 1]].x;
				return e > n ? e : n
			}, jsts.geomgraph.index.MonotoneChainEdge.prototype.computeIntersects = function(t, e) {
				for (var n = 0; n < this.startIndex.length - 1; n++) for (var i = 0; i < t.startIndex.length - 1; i++) this.computeIntersectsForChain(n, t, i, e)
			}, jsts.geomgraph.index.MonotoneChainEdge.prototype.computeIntersectsForChain = function(t, e, n, i) {
				this.computeIntersectsForChain2(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i)
			}, jsts.geomgraph.index.MonotoneChainEdge.prototype.computeIntersectsForChain2 = function(t, e, n, i, o, r) {
				var s = this.pts[t],
					a = this.pts[e],
					l = n.pts[i],
					u = n.pts[o];
				if (e - t == 1 && o - i == 1) return void r.addIntersections(this.e, t, n.e, i);
				if (this.env1.init(s, a), this.env2.init(l, u), this.env1.intersects(this.env2)) {
					var p = Math.floor((t + e) / 2),
						h = Math.floor((i + o) / 2);
					p > t && (h > i && this.computeIntersectsForChain2(t, p, n, i, h, r), o > h && this.computeIntersectsForChain2(t, p, n, h, o, r)), e > p && (h > i && this.computeIntersectsForChain2(p, e, n, i, h, r), o > h && this.computeIntersectsForChain2(p, e, n, h, o, r))
				}
			}, function() {
				var t = javascript.util.ArrayList;
				jsts.operation.relate.EdgeEndBuilder = function() {}, jsts.operation.relate.EdgeEndBuilder.prototype.computeEdgeEnds = function(e) {
					if (2 == arguments.length) return void this.computeEdgeEnds2.apply(this, arguments);
					for (var n = new t, i = e; i.hasNext();) {
						var o = i.next();
						this.computeEdgeEnds2(o, n)
					}
					return n
				}, jsts.operation.relate.EdgeEndBuilder.prototype.computeEdgeEnds2 = function(t, e) {
					var n = t.getEdgeIntersectionList();
					n.addEndpoints();
					var i = n.iterator(),
						o = null,
						r = null;
					if (i.hasNext()) {
						var s = i.next();
						do o = r, r = s, s = null, i.hasNext() && (s = i.next()), null !== r && (this.createEdgeEndForPrev(t, e, r, o), this.createEdgeEndForNext(t, e, r, s));
						while (null !== r)
					}
				}, jsts.operation.relate.EdgeEndBuilder.prototype.createEdgeEndForPrev = function(t, e, n, i) {
					var o = n.segmentIndex;
					if (0 === n.dist) {
						if (0 === o) return;
						o--
					}
					var r = t.getCoordinate(o);
					null !== i && i.segmentIndex >= o && (r = i.coord);
					var s = new jsts.geomgraph.Label(t.getLabel());
					s.flip();
					var a = new jsts.geomgraph.EdgeEnd(t, n.coord, r, s);
					e.add(a)
				}, jsts.operation.relate.EdgeEndBuilder.prototype.createEdgeEndForNext = function(t, e, n, i) {
					var o = n.segmentIndex + 1;
					if (!(o >= t.getNumPoints() && null === i)) {
						var r = t.getCoordinate(o);
						null !== i && i.segmentIndex === n.segmentIndex && (r = i.coord);
						var s = new jsts.geomgraph.EdgeEnd(t, n.coord, r, new jsts.geomgraph.Label(t.getLabel()));
						e.add(s)
					}
				}
			}(), function() {
				var t = javascript.util.ArrayList,
					e = javascript.util.TreeSet,
					n = jsts.geom.CoordinateFilter;
				jsts.util.UniqueCoordinateArrayFilter = function() {
					this.treeSet = new e, this.list = new t
				}, jsts.util.UniqueCoordinateArrayFilter.prototype = new n, jsts.util.UniqueCoordinateArrayFilter.prototype.treeSet = null, jsts.util.UniqueCoordinateArrayFilter.prototype.list = null, jsts.util.UniqueCoordinateArrayFilter.prototype.getCoordinates = function() {
					return this.list.toArray()
				}, jsts.util.UniqueCoordinateArrayFilter.prototype.filter = function(t) {
					this.treeSet.contains(t) || (this.list.add(t), this.treeSet.add(t))
				}
			}(), function() {
				var t = jsts.algorithm.CGAlgorithms,
					e = jsts.util.UniqueCoordinateArrayFilter,
					n = jsts.util.Assert,
					i = javascript.util.Stack,
					o = javascript.util.ArrayList,
					r = javascript.util.Arrays,
					s = function(t) {
						this.origin = t
					};
				s.prototype.origin = null, s.prototype.compare = function(t, e) {
					var n = t,
						i = e;
					return s.polarCompare(this.origin, n, i)
				}, s.polarCompare = function(e, n, i) {
					var o = n.x - e.x,
						r = n.y - e.y,
						s = i.x - e.x,
						a = i.y - e.y,
						l = t.computeOrientation(e, n, i);
					if (l == t.COUNTERCLOCKWISE) return 1;
					if (l == t.CLOCKWISE) return -1;
					var u = o * o + r * r,
						p = s * s + a * a;
					return p > u ? -1 : u > p ? 1 : 0
				}, jsts.algorithm.ConvexHull = function() {
					if (1 === arguments.length) {
						var t = arguments[0];
						this.inputPts = jsts.algorithm.ConvexHull.extractCoordinates(t), this.geomFactory = t.getFactory()
					} else this.pts = arguments[0], this.geomFactory = arguments[1]
				}, jsts.algorithm.ConvexHull.prototype.geomFactory = null, jsts.algorithm.ConvexHull.prototype.inputPts = null, jsts.algorithm.ConvexHull.extractCoordinates = function(t) {
					var n = new e;
					return t.apply(n), n.getCoordinates()
				}, jsts.algorithm.ConvexHull.prototype.getConvexHull = function() {
					if (0 == this.inputPts.length) return this.geomFactory.createGeometryCollection(null);
					if (1 == this.inputPts.length) return this.geomFactory.createPoint(this.inputPts[0]);
					if (2 == this.inputPts.length) return this.geomFactory.createLineString(this.inputPts);
					var t = this.inputPts;
					this.inputPts.length > 50 && (t = this.reduce(this.inputPts));
					var e = this.preSort(t),
						n = this.grahamScan(e),
						i = n.toArray();
					return this.lineOrPolygon(i)
				}, jsts.algorithm.ConvexHull.prototype.reduce = function(e) {
					var n = this.computeOctRing(e);
					if (null == n) return this.inputPts;
					for (var i = new javascript.util.TreeSet, o = 0; o < n.length; o++) i.add(n[o]);
					for (var o = 0; o < e.length; o++) t.isPointInRing(e[o], n) || i.add(e[o]);
					var r = i.toArray();
					return r.length < 3 ? this.padArray3(r) : r
				}, jsts.algorithm.ConvexHull.prototype.padArray3 = function(t) {
					for (var e = [], n = 0; n < e.length; n++) e[n] = n < t.length ? t[n] : t[0];
					return e
				}, jsts.algorithm.ConvexHull.prototype.preSort = function(t) {
					for (var e, n = 1; n < t.length; n++)(t[n].y < t[0].y || t[n].y == t[0].y && t[n].x < t[0].x) && (e = t[0], t[0] = t[n], t[n] = e);
					return r.sort(t, 1, t.length, new s(t[0])), t
				}, jsts.algorithm.ConvexHull.prototype.grahamScan = function(e) {
					var n, o = new i;
					n = o.push(e[0]), n = o.push(e[1]), n = o.push(e[2]);
					for (var r = 3; r < e.length; r++) {
						for (n = o.pop(); !o.empty() && t.computeOrientation(o.peek(), n, e[r]) > 0;) n = o.pop();
						n = o.push(n), n = o.push(e[r])
					}
					return n = o.push(e[0]), o
				}, jsts.algorithm.ConvexHull.prototype.isBetween = function(e, n, i) {
					if (0 !== t.computeOrientation(e, n, i)) return !1;
					if (e.x != i.x) {
						if (e.x <= n.x && n.x <= i.x) return !0;
						if (i.x <= n.x && n.x <= e.x) return !0
					}
					if (e.y != i.y) {
						if (e.y <= n.y && n.y <= i.y) return !0;
						if (i.y <= n.y && n.y <= e.y) return !0
					}
					return !1
				}, jsts.algorithm.ConvexHull.prototype.computeOctRing = function(t) {
					var e = this.computeOctPts(t),
						n = new jsts.geom.CoordinateList;
					return n.add(e, !1), n.size() < 3 ? null : (n.closeRing(), n.toCoordinateArray())
				}, jsts.algorithm.ConvexHull.prototype.computeOctPts = function(t) {
					for (var e = [], n = 0; 8 > n; n++) e[n] = t[0];
					for (var i = 1; i < t.length; i++) t[i].x < e[0].x && (e[0] = t[i]), t[i].x - t[i].y < e[1].x - e[1].y && (e[1] = t[i]), t[i].y > e[2].y && (e[2] = t[i]), t[i].x + t[i].y > e[3].x + e[3].y && (e[3] = t[i]), t[i].x > e[4].x && (e[4] = t[i]), t[i].x - t[i].y > e[5].x - e[5].y && (e[5] = t[i]), t[i].y < e[6].y && (e[6] = t[i]), t[i].x + t[i].y < e[7].x + e[7].y && (e[7] = t[i]);
					return e
				}, jsts.algorithm.ConvexHull.prototype.lineOrPolygon = function(t) {
					if (t = this.cleanRing(t), 3 == t.length) return this.geomFactory.createLineString([t[0], t[1]]);
					var e = this.geomFactory.createLinearRing(t);
					return this.geomFactory.createPolygon(e, null)
				}, jsts.algorithm.ConvexHull.prototype.cleanRing = function(t) {
					n.equals(t[0], t[t.length - 1]);
					for (var e = new o, i = null, r = 0; r <= t.length - 2; r++) {
						var s = t[r],
							a = t[r + 1];
						s.equals(a) || null != i && this.isBetween(i, s, a) || (e.add(s), i = s)
					}
					e.add(t[t.length - 1]);
					var l = [];
					return e.toArray(l)
				}
			}(), jsts.algorithm.MinimumDiameter = function(t, e) {
				this.convexHullPts = null, this.minBaseSeg = new jsts.geom.LineSegment, this.minWidthPt = null, this.minPtIndex = 0, this.minWidth = 0, jsts.algorithm.MinimumDiameter.inputGeom = t, jsts.algorithm.MinimumDiameter.isConvex = e || !1
			}, jsts.algorithm.MinimumDiameter.inputGeom = null, jsts.algorithm.MinimumDiameter.isConvex = !1, jsts.algorithm.MinimumDiameter.nextIndex = function(t, e) {
				return e++, e >= t.length && (e = 0), e
			}, jsts.algorithm.MinimumDiameter.computeC = function(t, e, n) {
				return t * n.y - e * n.x
			}, jsts.algorithm.MinimumDiameter.computeSegmentForLine = function(t, e, n) {
				var i, o;
				return Math.abs(e) > Math.abs(t) ? (i = new jsts.geom.Coordinate(0, n / e), o = new jsts.geom.Coordinate(1, n / e - t / e)) : (i = new jsts.geom.Coordinate(n / t, 0), o = new jsts.geom.Coordinate(n / t - e / t, 1)), new jsts.geom.LineSegment(i, o)
			}, jsts.algorithm.MinimumDiameter.prototype.getLength = function() {
				return this.computeMinimumDiameter(), this.minWidth
			}, jsts.algorithm.MinimumDiameter.prototype.getWidthCoordinate = function() {
				return this.computeMinimumDiameter(), this.minWidthPt
			}, jsts.algorithm.MinimumDiameter.prototype.getSupportingSegment = function() {
				this.computeMinimumDiameter();
				var t = [this.minBaseSeg.p0, this.minBaseSeg.p1];
				return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString(t)
			}, jsts.algorithm.MinimumDiameter.prototype.getDiameter = function() {
				if (this.computeMinimumDiameter(), null === this.minWidthPt) return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString(null);
				var t = this.minBaseSeg.project(this.minWidthPt);
				return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString([t, this.minWidthPt])
			}, jsts.algorithm.MinimumDiameter.prototype.computeMinimumDiameter = function() {
				if (null === this.minWidthPt) if (jsts.algorithm.MinimumDiameter.isConvex) this.computeWidthConvex(jsts.algorithm.MinimumDiameter.inputGeom);
				else {
					var t = new jsts.algorithm.ConvexHull(jsts.algorithm.MinimumDiameter.inputGeom).getConvexHull();
					this.computeWidthConvex(t)
				}
			}, jsts.algorithm.MinimumDiameter.prototype.computeWidthConvex = function(t) {
				this.convexHullPts = t instanceof jsts.geom.Polygon ? t.getExteriorRing().getCoordinates() : t.getCoordinates(), 0 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = null, this.minBaseSeg = null) : 1 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[0]) : 2 === this.convexHullPts.length || 3 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[1]) : this.computeConvexRingMinDiameter(this.convexHullPts)
			}, jsts.algorithm.MinimumDiameter.prototype.computeConvexRingMinDiameter = function(t) {
				this.minWidth = Number.MAX_VALUE;
				for (var e = 1, n = new jsts.geom.LineSegment, i = 0; i < t.length - 1; i++) n.p0 = t[i], n.p1 = t[i + 1], e = this.findMaxPerpDistance(t, n, e)
			}, jsts.algorithm.MinimumDiameter.prototype.findMaxPerpDistance = function(t, e, n) {
				for (var i = e.distancePerpendicular(t[n]), o = i, r = n, s = r; o >= i;) i = o, r = s, s = jsts.algorithm.MinimumDiameter.nextIndex(t, r), o = e.distancePerpendicular(t[s]);
				return i < this.minWidth && (this.minPtIndex = r, this.minWidth = i, this.minWidthPt = t[this.minPtIndex], this.minBaseSeg = new jsts.geom.LineSegment(e)), r
			}, jsts.algorithm.MinimumDiameter.prototype.getMinimumRectangle = function() {
				if (this.computeMinimumDiameter(), 0 === this.minWidth) return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1) ? jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createPoint(this.minBaseSeg.p0) : this.minBaseSeg.toGeometry(jsts.algorithm.MinimumDiameter.inputGeom.getFactory());
				for (var t = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x, e = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y, n = Number.MAX_VALUE, i = -Number.MAX_VALUE, o = Number.MAX_VALUE, r = -Number.MAX_VALUE, s = 0; s < this.convexHullPts.length; s++) {
					var a = jsts.algorithm.MinimumDiameter.computeC(t, e, this.convexHullPts[s]);
					a > i && (i = a), n > a && (n = a);
					var l = jsts.algorithm.MinimumDiameter.computeC(-e, t, this.convexHullPts[s]);
					l > r && (r = l), o > l && (o = l)
				}
				var u = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-t, -e, r),
					p = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-t, -e, o),
					h = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-e, t, i),
					c = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-e, t, n),
					g = h.lineIntersection(u),
					d = c.lineIntersection(u),
					f = c.lineIntersection(p),
					m = h.lineIntersection(p),
					y = jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLinearRing([g, d, f, m, g]);
				return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createPolygon(y, null)
			}, function() {
				jsts.io.GeoJSONParser = function(t) {
					this.geometryFactory = t || new jsts.geom.GeometryFactory, this.geometryTypes = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"]
				}, jsts.io.GeoJSONParser.prototype.read = function(t) {
					var e;
					e = "string" == typeof t ? JSON.parse(t) : t;
					var n = e.type;
					if (!this.parse[n]) throw new Error("Unknown GeoJSON type: " + e.type);
					return -1 != this.geometryTypes.indexOf(n) ? this.parse[n].apply(this, [e.coordinates]) : "GeometryCollection" === n ? this.parse[n].apply(this, [e.geometries]) : this.parse[n].apply(this, [e])
				}, jsts.io.GeoJSONParser.prototype.parse = {
					Feature: function(t) {
						var e = {};
						for (var n in t) e[n] = t[n];
						if (t.geometry) {
							var i = t.geometry.type;
							if (!this.parse[i]) throw new Error("Unknown GeoJSON type: " + t.type);
							e.geometry = this.read(t.geometry)
						}
						return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e
					},
					FeatureCollection: function(t) {
						var e = {};
						if (t.features) {
							e.features = [];
							for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]))
						}
						return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e
					},
					coordinates: function(t) {
						for (var e = [], n = 0; n < t.length; ++n) {
							var i = t[n];
							e.push(new jsts.geom.Coordinate(i[0], i[1]))
						}
						return e
					},
					bbox: function(t) {
						return this.geometryFactory.createLinearRing([new jsts.geom.Coordinate(t[0], t[1]), new jsts.geom.Coordinate(t[2], t[1]), new jsts.geom.Coordinate(t[2], t[3]), new jsts.geom.Coordinate(t[0], t[3]), new jsts.geom.Coordinate(t[0], t[1])])
					},
					Point: function(t) {
						var e = new jsts.geom.Coordinate(t[0], t[1]);
						return this.geometryFactory.createPoint(e)
					},
					MultiPoint: function(t) {
						for (var e = [], n = 0; n < t.length; ++n) e.push(this.parse.Point.apply(this, [t[n]]));
						return this.geometryFactory.createMultiPoint(e)
					},
					LineString: function(t) {
						var e = this.parse.coordinates.apply(this, [t]);
						return this.geometryFactory.createLineString(e)
					},
					MultiLineString: function(t) {
						for (var e = [], n = 0; n < t.length; ++n) e.push(this.parse.LineString.apply(this, [t[n]]));
						return this.geometryFactory.createMultiLineString(e)
					},
					Polygon: function(t) {
						for (var e = this.parse.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), i = [], o = 1; o < t.length; ++o) {
							var r = t[o],
								s = this.parse.coordinates.apply(this, [r]),
								a = this.geometryFactory.createLinearRing(s);
							i.push(a)
						}
						return this.geometryFactory.createPolygon(n, i)
					},
					MultiPolygon: function(t) {
						for (var e = [], n = 0; n < t.length; ++n) {
							var i = t[n];
							e.push(this.parse.Polygon.apply(this, [i]))
						}
						return this.geometryFactory.createMultiPolygon(e)
					},
					GeometryCollection: function(t) {
						for (var e = [], n = 0; n < t.length; ++n) {
							var i = t[n];
							e.push(this.read(i))
						}
						return this.geometryFactory.createGeometryCollection(e)
					}
				}, jsts.io.GeoJSONParser.prototype.write = function(t) {
					var e = t.CLASS_NAME.slice(10);
					if (!this.extract[e]) throw new Error("Geometry is not supported");
					return this.extract[e].apply(this, [t])
				}, jsts.io.GeoJSONParser.prototype.extract = {
					coordinate: function(t) {
						return [t.x, t.y]
					},
					Point: function(t) {
						var e = this.extract.coordinate.apply(this, [t.coordinate]);
						return {
							type: "Point",
							coordinates: e
						}
					},
					MultiPoint: function(t) {
						for (var e = [], n = 0; n < t.geometries.length; ++n) {
							var i = t.geometries[n],
								o = this.extract.Point.apply(this, [i]);
							e.push(o.coordinates)
						}
						return {
							type: "MultiPoint",
							coordinates: e
						}
					},
					LineString: function(t) {
						for (var e = [], n = 0; n < t.points.length; ++n) {
							var i = t.points[n];
							e.push(this.extract.coordinate.apply(this, [i]))
						}
						return {
							type: "LineString",
							coordinates: e
						}
					},
					MultiLineString: function(t) {
						for (var e = [], n = 0; n < t.geometries.length; ++n) {
							var i = t.geometries[n],
								o = this.extract.LineString.apply(this, [i]);
							e.push(o.coordinates)
						}
						return {
							type: "MultiLineString",
							coordinates: e
						}
					},
					Polygon: function(t) {
						var e = [],
							n = this.extract.LineString.apply(this, [t.shell]);
						e.push(n.coordinates);
						for (var i = 0; i < t.holes.length; ++i) {
							var o = t.holes[i],
								r = this.extract.LineString.apply(this, [o]);
							e.push(r.coordinates)
						}
						return {
							type: "Polygon",
							coordinates: e
						}
					},
					MultiPolygon: function(t) {
						for (var e = [], n = 0; n < t.geometries.length; ++n) {
							var i = t.geometries[n],
								o = this.extract.Polygon.apply(this, [i]);
							e.push(o.coordinates)
						}
						return {
							type: "MultiPolygon",
							coordinates: e
						}
					},
					GeometryCollection: function(t) {
						for (var e = [], n = 0; n < t.geometries.length; ++n) {
							var i = t.geometries[n],
								o = i.CLASS_NAME.slice(10);
							e.push(this.extract[o].apply(this, [i]))
						}
						return {
							type: "GeometryCollection",
							geometries: e
						}
					}
				}
			}(), jsts.triangulate.quadedge.Vertex = function() {
				1 === arguments.length ? this.initFromCoordinate(arguments[0]) : this.initFromXY(arguments[0], arguments[1])
			}, jsts.triangulate.quadedge.Vertex.LEFT = 0, jsts.triangulate.quadedge.Vertex.RIGHT = 1, jsts.triangulate.quadedge.Vertex.BEYOND = 2, jsts.triangulate.quadedge.Vertex.BEHIND = 3, jsts.triangulate.quadedge.Vertex.BETWEEN = 4, jsts.triangulate.quadedge.Vertex.ORIGIN = 5, jsts.triangulate.quadedge.Vertex.DESTINATION = 6, jsts.triangulate.quadedge.Vertex.prototype.initFromXY = function(t, e) {
				this.p = new jsts.geom.Coordinate(t, e)
			}, jsts.triangulate.quadedge.Vertex.prototype.initFromCoordinate = function(t) {
				this.p = new jsts.geom.Coordinate(t)
			}, jsts.triangulate.quadedge.Vertex.prototype.getX = function() {
				return this.p.x
			}, jsts.triangulate.quadedge.Vertex.prototype.getY = function() {
				return this.p.y
			}, jsts.triangulate.quadedge.Vertex.prototype.getZ = function() {
				return this.p.z
			}, jsts.triangulate.quadedge.Vertex.prototype.setZ = function(t) {
				this.p.z = t
			}, jsts.triangulate.quadedge.Vertex.prototype.getCoordinate = function() {
				return this.p
			}, jsts.triangulate.quadedge.Vertex.prototype.toString = function() {
				return "POINT (" + this.p.x + " " + this.p.y + ")"
			}, jsts.triangulate.quadedge.Vertex.prototype.equals = function() {
				return 1 === arguments.length ? this.equalsExact(arguments[0]) : this.equalsWithTolerance(arguments[0], arguments[1])
			}, jsts.triangulate.quadedge.Vertex.prototype.equalsExact = function(t) {
				return this.p.x === t.getX() && this.p.y === t.getY()
			}, jsts.triangulate.quadedge.Vertex.prototype.equalsWithTolerance = function(t, e) {
				return this.p.distance(t.getCoordinate()) < e
			}, jsts.triangulate.quadedge.Vertex.prototype.classify = function(t, e) {
				var n, i, o, r;
				return n = this, i = e.sub(t), o = n.sub(t), r = i.crossProduct(o), r > 0 ? jsts.triangulate.quadedge.Vertex.LEFT : 0 > r ? jsts.triangulate.quadedge.Vertex.RIGHT : i.getX() * o.getX() < 0 || i.getY() * o.getY() < 0 ? jsts.triangulate.quadedge.Vertex.BEHIND : i.magn() < o.magn() ? jsts.triangulate.quadedge.Vertex.BEYOND : t.equals(n) ? jsts.triangulate.quadedge.Vertex.ORIGIN : e.equals(n) ? jsts.triangulate.quadedge.Vertex.DESTINATION : jsts.triangulate.quadedge.Vertex.BETWEEN
			}, jsts.triangulate.quadedge.Vertex.prototype.crossProduct = function(t) {
				return this.p.x * t.getY() - this.p.y * t.getX()
			}, jsts.triangulate.quadedge.Vertex.prototype.dot = function(t) {
				return this.p.x * t.getX() + this.p.y * t.getY()
			}, jsts.triangulate.quadedge.Vertex.prototype.times = function(t) {
				return new jsts.triangulate.quadedge.Vertex(t * this.p.x, t * this.p.y)
			}, jsts.triangulate.quadedge.Vertex.prototype.sum = function(t) {
				return new jsts.triangulate.quadedge.Vertex(this.p.x + t.getX(), this.p.y + t.getY())
			}, jsts.triangulate.quadedge.Vertex.prototype.sub = function(t) {
				return new jsts.triangulate.quadedge.Vertex(this.p.x - t.getX(), this.p.y - t.getY())
			}, jsts.triangulate.quadedge.Vertex.prototype.magn = function() {
				return Math.sqrt(this.p.x * this.p.x + this.p.y * this.p.y)
			}, jsts.triangulate.quadedge.Vertex.prototype.cross = function() {
				return new Vertex(this.p.y, (-this.p.x))
			}, jsts.triangulate.quadedge.Vertex.prototype.isInCircle = function(t, e, n) {
				return jsts.triangulate.quadedge.TrianglePredicate.isInCircleRobust(t.p, e.p, n.p, this.p)
			}, jsts.triangulate.quadedge.Vertex.prototype.isCCW = function(t, e) {
				return (t.p.x - this.p.x) * (e.p.y - this.p.y) - (t.p.y - this.p.y) * (e.p.x - this.p.x) > 0
			}, jsts.triangulate.quadedge.Vertex.prototype.rightOf = function(t) {
				return this.isCCW(t.dest(), t.orig())
			}, jsts.triangulate.quadedge.Vertex.prototype.leftOf = function(t) {
				return this.isCCW(t.orig(), t.dest())
			}, jsts.triangulate.quadedge.Vertex.prototype.bisector = function(t, e) {
				var n, i, o, r;
				return n = e.getX() - t.getX(), i = e.getY() - t.getY(), o = new jsts.algorithm.HCoordinate(t.getX() + n / 2, t.getY() + i / 2, 1), r = new jsts.algorithm.HCoordinate(t.getX() - i + n / 2, t.getY() + n + i / 2, 1), new jsts.algorithm.HCoordinate(o, r)
			}, jsts.triangulate.quadedge.Vertex.prototype.distance = function(t, e) {
				return t.p.distance(e.p)
			}, jsts.triangulate.quadedge.Vertex.prototype.circumRadiusRatio = function(t, e) {
				var n, i, o, r;
				return n = this.circleCenter(t, e), i = this.distance(n, t), o = this.distance(this, t), r = this.distance(t, e), o > r && (o = r), r = this.distance(e, this), o > r && (o = r), i / o
			}, jsts.triangulate.quadedge.Vertex.prototype.midPoint = function(t) {
				var e, n;
				return e = (this.p.x + t.getX()) / 2, n = (this.p.y + t.getY()) / 2, new jsts.triangulate.quadedge.Vertex(e, n)
			}, jsts.triangulate.quadedge.Vertex.prototype.circleCenter = function(t, e) {
				var n, i, o, r, s;
				n = new jsts.triangulate.quadedge.Vertex(this.getX(), this.getY()), i = this.bisector(n, t), o = this.bisector(t, e), r = new jsts.algorithm.HCoordinate(i, o), s = null;
				try {
					s = new jsts.triangulate.quadedge.Vertex(r.getX(), r.getY())
				} catch (a) {}
				return s
			}, jsts.operation.valid.IsValidOp = function(t) {
				this.parentGeometry = t, this.isSelfTouchingRingFormingHoleValid = !1, this.validErr = null
			}, jsts.operation.valid.IsValidOp.isValid = function(t) {
				if (arguments[0] instanceof jsts.geom.Coordinate) return !isNaN(t.x) && (!(!isFinite(t.x) && !isNaN(t.x)) && (!isNaN(t.y) && !(!isFinite(t.y) && !isNaN(t.y))));
				var e = new jsts.operation.valid.IsValidOp(t);
				return e.isValid()
			}, jsts.operation.valid.IsValidOp.findPtNotNode = function(t, e, n) {
				for (var i = n.findEdge(e), o = i.getEdgeIntersectionList(), r = 0; r < t.length; r++) {
					var s = t[r];
					if (!o.isIntersection(s)) return s
				}
				return null
			}, jsts.operation.valid.IsValidOp.prototype.setSelfTouchingRingFormingHoleValid = function(t) {
				this.isSelfTouchingRingFormingHoleValid = t
			}, jsts.operation.valid.IsValidOp.prototype.isValid = function() {
				return this.checkValid(this.parentGeometry), null == this.validErr
			}, jsts.operation.valid.IsValidOp.prototype.getValidationError = function() {
				return this.checkValid(this.parentGeometry), this.validErr
			}, jsts.operation.valid.IsValidOp.prototype.checkValid = function(t) {
				if (this.validErr = null, !t.isEmpty()) if (t instanceof jsts.geom.Point) this.checkValidPoint(t);
				else if (t instanceof jsts.geom.MultiPoint) this.checkValidMultiPoint(t);
				else if (t instanceof jsts.geom.LinearRing) this.checkValidLinearRing(t);
				else if (t instanceof jsts.geom.LineString) this.checkValidLineString(t);
				else if (t instanceof jsts.geom.Polygon) this.checkValidPolygon(t);
				else if (t instanceof jsts.geom.MultiPolygon) this.checkValidMultiPolygon(t);
				else {
					if (!(t instanceof jsts.geom.GeometryCollection)) throw t.constructor;
					this.checkValidGeometryCollection(t)
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkValidPoint = function(t) {
				this.checkInvalidCoordinates(t.getCoordinates())
			}, jsts.operation.valid.IsValidOp.prototype.checkValidMultiPoint = function(t) {
				this.checkInvalidCoordinates(t.getCoordinates())
			}, jsts.operation.valid.IsValidOp.prototype.checkValidLineString = function(t) {
				if (this.checkInvalidCoordinates(t.getCoordinates()), null == this.validErr) {
					var e = new jsts.geomgraph.GeometryGraph(0, t);
					this.checkTooFewPoints(e)
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkValidLinearRing = function(t) {
				if (this.checkInvalidCoordinates(t.getCoordinates()), null == this.validErr && (this.checkClosedRing(t), null == this.validErr)) {
					var e = new jsts.geomgraph.GeometryGraph(0, t);
					if (this.checkTooFewPoints(e), null == this.validErr) {
						var n = new jsts.algorithm.RobustLineIntersector;
						e.computeSelfNodes(n, !0), this.checkNoSelfIntersectingRings(e)
					}
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkValidPolygon = function(t) {
				if (this.checkInvalidCoordinates(t), null == this.validErr && (this.checkClosedRings(t), null == this.validErr)) {
					var e = new jsts.geomgraph.GeometryGraph(0, t);
					this.checkTooFewPoints(e), null == this.validErr && (this.checkConsistentArea(e), null == this.validErr && (this.isSelfTouchingRingFormingHoleValid || (this.checkNoSelfIntersectingRings(e), null == this.validErr)) && (this.checkHolesInShell(t, e), null == this.validErr && (this.checkHolesNotNested(t, e), null == this.validErr && this.checkConnectedInteriors(e))))
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkValidMultiPolygon = function(t) {
				for (var e = t.getNumGeometries(), n = 0; e > n; n++) {
					var i = t.getGeometryN(n);
					if (this.checkInvalidCoordinates(i), null != this.validErr) return;
					if (this.checkClosedRings(i), null != this.validErr) return
				}
				var o = new jsts.geomgraph.GeometryGraph(0, t);
				if (this.checkTooFewPoints(o), null == this.validErr && (this.checkConsistentArea(o), null == this.validErr && (this.isSelfTouchingRingFormingHoleValid || (this.checkNoSelfIntersectingRings(o), null == this.validErr)))) {
					for (var n = 0; n < t.getNumGeometries(); n++) {
						var i = t.getGeometryN(n);
						if (this.checkHolesInShell(i, o), null != this.validErr) return
					}
					for (var n = 0; n < t.getNumGeometries(); n++) {
						var i = t.getGeometryN(n);
						if (this.checkHolesNotNested(i, o), null != this.validErr) return
					}
					this.checkShellsNotNested(t, o), null == this.validErr && this.checkConnectedInteriors(o)
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkValidGeometryCollection = function(t) {
				for (var e = 0; e < t.getNumGeometries(); e++) {
					var n = t.getGeometryN(e);
					if (this.checkValid(n), null != this.validErr) return
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkInvalidCoordinates = function(t) {
				if (t instanceof jsts.geom.Polygon) {
					var e = t;
					if (this.checkInvalidCoordinates(e.getExteriorRing().getCoordinates()), null != this.validErr) return;
					for (var n = 0; n < e.getNumInteriorRing(); n++) if (this.checkInvalidCoordinates(e.getInteriorRingN(n).getCoordinates()), null != this.validErr) return
				} else for (var i = t, n = 0; n < i.length; n++) if (!jsts.operation.valid.IsValidOp.isValid(i[n])) return void(this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.INVALID_COORDINATE, i[n]))
			}, jsts.operation.valid.IsValidOp.prototype.checkClosedRings = function(t) {
				if (this.checkClosedRing(t.getExteriorRing()), null == this.validErr) for (var e = 0; e < t.getNumInteriorRing(); e++) if (this.checkClosedRing(t.getInteriorRingN(e)), null != this.validErr) return
			}, jsts.operation.valid.IsValidOp.prototype.checkClosedRing = function(t) {
				if (!t.isClosed()) {
					var e = null;
					t.getNumPoints() >= 1 && (e = t.getCoordinateN(0)), this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.RING_NOT_CLOSED, e)
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkTooFewPoints = function(t) {
				return t.hasTooFewPoints ? void(this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.TOO_FEW_POINTS, t.getInvalidPoint())) : void 0
			}, jsts.operation.valid.IsValidOp.prototype.checkConsistentArea = function(t) {
				var e = new jsts.operation.valid.ConsistentAreaTester(t),
					n = e.isNodeConsistentArea();
				return n ? void(e.hasDuplicateRings() && (this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.DUPLICATE_RINGS, e.getInvalidPoint()))) : void(this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.SELF_INTERSECTION, e.getInvalidPoint()))
			}, jsts.operation.valid.IsValidOp.prototype.checkNoSelfIntersectingRings = function(t) {
				for (var e = t.getEdgeIterator(); e.hasNext();) {
					var n = e.next();
					if (this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()), null != this.validErr) return
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkNoSelfIntersectingRing = function(t) {
				for (var e = [], n = !0, i = t.iterator(); i.hasNext();) {
					var o = i.next();
					if (n) n = !1;
					else {
						if (e.indexOf(o.coord) >= 0) return void(this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.RING_SELF_INTERSECTION, o.coord));
						e.push(o.coord)
					}
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkHolesInShell = function(t, e) {
				for (var n = t.getExteriorRing(), i = new jsts.algorithm.MCPointInRing(n), o = 0; o < t.getNumInteriorRing(); o++) {
					var r = t.getInteriorRingN(o),
						s = jsts.operation.valid.IsValidOp.findPtNotNode(r.getCoordinates(), n, e);
					if (null == s) return;
					var a = !i.isInside(s);
					if (a) return void(this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.HOLE_OUTSIDE_SHELL, s))
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkHolesNotNested = function(t, e) {
				for (var n = new jsts.operation.valid.IndexedNestedRingTester(e), i = 0; i < t.getNumInteriorRing(); i++) {
					var o = t.getInteriorRingN(i);
					n.add(o)
				}
				var r = n.isNonNested();
				r || (this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.NESTED_HOLES, n.getNestedPoint()))
			}, jsts.operation.valid.IsValidOp.prototype.checkShellsNotNested = function(t, e) {
				for (var n = 0; n < t.getNumGeometries(); n++) for (var i = t.getGeometryN(n), o = i.getExteriorRing(), r = 0; r < t.getNumGeometries(); r++) if (n != r) {
					var s = t.getGeometryN(r);
					if (this.checkShellNotNested(o, s, e), null != this.validErr) return
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkShellNotNested = function(t, e, n) {
				var i = t.getCoordinates(),
					o = e.getExteriorRing(),
					r = o.getCoordinates(),
					s = jsts.operation.valid.IsValidOp.findPtNotNode(i, o, n);
				if (null != s) {
					var a = jsts.algorithm.CGAlgorithms.isPointInRing(s, r);
					if (a) {
						if (e.getNumInteriorRing() <= 0) return void(this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.NESTED_SHELLS, s));
						for (var l = null, u = 0; u < e.getNumInteriorRing(); u++) {
							var p = e.getInteriorRingN(u);
							if (l = this.checkShellInsideHole(t, p, n), null == l) return
						}
						this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.NESTED_SHELLS, l)
					}
				}
			}, jsts.operation.valid.IsValidOp.prototype.checkShellInsideHole = function(t, e, n) {
				var i = t.getCoordinates(),
					o = e.getCoordinates(),
					r = jsts.operation.valid.IsValidOp.findPtNotNode(i, e, n);
				if (null != r) {
					var s = jsts.algorithm.CGAlgorithms.isPointInRing(r, o);
					if (!s) return r
				}
				var a = jsts.operation.valid.IsValidOp.findPtNotNode(o, t, n);
				if (null != a) {
					var l = jsts.algorithm.CGAlgorithms.isPointInRing(a, i);
					return l ? a : null
				}
				return jsts.util.Assert.shouldNeverReachHere("points in shell and hole appear to be equal"), null
			}, jsts.operation.valid.IsValidOp.prototype.checkConnectedInteriors = function(t) {
				var e = new jsts.operation.valid.ConnectedInteriorTester(t);
				e.isInteriorsConnected() || (this.validErr = new jsts.operation.valid.TopologyValidationError(jsts.operation.valid.TopologyValidationError.DISCONNECTED_INTERIOR, e.getCoordinate()))
			}, jsts.algorithm.RobustDeterminant = function() {}, jsts.algorithm.RobustDeterminant.signOfDet2x2 = function(t, e, n, i) {
				var o, r, s, a;
				if (a = 0, o = 1, 0 === t || 0 === i) return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -o : o : n > 0 ? o : -o;
				if (0 === e || 0 === n) return i > 0 ? t > 0 ? o : -o : t > 0 ? -o : o;
				if (e > 0 ? i > 0 ? e > i && (o = -o, r = t, t = n, n = r, r = e, e = i, i = r) : -i >= e ? (o = -o, n = -n, i = -i) : (r = t, t = -n, n = r, r = e, e = -i, i = r) : i > 0 ? i >= -e ? (o = -o, t = -t, e = -e) : (r = -t, t = n, n = r, r = -e, e = i, i = r) : e >= i ? (t = -t, e = -e, n = -n, i = -i) : (o = -o, r = -t, t = -n, n = r, r = -e, e = -i, i = r), t > 0) {
					if (!(n > 0)) return o;
					if (t > n) return o
				} else {
					if (n > 0) return -o;
					if (!(t >= n)) return -o;
					o = -o, t = -t, n = -n
				}
				for (;;) {
					if (a += 1, s = Math.floor(n / t), n -= s * t, i -= s * e, 0 > i) return -o;
					if (i > e) return o;
					if (t > n + n) {
						if (i + i > e) return o
					} else {
						if (e > i + i) return -o;
						n = t - n, i = e - i, o = -o
					}
					if (0 === i) return 0 === n ? 0 : -o;
					if (0 === n) return o;
					if (s = Math.floor(t / n), t -= s * n, e -= s * i, 0 > e) return o;
					if (e > i) return -o;
					if (n > t + t) {
						if (e + e > i) return -o
					} else {
						if (i > e + e) return o;
						t = n - t, e = i - e, o = -o
					}
					if (0 === e) return 0 === t ? 0 : o;
					if (0 === t) return -o
				}
			}, jsts.algorithm.RobustDeterminant.orientationIndex = function(t, e, n) {
				var i = e.x - t.x,
					o = e.y - t.y,
					r = n.x - e.x,
					s = n.y - e.y;
				return jsts.algorithm.RobustDeterminant.signOfDet2x2(i, o, r, s)
			}, jsts.index.quadtree.NodeBase = function() {
				this.subnode = new Array(4), this.subnode[0] = null, this.subnode[1] = null, this.subnode[2] = null, this.subnode[3] = null, this.items = []
			}, jsts.index.quadtree.NodeBase.prototype.getSubnodeIndex = function(t, e) {
				var n = -1;
				return t.getMinX() >= e.x && (t.getMinY() >= e.y && (n = 3), t.getMaxY() <= e.y && (n = 1)), t.getMaxX() <= e.x && (t.getMinY() >= e.y && (n = 2), t.getMaxY() <= e.y && (n = 0)), n
			}, jsts.index.quadtree.NodeBase.prototype.getItems = function() {
				return this.items
			}, jsts.index.quadtree.NodeBase.prototype.hasItems = function() {
				return this.items.length > 0
			}, jsts.index.quadtree.NodeBase.prototype.add = function(t) {
				this.items.push(t)
			}, jsts.index.quadtree.NodeBase.prototype.remove = function(t, e) {
				if (!this.isSearchMatch(t)) return !1;
				var n = !1,
					i = 0;
				for (i; 4 > i; i++) if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {
					this.subnode[i].isPrunable() && (this.subnode[i] = null);
					break
				}
				if (n) return n;
				if (-1 !== this.items.indexOf(e)) {
					for (var i = this.items.length - 1; i >= 0; i--) this.items[i] === e && this.items.splice(i, 1);
					n = !0
				}
				return n
			}, jsts.index.quadtree.NodeBase.prototype.isPrunable = function() {
				return !(this.hasChildren() || this.hasItems())
			}, jsts.index.quadtree.NodeBase.prototype.hasChildren = function() {
				var t = 0;
				for (t; 4 > t; t++) if (null !== this.subnode[t]) return !0;
				return !1
			}, jsts.index.quadtree.NodeBase.prototype.isEmpty = function() {
				var t = !0;
				this.items.length > 0 && (t = !1);
				var e = 0;
				for (e; 4 > e; e++) null !== this.subnode[e] && (this.subnode[e].isEmpty() || (t = !1));
				return t
			}, jsts.index.quadtree.NodeBase.prototype.addAllItems = function(t) {
				t = t.concat(this.items);
				var e = 0;
				for (e; 4 > e; e++) null !== this.subnode[e] && (t = this.subnode[e].addAllItems(t));
				return t
			}, jsts.index.quadtree.NodeBase.prototype.addAllItemsFromOverlapping = function(t, e) {
				if (this.isSearchMatch(t)) {
					e = e.concat(this.items);
					var n = 0;
					for (n; 4 > n; n++) null !== this.subnode[n] && (e = this.subnode[n].addAllItemsFromOverlapping(t, e))
				}
			}, jsts.index.quadtree.NodeBase.prototype.visit = function(t, e) {
				if (this.isSearchMatch(t)) {
					this.visitItems(t, e);
					var n = 0;
					for (n; 4 > n; n++) null !== this.subnode[n] && this.subnode[n].visit(t, e)
				}
			}, jsts.index.quadtree.NodeBase.prototype.visitItems = function(t, e) {
				var n = 0,
					i = this.items.length;
				for (n; i > n; n++) e.visitItem(this.items[n])
			}, jsts.index.quadtree.NodeBase.prototype.depth = function() {
				var t, e = 0,
					n = 0;
				for (n; 4 > n; n++) null !== this.subnode[n] && (t = this.subnode[n].depth(), t > e && (e = t));
				return e + 1
			}, jsts.index.quadtree.NodeBase.prototype.size = function() {
				var t = 0,
					e = 0;
				for (e; 4 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].size());
				return t + this.items.length
			}, jsts.index.quadtree.NodeBase.prototype.getNodeCount = function() {
				var t = 0,
					e = 0;
				for (e; 4 > e; e++) null !== this.subnode[e] && (t += this.subnode[e].size());
				return t + 1
			}, jsts.index.quadtree.Node = function(t, e) {
				jsts.index.quadtree.NodeBase.prototype.constructor.apply(this, arguments), this.env = t, this.level = e, this.centre = new jsts.geom.Coordinate, this.centre.x = (t.getMinX() + t.getMaxX()) / 2, this.centre.y = (t.getMinY() + t.getMaxY()) / 2
			}, jsts.index.quadtree.Node.prototype = new jsts.index.quadtree.NodeBase, jsts.index.quadtree.Node.createNode = function(t) {
				var e, n;
				return e = new jsts.index.quadtree.Key(t), n = new jsts.index.quadtree.Node(e.getEnvelope(), e.getLevel())
			}, jsts.index.quadtree.Node.createExpanded = function(t, e) {
				var n, i = new jsts.geom.Envelope(e);
				return null !== t && i.expandToInclude(t.env), n = jsts.index.quadtree.Node.createNode(i), null !== t && n.insertNode(t), n
			}, jsts.index.quadtree.Node.prototype.getEnvelope = function() {
				return this.env
			}, jsts.index.quadtree.Node.prototype.isSearchMatch = function(t) {
				return this.env.intersects(t)
			}, jsts.index.quadtree.Node.prototype.getNode = function(t) {
				var e, n = this.getSubnodeIndex(t, this.centre);
				return -1 !== n ? (e = this.getSubnode(n), e.getNode(t)) : this
			}, jsts.index.quadtree.Node.prototype.find = function(t) {
				var e, n = this.getSubnodeIndex(t, this.centre);
				return -1 === n ? this : null !== this.subnode[n] ? (e = this.subnode[n], e.find(t)) : this
			}, jsts.index.quadtree.Node.prototype.insertNode = function(t) {
				var e, n = this.getSubnodeIndex(t.env, this.centre);
				t.level === this.level - 1 ? this.subnode[n] = t : (e = this.createSubnode(n), e.insertNode(t), this.subnode[n] = e)
			}, jsts.index.quadtree.Node.prototype.getSubnode = function(t) {
				return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t]
			}, jsts.index.quadtree.Node.prototype.createSubnode = function(t) {
				var e, n, i = 0,
					o = 0,
					r = 0,
					s = 0;
				switch (t) {
				case 0:
					i = this.env.getMinX(), o = this.centre.x, r = this.env.getMinY(), s = this.centre.y;
					break;
				case 1:
					i = this.centre.x, o = this.env.getMaxX(), r = this.env.getMinY(), s = this.centre.y;
					break;
				case 2:
					i = this.env.getMinX(), o = this.centre.x, r = this.centre.y, s = this.env.getMaxY();
					break;
				case 3:
					i = this.centre.x, o = this.env.getMaxX(), r = this.centre.y, s = this.env.getMaxY()
				}
				return e = new jsts.geom.Envelope(i, o, r, s), n = new jsts.index.quadtree.Node(e, this.level - 1)
			}, function() {
				jsts.triangulate.quadedge.QuadEdge = function() {
					this.rot = null, this.vertex = null, this.next = null, this.data = null
				};
				var t = jsts.triangulate.quadedge.QuadEdge;
				jsts.triangulate.quadedge.QuadEdge.makeEdge = function(e, n) {
					var i, o, r, s, a;
					return i = new t, o = new t, r = new t, s = new t, i.rot = o, o.rot = r, r.rot = s, s.rot = i, i.setNext(i), o.setNext(s), r.setNext(r), s.setNext(o), a = i, a.setOrig(e), a.setDest(n), a
				}, jsts.triangulate.quadedge.QuadEdge.connect = function(e, n) {
					var i = t.makeEdge(e.dest(), n.orig());
					return t.splice(i, e.lNext()), t.splice(i.sym(), n), i
				}, jsts.triangulate.quadedge.QuadEdge.splice = function(t, e) {
					var n, i, o, r, s, a;
					n = t.oNext().rot, i = e.oNext().rot, o = e.oNext(), r = t.oNext(), s = i.oNext(), a = n.oNext(), t.setNext(o), e.setNext(r), n.setNext(s), i.setNext(a)
				}, jsts.triangulate.quadedge.QuadEdge.swap = function(e) {
					var n, i;
					n = e.oPrev(), i = e.sym().oPrev(), t.splice(e, n), t.splice(e.sym(), i), t.splice(e, n.lNext()), t.splice(e.sym(), i.lNext()), e.setOrig(n.dest()), e.setDest(i.dest())
				}, jsts.triangulate.quadedge.QuadEdge.prototype.getPrimary = function() {
					return this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0 ? this : this.sym()
				}, jsts.triangulate.quadedge.QuadEdge.prototype.setData = function(t) {
					this.data = t
				}, jsts.triangulate.quadedge.QuadEdge.prototype.getData = function() {
					return this.data
				}, jsts.triangulate.quadedge.QuadEdge.prototype.delete_jsts = function() {
					this.rot = null
				}, jsts.triangulate.quadedge.QuadEdge.prototype.isLive = function() {
					return null !== this.rot
				}, jsts.triangulate.quadedge.QuadEdge.prototype.setNext = function(t) {
					this.next = t
				}, jsts.triangulate.quadedge.QuadEdge.prototype.invRot = function() {
					return this.rot.sym()
				}, jsts.triangulate.quadedge.QuadEdge.prototype.sym = function() {
					return this.rot.rot
				}, jsts.triangulate.quadedge.QuadEdge.prototype.oNext = function() {
					return this.next
				}, jsts.triangulate.quadedge.QuadEdge.prototype.oPrev = function() {
					return this.rot.next.rot
				}, jsts.triangulate.quadedge.QuadEdge.prototype.dNext = function() {
					return this.sym().oNext().sym()
				}, jsts.triangulate.quadedge.QuadEdge.prototype.dPrev = function() {
					return this.invRot().oNext().invRot()
				}, jsts.triangulate.quadedge.QuadEdge.prototype.lNext = function() {
					return this.invRot().oNext().rot
				}, jsts.triangulate.quadedge.QuadEdge.prototype.lPrev = function() {
					return this.next.sym()
				}, jsts.triangulate.quadedge.QuadEdge.prototype.rNext = function() {
					return this.rot.next.invRot()
				}, jsts.triangulate.quadedge.QuadEdge.prototype.rPrev = function() {
					return this.sym().oNext()
				}, jsts.triangulate.quadedge.QuadEdge.prototype.setOrig = function(t) {
					this.vertex = t
				}, jsts.triangulate.quadedge.QuadEdge.prototype.setDest = function(t) {
					this.sym().setOrig(t)
				}, jsts.triangulate.quadedge.QuadEdge.prototype.orig = function() {
					return this.vertex
				}, jsts.triangulate.quadedge.QuadEdge.prototype.dest = function() {
					return this.sym().orig()
				}, jsts.triangulate.quadedge.QuadEdge.prototype.getLength = function() {
					return this.orig().getCoordinate().distance(dest().getCoordinate())
				}, jsts.triangulate.quadedge.QuadEdge.prototype.equalsNonOriented = function(t) {
					return !!this.equalsOriented(t) || !! this.equalsOriented(t.sym())
				}, jsts.triangulate.quadedge.QuadEdge.prototype.equalsOriented = function(t) {
					return !(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate()) || !this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))
				}, jsts.triangulate.quadedge.QuadEdge.prototype.toLineSegment = function() {
					return new jsts.geom.LineSegment(this.vertex.getCoordinate(), this.dest().getCoordinate())
				}, jsts.triangulate.quadedge.QuadEdge.prototype.toString = function() {
					var t, e;
					return t = this.vertex.getCoordinate(), e = this.dest().getCoordinate(), jsts.io.WKTWriter.toLineString(t, e)
				}
			}(), function() {
				var t = jsts.util.Assert;
				jsts.geomgraph.EdgeEnd = function(t, e, n, i) {
					this.edge = t, e && n && this.init(e, n), i && (this.label = i || null)
				}, jsts.geomgraph.EdgeEnd.prototype.edge = null, jsts.geomgraph.EdgeEnd.prototype.label = null, jsts.geomgraph.EdgeEnd.prototype.node = null, jsts.geomgraph.EdgeEnd.prototype.p0 = null, jsts.geomgraph.EdgeEnd.prototype.p1 = null, jsts.geomgraph.EdgeEnd.prototype.dx = null, jsts.geomgraph.EdgeEnd.prototype.dy = null, jsts.geomgraph.EdgeEnd.prototype.quadrant = null, jsts.geomgraph.EdgeEnd.prototype.init = function(e, n) {
					this.p0 = e, this.p1 = n, this.dx = n.x - e.x, this.dy = n.y - e.y, this.quadrant = jsts.geomgraph.Quadrant.quadrant(this.dx, this.dy), t.isTrue(!(0 === this.dx && 0 === this.dy), "EdgeEnd with identical endpoints found")
				}, jsts.geomgraph.EdgeEnd.prototype.getEdge = function() {
					return this.edge
				}, jsts.geomgraph.EdgeEnd.prototype.getLabel = function() {
					return this.label
				}, jsts.geomgraph.EdgeEnd.prototype.getCoordinate = function() {
					return this.p0
				}, jsts.geomgraph.EdgeEnd.prototype.getDirectedCoordinate = function() {
					return this.p1
				}, jsts.geomgraph.EdgeEnd.prototype.getQuadrant = function() {
					return this.quadrant
				}, jsts.geomgraph.EdgeEnd.prototype.getDx = function() {
					return this.dx
				}, jsts.geomgraph.EdgeEnd.prototype.getDy = function() {
					return this.dy
				}, jsts.geomgraph.EdgeEnd.prototype.setNode = function(t) {
					this.node = t
				}, jsts.geomgraph.EdgeEnd.prototype.getNode = function() {
					return this.node
				}, jsts.geomgraph.EdgeEnd.prototype.compareTo = function(t) {
					return this.compareDirection(t)
				}, jsts.geomgraph.EdgeEnd.prototype.compareDirection = function(t) {
					return this.dx === t.dx && this.dy === t.dy ? 0 : this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : jsts.algorithm.CGAlgorithms.computeOrientation(t.p0, t.p1, this.p1)
				}, jsts.geomgraph.EdgeEnd.prototype.computeLabel = function() {}
			}(), jsts.operation.buffer.RightmostEdgeFinder = function() {}, jsts.operation.buffer.RightmostEdgeFinder.prototype.minIndex = -1, jsts.operation.buffer.RightmostEdgeFinder.prototype.minCoord = null, jsts.operation.buffer.RightmostEdgeFinder.prototype.minDe = null, jsts.operation.buffer.RightmostEdgeFinder.prototype.orientedDe = null, jsts.operation.buffer.RightmostEdgeFinder.prototype.getEdge = function() {
				return this.orientedDe
			}, jsts.operation.buffer.RightmostEdgeFinder.prototype.getCoordinate = function() {
				return this.minCoord
			}, jsts.operation.buffer.RightmostEdgeFinder.prototype.findEdge = function(t) {
				for (var e = t.iterator(); e.hasNext();) {
					var n = e.next();
					n.isForward() && this.checkForRightmostCoordinate(n)
				}
				jsts.util.Assert.isTrue(0 !== this.minIndex || this.minCoord.equals(this.minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this.minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this.orientedDe = this.minDe;
				var i = this.getRightmostSide(this.minDe, this.minIndex);
				i == jsts.geomgraph.Position.LEFT && (this.orientedDe = this.minDe.getSym())
			}, jsts.operation.buffer.RightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function() {
				var t = this.minDe.getNode(),
					e = t.getEdges();
				this.minDe = e.getRightmostEdge(), this.minDe.isForward() || (this.minDe = this.minDe.getSym(), this.minIndex = this.minDe.getEdge().getCoordinates().length - 1)
			}, jsts.operation.buffer.RightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function() {
				var t = this.minDe.getEdge().getCoordinates();
				jsts.util.Assert.isTrue(this.minIndex > 0 && this.minIndex < t.length, "rightmost point expected to be interior vertex of edge");
				var e = t[this.minIndex - 1],
					n = t[this.minIndex + 1],
					i = jsts.algorithm.CGAlgorithms.computeOrientation(this.minCoord, n, e),
					o = !1;
				e.y < this.minCoord.y && n.y < this.minCoord.y && i === jsts.algorithm.CGAlgorithms.COUNTERCLOCKWISE ? o = !0 : e.y > this.minCoord.y && n.y > this.minCoord.y && i === jsts.algorithm.CGAlgorithms.CLOCKWISE && (o = !0), o && (this.minIndex = this.minIndex - 1)
			}, jsts.operation.buffer.RightmostEdgeFinder.prototype.checkForRightmostCoordinate = function(t) {
				for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++)(null === this.minCoord || e[n].x > this.minCoord.x) && (this.minDe = t, this.minIndex = n, this.minCoord = e[n])
			}, jsts.operation.buffer.RightmostEdgeFinder.prototype.getRightmostSide = function(t, e) {
				var n = this.getRightmostSideOfSegment(t, e);
				return 0 > n && (n = this.getRightmostSideOfSegment(t, e - 1)), 0 > n && (this.minCoord = null, this.checkForRightmostCoordinate(t)), n
			}, jsts.operation.buffer.RightmostEdgeFinder.prototype.getRightmostSideOfSegment = function(t, e) {
				var n = t.getEdge(),
					i = n.getCoordinates();
				if (0 > e || e + 1 >= i.length) return -1;
				if (i[e].y == i[e + 1].y) return -1;
				var o = jsts.geomgraph.Position.LEFT;
				return i[e].y < i[e + 1].y && (o = jsts.geomgraph.Position.RIGHT), o
			}, function() {
				jsts.triangulate.IncrementalDelaunayTriangulator = function(t) {
					this.subdiv = t, this.isUsingTolerance = t.getTolerance() > 0
				}, jsts.triangulate.IncrementalDelaunayTriangulator.prototype.insertSites = function(t) {
					var e, n = 0,
						i = t.length;
					for (n; i > n; n++) e = t[n], this.insertSite(e)
				}, jsts.triangulate.IncrementalDelaunayTriangulator.prototype.insertSite = function(t) {
					var e, n, i, o;
					if (e = this.subdiv.locate(t), this.subdiv.isVertexOfEdge(e, t)) return e;
					this.subdiv.isOnEdge(e, t.getCoordinate()) && (e = e.oPrev(), this.subdiv.delete_jsts(e.oNext())), n = this.subdiv.makeEdge(e.orig(), t), jsts.triangulate.quadedge.QuadEdge.splice(n, e), i = n;
					do n = this.subdiv.connect(e, n.sym()), e = n.oPrev();
					while (e.lNext() != i);
					for (;;) if (o = e.oPrev(), o.dest().rightOf(e) && t.isInCircle(e.orig(), o.dest(), e.dest())) jsts.triangulate.quadedge.QuadEdge.swap(e), e = e.oPrev();
					else {
						if (e.oNext() == i) return n;
						e = e.oNext().lPrev()
					}
				}
			}(), jsts.algorithm.CentroidArea = function() {
				this.basePt = null, this.triangleCent3 = new jsts.geom.Coordinate, this.centSum = new jsts.geom.Coordinate, this.cg3 = new jsts.geom.Coordinate
			}, jsts.algorithm.CentroidArea.prototype.basePt = null, jsts.algorithm.CentroidArea.prototype.triangleCent3 = null, jsts.algorithm.CentroidArea.prototype.areasum2 = 0, jsts.algorithm.CentroidArea.prototype.cg3 = null, jsts.algorithm.CentroidArea.prototype.centSum = null, jsts.algorithm.CentroidArea.prototype.totalLength = 0, jsts.algorithm.CentroidArea.prototype.add = function(t) {
				if (t instanceof jsts.geom.Polygon) {
					var e = t;
					this.setBasePoint(e.getExteriorRing().getCoordinateN(0)), this.add3(e)
				} else if (t instanceof jsts.geom.GeometryCollection || t instanceof jsts.geom.MultiPolygon) for (var n = t, i = 0; i < n.getNumGeometries(); i++) this.add(n.getGeometryN(i));
				else t instanceof Array && this.add2(t)
			}, jsts.algorithm.CentroidArea.prototype.add2 = function(t) {
				this.setBasePoint(t[0]), this.addShell(t)
			}, jsts.algorithm.CentroidArea.prototype.getCentroid = function() {
				var t = new jsts.geom.Coordinate;
				return Math.abs(this.areasum2) > 0 ? (t.x = this.cg3.x / 3 / this.areasum2, t.y = this.cg3.y / 3 / this.areasum2) : (t.x = this.centSum.x / this.totalLength, t.y = this.centSum.y / this.totalLength), t
			}, jsts.algorithm.CentroidArea.prototype.setBasePoint = function(t) {
				null == this.basePt && (this.basePt = t)
			}, jsts.algorithm.CentroidArea.prototype.add3 = function(t) {
				this.addShell(t.getExteriorRing().getCoordinates());
				for (var e = 0; e < t.getNumInteriorRing(); e++) this.addHole(t.getInteriorRingN(e).getCoordinates())
			}, jsts.algorithm.CentroidArea.prototype.addShell = function(t) {
				for (var e = !jsts.algorithm.CGAlgorithms.isCCW(t), n = 0; n < t.length - 1; n++) this.addTriangle(this.basePt, t[n], t[n + 1], e);
				this.addLinearSegments(t)
			}, jsts.algorithm.CentroidArea.prototype.addHole = function(t) {
				for (var e = jsts.algorithm.CGAlgorithms.isCCW(t), n = 0; n < t.length - 1; n++) this.addTriangle(this.basePt, t[n], t[n + 1], e);
				this.addLinearSegments(t)
			}, jsts.algorithm.CentroidArea.prototype.addTriangle = function(t, e, n, i) {
				var o = i ? 1 : -1;
				jsts.algorithm.CentroidArea.centroid3(t, e, n, this.triangleCent3);
				var r = jsts.algorithm.CentroidArea.area2(t, e, n);
				this.cg3.x += o * r * this.triangleCent3.x, this.cg3.y += o * r * this.triangleCent3.y, this.areasum2 += o * r
			}, jsts.algorithm.CentroidArea.centroid3 = function(t, e, n, i) {
				i.x = t.x + e.x + n.x, i.y = t.y + e.y + n.y
			}, jsts.algorithm.CentroidArea.area2 = function(t, e, n) {
				return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y)
			}, jsts.algorithm.CentroidArea.prototype.addLinearSegments = function(t) {
				for (var e = 0; e < t.length - 1; e++) {
					var n = t[e].distance(t[e + 1]);
					this.totalLength += n;
					var i = (t[e].x + t[e + 1].x) / 2;
					this.centSum.x += n * i;
					var o = (t[e].y + t[e + 1].y) / 2;
					this.centSum.y += n * o
				}
			}, jsts.geomgraph.index.SweepLineSegment = function(t, e) {
				this.edge = t, this.ptIndex = e, this.pts = t.getCoordinates()
			}, jsts.geomgraph.index.SweepLineSegment.prototype.edge = null, jsts.geomgraph.index.SweepLineSegment.prototype.pts = null, jsts.geomgraph.index.SweepLineSegment.prototype.ptIndex = null, jsts.geomgraph.index.SweepLineSegment.prototype.getMinX = function() {
				var t = this.pts[this.ptIndex].x,
					e = this.pts[this.ptIndex + 1].x;
				return e > t ? t : e
			}, jsts.geomgraph.index.SweepLineSegment.prototype.getMaxX = function() {
				var t = this.pts[this.ptIndex].x,
					e = this.pts[this.ptIndex + 1].x;
				return t > e ? t : e
			}, jsts.geomgraph.index.SweepLineSegment.prototype.computeIntersections = function(t, e) {
				e.addIntersections(this.edge, this.ptIndex, t.edge, t.ptIndex)
			}, jsts.index.quadtree.Root = function() {
				jsts.index.quadtree.NodeBase.prototype.constructor.apply(this, arguments), this.origin = new jsts.geom.Coordinate(0, 0)
			}, jsts.index.quadtree.Root.prototype = new jsts.index.quadtree.NodeBase, jsts.index.quadtree.Root.prototype.insert = function(t, e) {
				var n = this.getSubnodeIndex(t, this.origin);
				if (-1 === n) return void this.add(e);
				var i = this.subnode[n];
				if (null === i || !i.getEnvelope().contains(t)) {
					var o = jsts.index.quadtree.Node.createExpanded(i, t);
					this.subnode[n] = o
				}
				this.insertContained(this.subnode[n], t, e)
			}, jsts.index.quadtree.Root.prototype.insertContained = function(t, e, n) {
				var i, o, r;
				i = jsts.index.IntervalSize.isZeroWidth(e.getMinX(), e.getMaxX()), o = jsts.index.IntervalSize.isZeroWidth(e.getMinY(), e.getMaxY()), r = i || o ? t.find(e) : t.getNode(e), r.add(n)
			}, jsts.index.quadtree.Root.prototype.isSearchMatch = function() {
				return !0
			}, jsts.geomgraph.index.MonotoneChainIndexer = function() {}, jsts.geomgraph.index.MonotoneChainIndexer.toIntArray = function(t) {
				for (var e = [], n = t.iterator(); n.hasNext();) {
					var i = n.next();
					e.push(i)
				}
				return e
			}, jsts.geomgraph.index.MonotoneChainIndexer.prototype.getChainStartIndices = function(t) {
				var e = 0,
					n = new javascript.util.ArrayList;
				n.add(e);
				do {
					var i = this.findChainEnd(t, e);
					n.add(i), e = i
				} while (e < t.length - 1);
				var o = jsts.geomgraph.index.MonotoneChainIndexer.toIntArray(n);
				return o
			}, jsts.geomgraph.index.MonotoneChainIndexer.prototype.findChainEnd = function(t, e) {
				for (var n = jsts.geomgraph.Quadrant.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length;) {
					var o = jsts.geomgraph.Quadrant.quadrant(t[i - 1], t[i]);
					if (o != n) break;
					i++
				}
				return i - 1
			}, jsts.noding.IntersectionAdder = function(t) {
				this.li = t
			}, jsts.noding.IntersectionAdder.prototype = new jsts.noding.SegmentIntersector, jsts.noding.IntersectionAdder.constructor = jsts.noding.IntersectionAdder, jsts.noding.IntersectionAdder.isAdjacentSegments = function(t, e) {
				return 1 === Math.abs(t - e)
			}, jsts.noding.IntersectionAdder.prototype._hasIntersection = !1, jsts.noding.IntersectionAdder.prototype.hasProper = !1, jsts.noding.IntersectionAdder.prototype.hasProperInterior = !1, jsts.noding.IntersectionAdder.prototype.hasInterior = !1, jsts.noding.IntersectionAdder.prototype.properIntersectionPoint = null, jsts.noding.IntersectionAdder.prototype.li = null, jsts.noding.IntersectionAdder.prototype.isSelfIntersection = null, jsts.noding.IntersectionAdder.prototype.numIntersections = 0, jsts.noding.IntersectionAdder.prototype.numInteriorIntersections = 0, jsts.noding.IntersectionAdder.prototype.numProperIntersections = 0, jsts.noding.IntersectionAdder.prototype.numTests = 0, jsts.noding.IntersectionAdder.prototype.getLineIntersector = function() {
				return this.li
			}, jsts.noding.IntersectionAdder.prototype.getProperIntersectionPoint = function() {
				return this.properIntersectionPoint
			}, jsts.noding.IntersectionAdder.prototype.hasIntersection = function() {
				return this._hasIntersection
			}, jsts.noding.IntersectionAdder.prototype.hasProperIntersection = function() {
				return this.hasProper
			}, jsts.noding.IntersectionAdder.prototype.hasProperInteriorIntersection = function() {
				return this.hasProperInterior
			}, jsts.noding.IntersectionAdder.prototype.hasInteriorIntersection = function() {
				return this.hasInterior
			}, jsts.noding.IntersectionAdder.prototype.isTrivialIntersection = function(t, e, n, i) {
				if (t == n && 1 == this.li.getIntersectionNum()) {
					if (jsts.noding.IntersectionAdder.isAdjacentSegments(e, i)) return !0;
					if (t.isClosed()) {
						var o = t.size() - 1;
						if (0 === e && i === o || 0 === i && e === o) return !0
					}
				}
				return !1
			}, jsts.noding.IntersectionAdder.prototype.processIntersections = function(t, e, n, i) {
				if (t !== n || e !== i) {
					this.numTests++;
					var o = t.getCoordinates()[e],
						r = t.getCoordinates()[e + 1],
						s = n.getCoordinates()[i],
						a = n.getCoordinates()[i + 1];
					this.li.computeIntersection(o, r, s, a), this.li.hasIntersection() && (this.numIntersections++, this.li.isInteriorIntersection() && (this.numInteriorIntersections++, this.hasInterior = !0), this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1), this.li.isProper() && (this.numProperIntersections++, this.hasProper = !0, this.hasProperInterior = !0)))
				}
			}, jsts.noding.IntersectionAdder.prototype.isDone = function() {
				return !1
			}, jsts.operation.union.CascadedPolygonUnion = function(t) {
				this.inputPolys = t
			}, jsts.operation.union.CascadedPolygonUnion.union = function(t) {
				var e = new jsts.operation.union.CascadedPolygonUnion(t);
				return e.union()
			}, jsts.operation.union.CascadedPolygonUnion.prototype.inputPolys, jsts.operation.union.CascadedPolygonUnion.prototype.geomFactory = null, jsts.operation.union.CascadedPolygonUnion.prototype.STRTREE_NODE_CAPACITY = 4, jsts.operation.union.CascadedPolygonUnion.prototype.union = function() {
				if (0 === this.inputPolys.length) return null;
				this.geomFactory = this.inputPolys[0].getFactory();
				for (var t = new jsts.index.strtree.STRtree(this.STRTREE_NODE_CAPACITY), e = 0, n = this.inputPolys.length; n > e; e++) {
					var i = this.inputPolys[e];
					t.insert(i.getEnvelopeInternal(), i)
				}
				var o = t.itemsTree(),
					r = this.unionTree(o);
				return r
			}, jsts.operation.union.CascadedPolygonUnion.prototype.unionTree = function(t) {
				var e = this.reduceToGeometries(t),
					n = this.binaryUnion(e);
				return n
			}, jsts.operation.union.CascadedPolygonUnion.prototype.binaryUnion = function(t, e, n) {
				if (e = e || 0, n = n || t.length, 1 >= n - e) {
					var i = this.getGeometry(t, e);
					return this.unionSafe(i, null)
				}
				if (n - e === 2) return this.unionSafe(this.getGeometry(t, e), this.getGeometry(t, e + 1));
				var o = parseInt((n + e) / 2),
					i = this.binaryUnion(t, e, o),
					r = this.binaryUnion(t, o, n);
				return this.unionSafe(i, r)
			}, jsts.operation.union.CascadedPolygonUnion.prototype.getGeometry = function(t, e) {
				return e >= t.length ? null : t[e]
			}, jsts.operation.union.CascadedPolygonUnion.prototype.reduceToGeometries = function(t) {
				for (var e = [], n = 0, i = t.length; i > n; n++) {
					var o = t[n],
						r = null;
					o instanceof Array ? r = this.unionTree(o) : o instanceof jsts.geom.Geometry && (r = o), e.push(r)
				}
				return e
			}, jsts.operation.union.CascadedPolygonUnion.prototype.unionSafe = function(t, e) {
				return null === t && null === e ? null : null === t ? e.clone() : null === e ? t.clone() : this.unionOptimized(t, e)
			}, jsts.operation.union.CascadedPolygonUnion.prototype.unionOptimized = function(t, e) {
				var n = t.getEnvelopeInternal(),
					i = e.getEnvelopeInternal();
				if (!n.intersects(i)) {
					var o = jsts.geom.util.GeometryCombiner.combine(t, e);
					return o
				}
				if (t.getNumGeometries <= 1 && e.getNumGeometries <= 1) return this.unionActual(t, e);
				var r = n.intersection(i);
				return this.unionUsingEnvelopeIntersection(t, e, r)
			}, jsts.operation.union.CascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function(t, e, n) {
				var i = new javascript.util.ArrayList,
					o = this.extractByEnvelope(n, t, i),
					r = this.extractByEnvelope(n, e, i),
					s = this.unionActual(o, r);
				i.add(s);
				var a = jsts.geom.util.GeometryCombiner.combine(i);
				return a
			}, jsts.operation.union.CascadedPolygonUnion.prototype.extractByEnvelope = function(t, e, n) {
				for (var i = new javascript.util.ArrayList, o = 0; o < e.getNumGeometries(); o++) {
					var r = e.getGeometryN(o);
					r.getEnvelopeInternal().intersects(t) ? i.add(r) : n.add(r)
				}
				return this.geomFactory.buildGeometry(i)
			}, jsts.operation.union.CascadedPolygonUnion.prototype.unionActual = function(t, e) {
				return t.union(e)
			}, function() {
				jsts.geom.MultiPoint = function(t, e) {
					this.geometries = t || [], this.factory = e
				}, jsts.geom.MultiPoint.prototype = new jsts.geom.GeometryCollection, jsts.geom.MultiPoint.constructor = jsts.geom.MultiPoint, jsts.geom.MultiPoint.prototype.getBoundary = function() {
					return this.getFactory().createGeometryCollection(null)
				}, jsts.geom.MultiPoint.prototype.getGeometryN = function(t) {
					return this.geometries[t]
				}, jsts.geom.MultiPoint.prototype.equalsExact = function(t, e) {
					return !!this.isEquivalentClass(t) && jsts.geom.GeometryCollection.prototype.equalsExact.call(this, t, e)
				}, jsts.geom.MultiPoint.prototype.CLASS_NAME = "jsts.geom.MultiPoint"
			}(), jsts.operation.buffer.OffsetCurveBuilder = function(t, e) {
				this.precisionModel = t, this.bufParams = e
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.distance = 0, jsts.operation.buffer.OffsetCurveBuilder.prototype.precisionModel = null, jsts.operation.buffer.OffsetCurveBuilder.prototype.bufParams = null, jsts.operation.buffer.OffsetCurveBuilder.prototype.getBufferParameters = function() {
				return this.bufParams
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.getLineCurve = function(t, e) {
				if (this.distance = e, this.distance < 0 && !this.bufParams.isSingleSided()) return null;
				if (0 == this.distance) return null;
				var n = Math.abs(this.distance),
					i = this.getSegGen(n);
				if (t.length <= 1) this.computePointCurve(t[0], i);
				else if (this.bufParams.isSingleSided()) {
					var o = 0 > e;
					this.computeSingleSidedBufferCurve(t, o, i)
				} else this.computeLineBufferCurve(t, i);
				var r = i.getCoordinates();
				return r
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.getRingCurve = function(t, e, n) {
				if (this.distance = n, t.length <= 2) return this.getLineCurve(t, n);
				if (0 == this.distance) return jsts.operation.buffer.OffsetCurveBuilder.copyCoordinates(t);
				var i = this.getSegGen(this.distance);
				return this.computeRingBufferCurve(t, e, i), i.getCoordinates()
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.getOffsetCurve = function(t, e) {
				if (this.distance = e, 0 === this.distance) return null;
				var n = this.distance < 0,
					i = Math.abs(this.distance),
					o = this.getSegGen(i);
				t.length <= 1 ? this.computePointCurve(t[0], o) : this.computeOffsetCurve(t, n, o);
				var r = o.getCoordinates();
				return n && r.reverse(), r
			}, jsts.operation.buffer.OffsetCurveBuilder.copyCoordinates = function(t) {
				for (var e = [], n = 0; n < t.length; n++) e.push(t[n].clone());
				return e
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.getSegGen = function(t) {
				return new jsts.operation.buffer.OffsetSegmentGenerator(this.precisionModel, this.bufParams, t)
			}, jsts.operation.buffer.OffsetCurveBuilder.SIMPLIFY_FACTOR = 100, jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance = function(t) {
				return t / jsts.operation.buffer.OffsetCurveBuilder.SIMPLIFY_FACTOR
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.computePointCurve = function(t, e) {
				switch (this.bufParams.getEndCapStyle()) {
				case jsts.operation.buffer.BufferParameters.CAP_ROUND:
					e.createCircle(t);
					break;
				case jsts.operation.buffer.BufferParameters.CAP_SQUARE:
					e.createSquare(t)
				}
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.computeLineBufferCurve = function(t, e) {
				var n = jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance(this.distance),
					i = jsts.operation.buffer.BufferInputLineSimplifier.simplify(t, n),
					o = i.length - 1;
				e.initSideSegments(i[0], i[1], jsts.geomgraph.Position.LEFT);
				for (var r = 2; o >= r; r++) e.addNextSegment(i[r], !0);
				e.addLastSegment(), e.addLineEndCap(i[o - 1], i[o]);
				var s = jsts.operation.buffer.BufferInputLineSimplifier.simplify(t, -n),
					a = s.length - 1;
				e.initSideSegments(s[a], s[a - 1], jsts.geomgraph.Position.LEFT);
				for (var r = a - 2; r >= 0; r--) e.addNextSegment(s[r], !0);
				e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing()
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function(t, e, n) {
				var i = jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance(this.distance);
				if (e) {
					n.addSegments(t, !0);
					var o = jsts.operation.buffer.BufferInputLineSimplifier.simplify(t, -i),
						r = o.length - 1;
					n.initSideSegments(o[r], o[r - 1], jsts.geomgraph.Position.LEFT), n.addFirstSegment();
					for (var s = r - 2; s >= 0; s--) n.addNextSegment(o[s], !0)
				} else {
					n.addSegments(t, !1);
					var a = jsts.operation.buffer.BufferInputLineSimplifier.simplify(t, i),
						l = a.length - 1;
					n.initSideSegments(a[0], a[1], jsts.geomgraph.Position.LEFT), n.addFirstSegment();
					for (var s = 2; l >= s; s++) n.addNextSegment(a[s], !0)
				}
				n.addLastSegment(), n.closeRing()
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.computeOffsetCurve = function(t, e, n) {
				var i = jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance(this.distance);
				if (e) {
					var o = jsts.operation.buffer.BufferInputLineSimplifier.simplify(t, -i),
						r = o.length - 1;
					n.initSideSegments(o[r], o[r - 1], jsts.geomgraph.Position.LEFT), n.addFirstSegment();
					for (var s = r - 2; s >= 0; s--) n.addNextSegment(o[s], !0)
				} else {
					var a = jsts.operation.buffer.BufferInputLineSimplifier.simplify(t, i),
						l = a.length - 1;
					n.initSideSegments(a[0], a[1], jsts.geomgraph.Position.LEFT), n.addFirstSegment();
					for (var s = 2; l >= s; s++) n.addNextSegment(a[s], !0)
				}
				n.addLastSegment()
			}, jsts.operation.buffer.OffsetCurveBuilder.prototype.computeRingBufferCurve = function(t, e, n) {
				var i = jsts.operation.buffer.OffsetCurveBuilder.simplifyTolerance(this.distance);
				e === jsts.geomgraph.Position.RIGHT && (i = -i);
				var o = jsts.operation.buffer.BufferInputLineSimplifier.simplify(t, i),
					r = o.length - 1;
				n.initSideSegments(o[r - 1], o[0], e);
				for (var s = 1; r >= s; s++) {
					var a = 1 !== s;
					n.addNextSegment(o[s], a)
				}
				n.closeRing()
			}, function() {
				var t = function(t, e, n) {
						this.hotPixel = t, this.parentEdge = e, this.vertexIndex = n
					};
				t.prototype = new jsts.index.chain.MonotoneChainSelectAction, t.constructor = t, t.prototype.hotPixel = null, t.prototype.parentEdge = null, t.prototype.vertexIndex = null, t.prototype._isNodeAdded = !1, t.prototype.isNodeAdded = function() {
					return this._isNodeAdded
				}, t.prototype.select = function(t, e) {
					var n = t.getContext();
					(null === this.parentEdge || n !== this.parentEdge || e !== this.vertexIndex) && (this._isNodeAdded = this.hotPixel.addSnappedNode(n, e))
				}, jsts.noding.snapround.MCIndexPointSnapper = function(t) {
					this.index = t
				}, jsts.noding.snapround.MCIndexPointSnapper.prototype.index = null, jsts.noding.snapround.MCIndexPointSnapper.prototype.snap = function(e, n, i) {
					if (1 === arguments.length) return void this.snap2.apply(this, arguments);
					var o = e.getSafeEnvelope(),
						r = new t(e, n, i);
					return this.index.query(o, {
						visitItem: function(t) {
							t.select(o, r)
						}
					}), r.isNodeAdded()
				}, jsts.noding.snapround.MCIndexPointSnapper.prototype.snap2 = function(t) {
					return this.snap(t, null, -1)
				}
			}(), function() {
				var t = function() {
						this.items = new javascript.util.ArrayList, this.subnode = [null, null]
					};
				t.getSubnodeIndex = function(t, e) {
					var n = -1;
					return t.min >= e && (n = 1), t.max <= e && (n = 0), n
				}, t.prototype.getItems = function() {
					return this.items
				}, t.prototype.add = function(t) {
					this.items.add(t)
				}, t.prototype.addAllItems = function(t) {
					t.addAll(this.items);
					var e = 0,
						n = 2;
					for (e; n > e; e++) null !== this.subnode[e] && this.subnode[e].addAllItems(t);
					return t
				}, t.prototype.addAllItemsFromOverlapping = function(t, e) {
					(null === t || this.isSearchMatch(t)) && (e.addAll(this.items), null !== this.subnode[0] && this.subnode[0].addAllItemsFromOverlapping(t, e), null !== this.subnode[1] && this.subnode[1].addAllItemsFromOverlapping(t, e))
				}, t.prototype.remove = function(t, e) {
					if (!this.isSearchMatch(t)) return !1;
					var n = !1,
						i = 0,
						o = 2;
					for (i; o > i; i++) if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {
						this.subnode[i].isPrunable() && (this.subnode[i] = null);
						break
					}
					return n ? n : n = this.items.remove(e)
				}, t.prototype.isPrunable = function() {
					return !(this.hasChildren() || this.hasItems())
				}, t.prototype.hasChildren = function() {
					var t = 0,
						e = 2;
					for (t; e > t; t++) if (null !== this.subnode[t]) return !0;
					return !1
				}, t.prototype.hasItems = function() {
					return !this.items.isEmpty()
				}, t.prototype.depth = function() {
					var t, e = 0,
						n = 0,
						i = 2;
					for (n; i > n; n++) null !== this.subnode[n] && (t = this.subnode[n].depth(), t > e && (e = t));
					return e + 1
				}, t.prototype.size = function() {
					var t = 0,
						e = 0,
						n = 2;
					for (e; n > e; e++) null !== this.subnode[e] && (t += this.subnode[e].size());
					return t + this.items.size()
				}, t.prototype.nodeSize = function() {
					var t = 0,
						e = 0,
						n = 2;
					for (e; n > e; e++) null !== this.subnode[e] && (t += this.subnode[e].nodeSize());
					return t + 1
				}, jsts.index.bintree.NodeBase = t
			}(), function() {
				var t = jsts.index.bintree.NodeBase,
					e = jsts.index.bintree.Key,
					n = jsts.index.bintree.Interval,
					i = function(t, e) {
						this.items = new javascript.util.ArrayList, this.subnode = [null, null], this.interval = t, this.level = e, this.centre = (t.getMin() + t.getMax()) / 2
					};
				i.prototype = new t, i.constructor = i, i.createNode = function(t) {
					var n, o;
					return n = new e(t), o = new i(n.getInterval(), n.getLevel())
				}, i.createExpanded = function(t, e) {
					var o, r;
					return o = new n(e), null !== t && o.expandToInclude(t.interval), r = i.createNode(o), null !== t && r.insert(t), r
				}, i.prototype.getInterval = function() {
					return this.interval
				}, i.prototype.isSearchMatch = function(t) {
					return t.overlaps(this.interval)
				}, i.prototype.getNode = function(e) {
					var n, i = t.getSubnodeIndex(e, this.centre);
					return -1 != i ? (n = this.getSubnode(i), n.getNode(e)) : this
				}, i.prototype.find = function(e) {
					var n, i = t.getSubnodeIndex(e, this.centre);
					return -1 === i ? this : null !== this.subnode[i] ? (n = this.subnode[i], n.find(e)) : this
				}, i.prototype.insert = function(e) {
					var n, i = t.getSubnodeIndex(e.interval, this.centre);
					e.level === this.level - 1 ? this.subnode[i] = e : (n = this.createSubnode(i), n.insert(e), this.subnode[i] = n)
				}, i.prototype.getSubnode = function(t) {
					return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)), this.subnode[t]
				}, i.prototype.createSubnode = function(t) {
					var e, o, r, s;
					switch (e = 0, o = 0, t) {
					case 0:
						e = this.interval.getMin(), o = this.centre;
						break;
					case 1:
						e = this.centre, o = this.interval.getMax()
					}
					return r = new n(e, o), s = new i(r, this.level - 1)
				}, jsts.index.bintree.Node = i
			}(), function() {
				var t = jsts.index.bintree.Node,
					e = jsts.index.bintree.NodeBase,
					n = function() {
						this.subnode = [null, null], this.items = new javascript.util.ArrayList
					};
				n.prototype = new jsts.index.bintree.NodeBase, n.constructor = n, n.origin = 0, n.prototype.insert = function(i, o) {
					var r, s, a = e.getSubnodeIndex(i, n.origin);
					return -1 === a ? void this.add(o) : (r = this.subnode[a], null !== r && r.getInterval().contains(i) || (s = t.createExpanded(r, i), this.subnode[a] = s), void this.insertContained(this.subnode[a], i, o))
				}, n.prototype.insertContained = function(t, e, n) {
					var i, o;
					i = jsts.index.IntervalSize.isZeroWidth(e.getMin(), e.getMax()), o = i ? t.find(e) : t.getNode(e), o.add(n)
				}, n.prototype.isSearchMatch = function() {
					return !0
				}, jsts.index.bintree.Root = n
			}(), jsts.geomgraph.Quadrant = function() {}, jsts.geomgraph.Quadrant.NE = 0, jsts.geomgraph.Quadrant.NW = 1, jsts.geomgraph.Quadrant.SW = 2, jsts.geomgraph.Quadrant.SE = 3, jsts.geomgraph.Quadrant.quadrant = function(t, e) {
				if (t instanceof jsts.geom.Coordinate) return jsts.geomgraph.Quadrant.quadrant2.apply(this, arguments);
				if (0 === t && 0 === e) throw new jsts.error.IllegalArgumentError("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
				return t >= 0 ? e >= 0 ? jsts.geomgraph.Quadrant.NE : jsts.geomgraph.Quadrant.SE : e >= 0 ? jsts.geomgraph.Quadrant.NW : jsts.geomgraph.Quadrant.SW
			}, jsts.geomgraph.Quadrant.quadrant2 = function(t, e) {
				if (e.x === t.x && e.y === t.y) throw new jsts.error.IllegalArgumentError("Cannot compute the quadrant for two identical points " + t);
				return e.x >= t.x ? e.y >= t.y ? jsts.geomgraph.Quadrant.NE : jsts.geomgraph.Quadrant.SE : e.y >= t.y ? jsts.geomgraph.Quadrant.NW : jsts.geomgraph.Quadrant.SW
			}, jsts.geomgraph.Quadrant.isOpposite = function(t, e) {
				if (t === e) return !1;
				var n = (t - e + 4) % 4;
				return 2 === n
			}, jsts.geomgraph.Quadrant.commonHalfPlane = function(t, e) {
				if (t === e) return t;
				var n = (t - e + 4) % 4;
				if (2 === n) return -1;
				var i = e > t ? t : e,
					o = t > e ? t : e;
				return 0 === i && 3 === o ? 3 : i
			}, jsts.geomgraph.Quadrant.isInHalfPlane = function(t, e) {
				return e === jsts.geomgraph.Quadrant.SE ? t === jsts.geomgraph.Quadrant.SE || t === jsts.geomgraph.Quadrant.SW : t === e || t === e + 1
			}, jsts.geomgraph.Quadrant.isNorthern = function(t) {
				return t === jsts.geomgraph.Quadrant.NE || t === jsts.geomgraph.Quadrant.NW
			}, jsts.operation.valid.ConsistentAreaTester = function(t) {
				this.geomGraph = t, this.li = new jsts.algorithm.RobustLineIntersector, this.nodeGraph = new jsts.operation.relate.RelateNodeGraph, this.invalidPoint = null
			}, jsts.operation.valid.ConsistentAreaTester.prototype.getInvalidPoint = function() {
				return this.invalidPoint
			}, jsts.operation.valid.ConsistentAreaTester.prototype.isNodeConsistentArea = function() {
				var t = this.geomGraph.computeSelfNodes(this.li, !0);
				return t.hasProperIntersection() ? (this.invalidPoint = t.getProperIntersectionPoint(), !1) : (this.nodeGraph.build(this.geomGraph), this.isNodeEdgeAreaLabelsConsistent())
			}, jsts.operation.valid.ConsistentAreaTester.prototype.isNodeEdgeAreaLabelsConsistent = function() {
				for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) {
					var e = t.next();
					if (!e.getEdges().isAreaLabelsConsistent(this.geomGraph)) return this.invalidPoint = e.getCoordinate().clone(), !1
				}
				return !0
			}, jsts.operation.valid.ConsistentAreaTester.prototype.hasDuplicateRings = function() {
				for (var t = this.nodeGraph.getNodeIterator(); t.hasNext();) for (var e = t.next(), n = e.getEdges().iterator(); n.hasNext();) {
					var i = n.next();
					if (i.getEdgeEnds().length > 1) return invalidPoint = i.getEdge().getCoordinate(0), !0
				}
				return !1
			}, jsts.operation.relate.RelateNode = function() {
				jsts.geomgraph.Node.apply(this, arguments)
			}, jsts.operation.relate.RelateNode.prototype = new jsts.geomgraph.Node, jsts.operation.relate.RelateNode.prototype.computeIM = function(t) {
				t.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0)
			}, jsts.operation.relate.RelateNode.prototype.updateIMFromEdges = function(t) {
				this.edges.updateIM(t)
			}, function() {
				var t = jsts.geom.Location,
					e = jsts.geomgraph.Position,
					n = jsts.geomgraph.EdgeEnd;
				jsts.geomgraph.DirectedEdge = function(t, e) {
					if (n.call(this, t), this.depth = [0, -999, -999], this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1));
					else {
						var i = t.getNumPoints() - 1;
						this.init(t.getCoordinate(i), t.getCoordinate(i - 1))
					}
					this.computeDirectedLabel()
				}, jsts.geomgraph.DirectedEdge.prototype = new n, jsts.geomgraph.DirectedEdge.constructor = jsts.geomgraph.DirectedEdge, jsts.geomgraph.DirectedEdge.depthFactor = function(e, n) {
					return e === t.EXTERIOR && n === t.INTERIOR ? 1 : e === t.INTERIOR && n === t.EXTERIOR ? -1 : 0
				}, jsts.geomgraph.DirectedEdge.prototype._isForward = null, jsts.geomgraph.DirectedEdge.prototype._isInResult = !1, jsts.geomgraph.DirectedEdge.prototype._isVisited = !1, jsts.geomgraph.DirectedEdge.prototype.sym = null, jsts.geomgraph.DirectedEdge.prototype.next = null, jsts.geomgraph.DirectedEdge.prototype.nextMin = null, jsts.geomgraph.DirectedEdge.prototype.edgeRing = null, jsts.geomgraph.DirectedEdge.prototype.minEdgeRing = null, jsts.geomgraph.DirectedEdge.prototype.depth = null, jsts.geomgraph.DirectedEdge.prototype.getEdge = function() {
					return this.edge
				}, jsts.geomgraph.DirectedEdge.prototype.setInResult = function(t) {
					this._isInResult = t
				}, jsts.geomgraph.DirectedEdge.prototype.isInResult = function() {
					return this._isInResult
				}, jsts.geomgraph.DirectedEdge.prototype.isVisited = function() {
					return this._isVisited
				}, jsts.geomgraph.DirectedEdge.prototype.setVisited = function(t) {
					this._isVisited = t
				}, jsts.geomgraph.DirectedEdge.prototype.setEdgeRing = function(t) {
					this.edgeRing = t
				}, jsts.geomgraph.DirectedEdge.prototype.getEdgeRing = function() {
					return this.edgeRing
				}, jsts.geomgraph.DirectedEdge.prototype.setMinEdgeRing = function(t) {
					this.minEdgeRing = t
				}, jsts.geomgraph.DirectedEdge.prototype.getMinEdgeRing = function() {
					return this.minEdgeRing
				}, jsts.geomgraph.DirectedEdge.prototype.getDepth = function(t) {
					return this.depth[t]
				}, jsts.geomgraph.DirectedEdge.prototype.setDepth = function(t, e) {
					if (-999 !== this.depth[t] && this.depth[t] !== e) throw new jsts.error.TopologyError("assigned depths do not match", this.getCoordinate());
					this.depth[t] = e
				}, jsts.geomgraph.DirectedEdge.prototype.getDepthDelta = function() {
					var t = this.edge.getDepthDelta();
					return this._isForward || (t = -t), t
				}, jsts.geomgraph.DirectedEdge.prototype.setVisitedEdge = function(t) {
					this.setVisited(t), this.sym.setVisited(t)
				}, jsts.geomgraph.DirectedEdge.prototype.getSym = function() {
					return this.sym
				}, jsts.geomgraph.DirectedEdge.prototype.isForward = function() {
					return this._isForward
				}, jsts.geomgraph.DirectedEdge.prototype.setSym = function(t) {
					this.sym = t
				}, jsts.geomgraph.DirectedEdge.prototype.getNext = function() {
					return this.next
				}, jsts.geomgraph.DirectedEdge.prototype.setNext = function(t) {
					this.next = t
				}, jsts.geomgraph.DirectedEdge.prototype.getNextMin = function() {
					return this.nextMin
				}, jsts.geomgraph.DirectedEdge.prototype.setNextMin = function(t) {
					this.nextMin = t
				}, jsts.geomgraph.DirectedEdge.prototype.isLineEdge = function() {
					var e = this.label.isLine(0) || this.label.isLine(1),
						n = !this.label.isArea(0) || this.label.allPositionsEqual(0, t.EXTERIOR),
						i = !this.label.isArea(1) || this.label.allPositionsEqual(1, t.EXTERIOR);
					return e && n && i
				}, jsts.geomgraph.DirectedEdge.prototype.isInteriorAreaEdge = function() {
					for (var n = !0, i = 0; 2 > i; i++) this.label.isArea(i) && this.label.getLocation(i, e.LEFT) === t.INTERIOR && this.label.getLocation(i, e.RIGHT) === t.INTERIOR || (n = !1);
					return n
				}, jsts.geomgraph.DirectedEdge.prototype.computeDirectedLabel = function() {
					this.label = new jsts.geomgraph.Label(this.edge.getLabel()), this._isForward || this.label.flip()
				}, jsts.geomgraph.DirectedEdge.prototype.setEdgeDepths = function(t, n) {
					var i = this.getEdge().getDepthDelta();
					this._isForward || (i = -i);
					var o = 1;
					t === e.LEFT && (o = -1);
					var r = e.opposite(t),
						s = i * o,
						a = n + s;
					this.setDepth(t, n), this.setDepth(r, a)
				}
			}(), jsts.operation.distance.DistanceOp = function(t, e, n) {
				this.ptLocator = new jsts.algorithm.PointLocator, this.geom = [], this.geom[0] = t, this.geom[1] = e, this.terminateDistance = n
			}, jsts.operation.distance.DistanceOp.prototype.geom = null, jsts.operation.distance.DistanceOp.prototype.terminateDistance = 0, jsts.operation.distance.DistanceOp.prototype.ptLocator = null, jsts.operation.distance.DistanceOp.prototype.minDistanceLocation = null, jsts.operation.distance.DistanceOp.prototype.minDistance = Number.MAX_VALUE, jsts.operation.distance.DistanceOp.distance = function(t, e) {
				var n = new jsts.operation.distance.DistanceOp(t, e, 0);
				return n.distance()
			}, jsts.operation.distance.DistanceOp.isWithinDistance = function(t, e, n) {
				var i = new jsts.operation.distance.DistanceOp(t, e, n);
				return i.distance() <= n
			}, jsts.operation.distance.DistanceOp.nearestPoints = function(t, e) {
				var n = new jsts.operation.distance.DistanceOp(t, e, 0);
				return n.nearestPoints()
			}, jsts.operation.distance.DistanceOp.prototype.distance = function() {
				if (null === this.geom[0] || null === this.geom[1]) throw new jsts.error.IllegalArgumentError("null geometries are not supported");
				return this.geom[0].isEmpty() || this.geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this.minDistance)
			}, jsts.operation.distance.DistanceOp.prototype.nearestPoints = function() {
				this.computeMinDistance();
				var t = [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()];
				return t
			}, jsts.operation.distance.DistanceOp.prototype.nearestLocations = function() {
				return this.computeMinDistance(), this.minDistanceLocation
			}, jsts.operation.distance.DistanceOp.prototype.updateMinDistance = function(t, e) {
				null !== t[0] && (e ? (this.minDistanceLocation[0] = t[1], this.minDistanceLocation[1] = t[0]) : (this.minDistanceLocation[0] = t[0], this.minDistanceLocation[1] = t[1]))
			}, jsts.operation.distance.DistanceOp.prototype.computeMinDistance = function() {
				return arguments.length > 0 ? void this.computeMinDistance2.apply(this, arguments) : void(null === this.minDistanceLocation && (this.minDistanceLocation = [], this.computeContainmentDistance(), this.minDistance <= this.terminateDistance || this.computeFacetDistance()))
			}, jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance = function() {
				if (2 === arguments.length) return void this.computeContainmentDistance2.apply(this, arguments);
				if (3 === arguments.length && !arguments[0] instanceof jsts.operation.distance.GeometryLocation) return void this.computeContainmentDistance3.apply(this, arguments);
				if (3 === arguments.length) return void this.computeContainmentDistance4.apply(this, arguments);
				var t = [];
				this.computeContainmentDistance2(0, t), this.minDistance <= this.terminateDistance || this.computeContainmentDistance2(1, t)
			}, jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance2 = function(t, e) {
				var n = 1 - t,
					i = jsts.geom.util.PolygonExtracter.getPolygons(this.geom[t]);
				if (i.length > 0) {
					var o = jsts.operation.distance.ConnectedElementLocationFilter.getLocations(this.geom[n]);
					if (this.computeContainmentDistance3(o, i, e), this.minDistance <= this.terminateDistance) return this.minDistanceLocation[n] = e[0], void(this.minDistanceLocation[t] = e[1])
				}
			}, jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance3 = function(t, e, n) {
				for (var i = 0; i < t.length; i++) for (var o = t[i], r = 0; r < e.length; r++) if (this.computeContainmentDistance4(o, e[r], n), this.minDistance <= this.terminateDistance) return
			}, jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance4 = function(t, e, n) {
				var i = t.getCoordinate();
				return jsts.geom.Location.EXTERIOR !== this.ptLocator.locate(i, e) ? (this.minDistance = 0, n[0] = t, void(n[1] = new jsts.operation.distance.GeometryLocation(e, i))) : void 0
			}, jsts.operation.distance.DistanceOp.prototype.computeFacetDistance = function() {
				var t = [],
					e = jsts.geom.util.LinearComponentExtracter.getLines(this.geom[0]),
					n = jsts.geom.util.LinearComponentExtracter.getLines(this.geom[1]),
					i = jsts.geom.util.PointExtracter.getPoints(this.geom[0]),
					o = jsts.geom.util.PointExtracter.getPoints(this.geom[1]);
				this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance || (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, o, t), this.updateMinDistance(t, !1), this.minDistance <= this.terminateDistance || (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, i, t), this.updateMinDistance(t, !0), this.minDistance <= this.terminateDistance || (t[0] = null, t[1] = null, this.computeMinDistancePoints(i, o, t), this.updateMinDistance(t, !1))))
			}, jsts.operation.distance.DistanceOp.prototype.computeMinDistanceLines = function(t, e, n) {
				for (var i = 0; i < t.length; i++) for (var o = t[i], r = 0; r < e.length; r++) {
					var s = e[r];
					if (this.computeMinDistance(o, s, n), this.minDistance <= this.terminateDistance) return
				}
			}, jsts.operation.distance.DistanceOp.prototype.computeMinDistancePoints = function(t, e, n) {
				for (var i = 0; i < t.length; i++) for (var o = t[i], r = 0; r < e.length; r++) {
					var s = e[r],
						a = o.getCoordinate().distance(s.getCoordinate());
					if (a < this.minDistance && (this.minDistance = a, n[0] = new jsts.operation.distance.GeometryLocation(o, 0, o.getCoordinate()), n[1] = new jsts.operation.distance.GeometryLocation(s, 0, s.getCoordinate())), this.minDistance <= this.terminateDistance) return
				}
			}, jsts.operation.distance.DistanceOp.prototype.computeMinDistanceLinesPoints = function(t, e, n) {
				for (var i = 0; i < t.length; i++) for (var o = t[i], r = 0; r < e.length; r++) {
					var s = e[r];
					if (this.computeMinDistance(o, s, n), this.minDistance <= this.terminateDistance) return
				}
			}, jsts.operation.distance.DistanceOp.prototype.computeMinDistance2 = function(t, e, n) {
				if (e instanceof jsts.geom.Point) return void this.computeMinDistance3(t, e, n);
				if (!(t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this.minDistance)) for (var i = t.getCoordinates(), o = e.getCoordinates(), r = 0; r < i.length - 1; r++) for (var s = 0; s < o.length - 1; s++) {
					var a = jsts.algorithm.CGAlgorithms.distanceLineLine(i[r], i[r + 1], o[s], o[s + 1]);
					if (a < this.minDistance) {
						this.minDistance = a;
						var l = new jsts.geom.LineSegment(i[r], i[r + 1]),
							u = new jsts.geom.LineSegment(o[s], o[s + 1]),
							p = l.closestPoints(u);
						n[0] = new jsts.operation.distance.GeometryLocation(t, r, p[0]), n[1] = new jsts.operation.distance.GeometryLocation(e, s, p[1])
					}
					if (this.minDistance <= this.terminateDistance) return
				}
			}, jsts.operation.distance.DistanceOp.prototype.computeMinDistance3 = function(t, e, n) {
				if (!(t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this.minDistance)) for (var i = t.getCoordinates(), o = e.getCoordinate(), r = 0; r < i.length - 1; r++) {
					var s = jsts.algorithm.CGAlgorithms.distancePointLine(o, i[r], i[r + 1]);
					if (s < this.minDistance) {
						this.minDistance = s;
						var a = new jsts.geom.LineSegment(i[r], i[r + 1]),
							l = a.closestPoint(o);
						n[0] = new jsts.operation.distance.GeometryLocation(t, r, l), n[1] = new jsts.operation.distance.GeometryLocation(e, 0, o)
					}
					if (this.minDistance <= this.terminateDistance) return
				}
			}, jsts.index.strtree.SIRtree = function(t) {
				t = t || 10, jsts.index.strtree.AbstractSTRtree.call(this, t)
			}, jsts.index.strtree.SIRtree.prototype = new jsts.index.strtree.AbstractSTRtree, jsts.index.strtree.SIRtree.constructor = jsts.index.strtree.SIRtree, jsts.index.strtree.SIRtree.prototype.comperator = {
				compare: function(t, e) {
					return t.getBounds().getCentre() - e.getBounds().getCentre()
				}
			}, jsts.index.strtree.SIRtree.prototype.intersectionOp = {
				intersects: function(t, e) {
					return t.intersects(e)
				}
			}, jsts.index.strtree.SIRtree.prototype.createNode = function() {
				var t = function() {
						jsts.index.strtree.AbstractNode.apply(this, arguments)
					};
				return t.prototype = new jsts.index.strtree.AbstractNode, t.constructor = t, t.prototype.computeBounds = function() {
					for (var t, e = null, n = this.getChildBoundables(), i = 0, o = n.length; o > i; i++) t = n[i], null === e ? e = new jsts.index.strtree.Interval(t.getBounds()) : e.expandToInclude(t.getBounds());
					return e
				}, t
			}, jsts.index.strtree.SIRtree.prototype.insert = function(t, e, n) {
				jsts.index.strtree.AbstractSTRtree.prototype.insert(new jsts.index.strtree.Interval(Math.min(t, e), Math.max(t, e)), n)
			}, jsts.index.strtree.SIRtree.prototype.query = function(t, e) {
				e = e || t, jsts.index.strtree.AbstractSTRtree.prototype.query(new jsts.index.strtree.Interval(Math.min(t, e), Math.max(t, e)))
			}, jsts.index.strtree.SIRtree.prototype.getIntersectsOp = function() {
				return this.intersectionOp
			}, jsts.index.strtree.SIRtree.prototype.getComparator = function() {
				return this.comperator
			}, jsts.simplify.DouglasPeuckerSimplifier = function(t) {
				this.inputGeom = t, this.isEnsureValidTopology = !0
			}, jsts.simplify.DouglasPeuckerSimplifier.prototype.inputGeom = null, jsts.simplify.DouglasPeuckerSimplifier.prototype.distanceTolerance = null, jsts.simplify.DouglasPeuckerSimplifier.prototype.isEnsureValidTopology = null, jsts.simplify.DouglasPeuckerSimplifier.simplify = function(t, e) {
				var n = new jsts.simplify.DouglasPeuckerSimplifier(t);
				return n.setDistanceTolerance(e), n.getResultGeometry()
			}, jsts.simplify.DouglasPeuckerSimplifier.prototype.setDistanceTolerance = function(t) {
				if (0 > t) throw "Tolerance must be non-negative";
				this.distanceTolerance = t
			}, jsts.simplify.DouglasPeuckerSimplifier.prototype.setEnsureValid = function(t) {
				this.isEnsureValidTopology = t
			}, jsts.simplify.DouglasPeuckerSimplifier.prototype.getResultGeometry = function() {
				return this.inputGeom.isEmpty() ? this.inputGeom.clone() : new jsts.simplify.DPTransformer(this.distanceTolerance, this.isEnsureValidTopology).transform(this.inputGeom)
			}, function() {
				jsts.operation.predicate.RectangleContains = function(t) {
					this.rectEnv = t.getEnvelopeInternal()
				}, jsts.operation.predicate.RectangleContains.contains = function(t, e) {
					var n = new jsts.operation.predicate.RectangleContains(t);
					return n.contains(e)
				}, jsts.operation.predicate.RectangleContains.prototype.rectEnv = null, jsts.operation.predicate.RectangleContains.prototype.contains = function(t) {
					return !!this.rectEnv.contains(t.getEnvelopeInternal()) && !this.isContainedInBoundary(t)
				}, jsts.operation.predicate.RectangleContains.prototype.isContainedInBoundary = function(t) {
					if (t instanceof jsts.geom.Polygon) return !1;
					if (t instanceof jsts.geom.Point) return this.isPointContainedInBoundary(t.getCoordinate());
					if (t instanceof jsts.geom.LineString) return this.isLineStringContainedInBoundary(t);
					for (var e = 0; e < t.getNumGeometries(); e++) {
						var n = t.getGeometryN(e);
						if (!this.isContainedInBoundary(n)) return !1
					}
					return !0
				}, jsts.operation.predicate.RectangleContains.prototype.isPointContainedInBoundary = function(t) {
					return t.x == this.rectEnv.getMinX() || t.x == this.rectEnv.getMaxX() || t.y == this.rectEnv.getMinY() || t.y == this.rectEnv.getMaxY()
				}, jsts.operation.predicate.RectangleContains.prototype.isLineStringContainedInBoundary = function(t) {
					for (var e = t.getCoordinateSequence(), n = 0; n < e.length - 1; n++) {
						var i = e[n],
							o = e[n + 1];
						if (!this.isLineSegmentContainedInBoundary(i, o)) return !1
					}
					return !0
				}, jsts.operation.predicate.RectangleContains.prototype.isLineSegmentContainedInBoundary = function(t, e) {
					if (t.equals(e)) return this.isPointContainedInBoundary(t);
					if (t.x == e.x) {
						if (t.x == this.rectEnv.getMinX() || t.x == this.rectEnv.getMaxX()) return !0
					} else if (t.y == e.y && (t.y == this.rectEnv.getMinY() || t.y == this.rectEnv.getMaxY())) return !0;
					return !1
				}
			}(), function() {
				var t = jsts.geom.Location,
					e = jsts.geomgraph.Position;
				jsts.geomgraph.Depth = function() {
					this.depth = [
						[],
						[]
					];
					for (var t = 0; 2 > t; t++) for (var e = 0; 3 > e; e++) this.depth[t][e] = jsts.geomgraph.Depth.NULL_VALUE
				}, jsts.geomgraph.Depth.NULL_VALUE = -1, jsts.geomgraph.Depth.depthAtLocation = function(e) {
					return e === t.EXTERIOR ? 0 : e === t.INTERIOR ? 1 : jsts.geomgraph.Depth.NULL_VALUE
				}, jsts.geomgraph.Depth.prototype.depth = null, jsts.geomgraph.Depth.prototype.getDepth = function(t, e) {
					return this.depth[t][e]
				}, jsts.geomgraph.Depth.prototype.setDepth = function(t, e, n) {
					this.depth[t][e] = n
				}, jsts.geomgraph.Depth.prototype.getLocation = function(e, n) {
					return this.depth[e][n] <= 0 ? t.EXTERIOR : t.INTERIOR
				}, jsts.geomgraph.Depth.prototype.add = function(e, n, i) {
					i === t.INTERIOR && this.depth[e][n]++
				}, jsts.geomgraph.Depth.prototype.isNull = function() {
					if (arguments.length > 0) return this.isNull2.apply(this, arguments);
					for (var t = 0; 2 > t; t++) for (var e = 0; 3 > e; e++) if (this.depth[t][e] !== jsts.geomgraph.Depth.NULL_VALUE) return !1;
					return !0
				}, jsts.geomgraph.Depth.prototype.isNull2 = function(t) {
					return arguments.length > 1 ? this.isNull3.apply(this, arguments) : this.depth[t][1] == jsts.geomgraph.Depth.NULL_VALUE
				}, jsts.geomgraph.Depth.prototype.isNull3 = function(t, e) {
					return this.depth[t][e] == jsts.geomgraph.Depth.NULL_VALUE
				}, jsts.geomgraph.Depth.prototype.add = function(e) {
					for (var n = 0; 2 > n; n++) for (var i = 1; 3 > i; i++) {
						var o = e.getLocation(n, i);
						(o === t.EXTERIOR || o === t.INTERIOR) && (this.isNull(n, i) ? this.depth[n][i] = jsts.geomgraph.Depth.depthAtLocation(o) : this.depth[n][i] += jsts.geomgraph.Depth.depthAtLocation(o))
					}
				}, jsts.geomgraph.Depth.prototype.getDelta = function(t) {
					return this.depth[t][e.RIGHT] - this.depth[t][e.LEFT]
				}, jsts.geomgraph.Depth.prototype.normalize = function() {
					for (var t = 0; 2 > t; t++) if (!this.isNull(t)) {
						var e = this.depth[t][1];
						this.depth[t][2] < e && (e = this.depth[t][2]), 0 > e && (e = 0);
						for (var n = 1; 3 > n; n++) {
							var i = 0;
							this.depth[t][n] > e && (i = 1), this.depth[t][n] = i
						}
					}
				}, jsts.geomgraph.Depth.prototype.toString = function() {
					return "A: " + this.depth[0][1] + "," + this.depth[0][2] + " B: " + this.depth[1][1] + "," + this.depth[1][2]
				}
			}(), jsts.algorithm.BoundaryNodeRule = function() {}, jsts.algorithm.BoundaryNodeRule.prototype.isInBoundary = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.algorithm.Mod2BoundaryNodeRule = function() {}, jsts.algorithm.Mod2BoundaryNodeRule.prototype = new jsts.algorithm.BoundaryNodeRule, jsts.algorithm.Mod2BoundaryNodeRule.prototype.isInBoundary = function(t) {
				return t % 2 === 1
			}, jsts.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE = new jsts.algorithm.Mod2BoundaryNodeRule, jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = jsts.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE, jsts.operation.distance.GeometryLocation = function(t, e, n) {
				this.component = t, this.segIndex = e, this.pt = n
			}, jsts.operation.distance.GeometryLocation.INSIDE_AREA = -1, jsts.operation.distance.GeometryLocation.prototype.component = null, jsts.operation.distance.GeometryLocation.prototype.segIndex = null, jsts.operation.distance.GeometryLocation.prototype.pt = null, jsts.operation.distance.GeometryLocation.prototype.getGeometryComponent = function() {
				return this.component
			}, jsts.operation.distance.GeometryLocation.prototype.getSegmentIndex = function() {
				return this.segIndex
			}, jsts.operation.distance.GeometryLocation.prototype.getCoordinate = function() {
				return this.pt
			}, jsts.operation.distance.GeometryLocation.prototype.isInsideArea = function() {
				return this.segIndex === jsts.operation.distance.GeometryLocation.INSIDE_AREA
			}, jsts.geom.util.PointExtracter = function(t) {
				this.pts = t
			}, jsts.geom.util.PointExtracter.prototype = new jsts.geom.GeometryFilter, jsts.geom.util.PointExtracter.prototype.pts = null, jsts.geom.util.PointExtracter.getPoints = function(t, e) {
				return void 0 === e && (e = []), t instanceof jsts.geom.Point ? e.push(t) : (t instanceof jsts.geom.GeometryCollection || t instanceof jsts.geom.MultiPoint || t instanceof jsts.geom.MultiLineString || t instanceof jsts.geom.MultiPolygon) && t.apply(new jsts.geom.util.PointExtracter(e)), e
			}, jsts.geom.util.PointExtracter.prototype.filter = function(t) {
				t instanceof jsts.geom.Point && this.pts.push(t)
			}, function() {
				var t = jsts.geom.Location;
				jsts.operation.relate.RelateNodeGraph = function() {
					this.nodes = new jsts.geomgraph.NodeMap(new jsts.operation.relate.RelateNodeFactory)
				}, jsts.operation.relate.RelateNodeGraph.prototype.nodes = null, jsts.operation.relate.RelateNodeGraph.prototype.build = function(t) {
					this.computeIntersectionNodes(t, 0), this.copyNodesAndLabels(t, 0);
					var e = new jsts.operation.relate.EdgeEndBuilder,
						n = e.computeEdgeEnds(t.getEdgeIterator());
					this.insertEdgeEnds(n)
				}, jsts.operation.relate.RelateNodeGraph.prototype.computeIntersectionNodes = function(e, n) {
					for (var i = e.getEdgeIterator(); i.hasNext();) for (var o = i.next(), r = o.getLabel().getLocation(n), s = o.getEdgeIntersectionList().iterator(); s.hasNext();) {
						var a = s.next(),
							l = this.nodes.addNode(a.coord);
						r === t.BOUNDARY ? l.setLabelBoundary(n) : l.getLabel().isNull(n) && l.setLabel(n, t.INTERIOR)
					}
				}, jsts.operation.relate.RelateNodeGraph.prototype.copyNodesAndLabels = function(t, e) {
					for (var n = t.getNodeIterator(); n.hasNext();) {
						var i = n.next(),
							o = this.nodes.addNode(i.getCoordinate());
						o.setLabel(e, i.getLabel().getLocation(e))
					}
				}, jsts.operation.relate.RelateNodeGraph.prototype.insertEdgeEnds = function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var n = e.next();
						this.nodes.add(n)
					}
				}, jsts.operation.relate.RelateNodeGraph.prototype.getNodeIterator = function() {
					return this.nodes.iterator()
				}
			}(), jsts.geomgraph.index.SimpleSweepLineIntersector = function() {}, jsts.geomgraph.index.SimpleSweepLineIntersector.prototype = new jsts.geomgraph.index.EdgeSetIntersector, jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.events = [], jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.nOverlaps = null, jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.computeIntersections = function(t, e, n) {
				return e instanceof javascript.util.List ? void this.computeIntersections2.apply(this, arguments) : (n ? this.add(t, null) : this.add(t), void this.computeIntersections3(e))
			}, jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.computeIntersections2 = function(t, e, n) {
				this.add(t, t), this.add(e, e), this.computeIntersections3(n)
			}, jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.add = function(t, e) {
				if (t instanceof javascript.util.List) return void this.add2.apply(this, arguments);
				for (var n = t.getCoordinates(), i = 0; i < n.length - 1; i++) {
					var o = new jsts.geomgraph.index.SweepLineSegment(t, i),
						r = new jsts.geomgraph.index.SweepLineEvent(o.getMinX(), o, e);
					this.events.push(r), this.events.push(new jsts.geomgraph.index.SweepLineEvent(o.getMaxX(), r))
				}
			}, jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.add2 = function(t, e) {
				for (var n = t.iterator(); n.hasNext();) {
					var i = n.next();
					e ? this.add(i, e) : this.add(i, i)
				}
			}, jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.prepareEvents = function() {
				this.events.sort(function(t, e) {
					return t.compareTo(e)
				});
				for (var t = 0; t < this.events.length; t++) {
					var e = this.events[t];
					e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
				}
			}, jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.computeIntersections3 = function(t) {
				this.nOverlaps = 0, this.prepareEvents();
				for (var e = 0; e < this.events.length; e++) {
					var n = this.events[e];
					n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t)
				}
			}, jsts.geomgraph.index.SimpleSweepLineIntersector.prototype.processOverlaps = function(t, e, n, i) {
				for (var o = n.getObject(), r = t; e > r; r++) {
					var s = this.events[r];
					if (s.isInsert()) {
						var a = s.getObject();
						n.isSameLabel(s) || (o.computeIntersections(a, i), this.nOverlaps++)
					}
				}
			}, jsts.triangulate.VoronoiDiagramBuilder = function() {
				this.siteCoords = null, this.tolerance = 0, this.subdiv = null, this.clipEnv = null, this.diagramEnv = null
			}, jsts.triangulate.VoronoiDiagramBuilder.prototype.setSites = function() {
				var t = arguments[0];
				t instanceof jsts.geom.Geometry || t instanceof jsts.geom.Coordinate || t instanceof jsts.geom.Point || t instanceof jsts.geom.MultiPoint || t instanceof jsts.geom.LineString || t instanceof jsts.geom.MultiLineString || t instanceof jsts.geom.LinearRing || t instanceof jsts.geom.Polygon || t instanceof jsts.geom.MultiPolygon ? this.setSitesByGeometry(t) : this.setSitesByArray(t)
			}, jsts.triangulate.VoronoiDiagramBuilder.prototype.setSitesByGeometry = function(t) {
				this.siteCoords = jsts.triangulate.DelaunayTriangulationBuilder.extractUniqueCoordinates(t)
			}, jsts.triangulate.VoronoiDiagramBuilder.prototype.setSitesByArray = function(t) {
				this.siteCoords = jsts.triangulate.DelaunayTriangulationBuilder.unique(t)
			}, jsts.triangulate.VoronoiDiagramBuilder.prototype.setClipEnvelope = function(t) {
				this.clipEnv = t
			}, jsts.triangulate.VoronoiDiagramBuilder.prototype.setTolerance = function(t) {
				this.tolerance = t
			}, jsts.triangulate.VoronoiDiagramBuilder.prototype.create = function() {
				if (null === this.subdiv) {
					var t, e, n, i;
					t = jsts.triangulate.DelaunayTriangulationBuilder.envelope(this.siteCoords), this.diagramEnv = t, e = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight()), this.diagramEnv.expandBy(e), null !== this.clipEnv && this.diagramEnv.expandToInclude(this.clipEnv), n = jsts.triangulate.DelaunayTriangulationBuilder.toVertices(this.siteCoords), this.subdiv = new jsts.triangulate.quadedge.QuadEdgeSubdivision(t, this.tolerance), i = new jsts.triangulate.IncrementalDelaunayTriangulator(this.subdiv), i.insertSites(n)
				}
			}, jsts.triangulate.VoronoiDiagramBuilder.prototype.getSubdivision = function() {
				return this.create(), this.subdiv
			}, jsts.triangulate.VoronoiDiagramBuilder.prototype.getDiagram = function(t) {
				this.create();
				var e = this.subdiv.getVoronoiDiagram(t);
				return this.clipGeometryCollection(e, this.diagramEnv)
			}, jsts.triangulate.VoronoiDiagramBuilder.prototype.clipGeometryCollection = function(t, e) {
				var n, i, o, r, s, a;
				for (n = t.getFactory().toGeometry(e), i = [], o = 0, r = t.getNumGeometries(), o; r > o; o++) s = t.getGeometryN(o), a = null, e.contains(s.getEnvelopeInternal()) ? a = s : e.intersects(s.getEnvelopeInternal()) && (a = n.intersection(s)), null === a || a.isEmpty() || i.push(a);
				return t.getFactory().createGeometryCollection(i)
			}, jsts.operation.valid.IndexedNestedRingTester = function(t) {
				this.graph = t, this.rings = new javascript.util.ArrayList, this.totalEnv = new jsts.geom.Envelope, this.index = null, this.nestedPt = null
			}, jsts.operation.valid.IndexedNestedRingTester.prototype.getNestedPoint = function() {
				return this.nestedPt
			}, jsts.operation.valid.IndexedNestedRingTester.prototype.add = function(t) {
				this.rings.add(t), this.totalEnv.expandToInclude(t.getEnvelopeInternal())
			}, jsts.operation.valid.IndexedNestedRingTester.prototype.isNonNested = function() {
				this.buildIndex();
				for (var t = 0; t < this.rings.size(); t++) for (var e = this.rings.get(t), n = e.getCoordinates(), i = this.index.query(e.getEnvelopeInternal()), o = 0; o < i.length; o++) {
					var r = i[o],
						s = r.getCoordinates();
					if (e != r && e.getEnvelopeInternal().intersects(r.getEnvelopeInternal())) {
						var a = jsts.operation.valid.IsValidOp.findPtNotNode(n, r, this.graph);
						if (null != a) {
							var l = jsts.algorithm.CGAlgorithms.isPointInRing(a, s);
							if (l) return this.nestedPt = a, !1
						}
					}
				}
				return !0
			}, jsts.operation.valid.IndexedNestedRingTester.prototype.buildIndex = function() {
				this.index = new jsts.index.strtree.STRtree;
				for (var t = 0; t < this.rings.size(); t++) {
					var e = this.rings.get(t),
						n = e.getEnvelopeInternal();
					this.index.insert(n, e)
				}
			}, jsts.geomgraph.index.MonotoneChain = function(t, e) {
				this.mce = t, this.chainIndex = e
			}, jsts.geomgraph.index.MonotoneChain.prototype.mce = null, jsts.geomgraph.index.MonotoneChain.prototype.chainIndex = null, jsts.geomgraph.index.MonotoneChain.prototype.computeIntersections = function(t, e) {
				this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e)
			}, jsts.noding.SegmentNode = function(t, e, n, i) {
				this.segString = t, this.coord = new jsts.geom.Coordinate(e), this.segmentIndex = n, this.segmentOctant = i, this._isInterior = !e.equals2D(t.getCoordinate(n))
			}, jsts.noding.SegmentNode.prototype.segString = null, jsts.noding.SegmentNode.prototype.coord = null, jsts.noding.SegmentNode.prototype.segmentIndex = null, jsts.noding.SegmentNode.prototype.segmentOctant = null, jsts.noding.SegmentNode.prototype._isInterior = null, jsts.noding.SegmentNode.prototype.getCoordinate = function() {
				return this.coord
			}, jsts.noding.SegmentNode.prototype.isInterior = function() {
				return this._isInterior
			}, jsts.noding.SegmentNode.prototype.isEndPoint = function() {
				return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === this.maxSegmentIndex
			}, jsts.noding.SegmentNode.prototype.compareTo = function(t) {
				var e = t;
				return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : jsts.noding.SegmentPointComparator.compare(this.segmentOctant, this.coord, e.coord)
			}, function() {
				jsts.io.GeoJSONWriter = function() {
					this.parser = new jsts.io.GeoJSONParser(this.geometryFactory)
				}, jsts.io.GeoJSONWriter.prototype.write = function(t) {
					var e = this.parser.write(t);
					return e
				}
			}(), jsts.io.OpenLayersParser = function(t) {
				this.geometryFactory = t || new jsts.geom.GeometryFactory
			}, jsts.io.OpenLayersParser.prototype.read = function(t) {
				return "OpenLayers.Geometry.Point" === t.CLASS_NAME ? this.convertFromPoint(t) : "OpenLayers.Geometry.LineString" === t.CLASS_NAME ? this.convertFromLineString(t) : "OpenLayers.Geometry.LinearRing" === t.CLASS_NAME ? this.convertFromLinearRing(t) : "OpenLayers.Geometry.Polygon" === t.CLASS_NAME ? this.convertFromPolygon(t) : "OpenLayers.Geometry.MultiPoint" === t.CLASS_NAME ? this.convertFromMultiPoint(t) : "OpenLayers.Geometry.MultiLineString" === t.CLASS_NAME ? this.convertFromMultiLineString(t) : "OpenLayers.Geometry.MultiPolygon" === t.CLASS_NAME ? this.convertFromMultiPolygon(t) : "OpenLayers.Geometry.Collection" === t.CLASS_NAME ? this.convertFromCollection(t) : void 0
			}, jsts.io.OpenLayersParser.prototype.convertFromPoint = function(t) {
				return this.geometryFactory.createPoint(new jsts.geom.Coordinate(t.x, t.y))
			}, jsts.io.OpenLayersParser.prototype.convertFromLineString = function(t) {
				var e, n = [];
				for (e = 0; e < t.components.length; e++) n.push(new jsts.geom.Coordinate(t.components[e].x, t.components[e].y));
				return this.geometryFactory.createLineString(n)
			}, jsts.io.OpenLayersParser.prototype.convertFromLinearRing = function(t) {
				var e, n = [];
				for (e = 0; e < t.components.length; e++) n.push(new jsts.geom.Coordinate(t.components[e].x, t.components[e].y));
				return this.geometryFactory.createLinearRing(n)
			}, jsts.io.OpenLayersParser.prototype.convertFromPolygon = function(t) {
				var e, n = null,
					i = [];
				for (e = 0; e < t.components.length; e++) {
					var o = this.convertFromLinearRing(t.components[e]);
					0 === e ? n = o : i.push(o)
				}
				return this.geometryFactory.createPolygon(n, i)
			}, jsts.io.OpenLayersParser.prototype.convertFromMultiPoint = function(t) {
				var e, n = [];
				for (e = 0; e < t.components.length; e++) n.push(this.convertFromPoint(t.components[e]));
				return this.geometryFactory.createMultiPoint(n)
			}, jsts.io.OpenLayersParser.prototype.convertFromMultiLineString = function(t) {
				var e, n = [];
				for (e = 0; e < t.components.length; e++) n.push(this.convertFromLineString(t.components[e]));
				return this.geometryFactory.createMultiLineString(n)
			}, jsts.io.OpenLayersParser.prototype.convertFromMultiPolygon = function(t) {
				var e, n = [];
				for (e = 0; e < t.components.length; e++) n.push(this.convertFromPolygon(t.components[e]));
				return this.geometryFactory.createMultiPolygon(n)
			}, jsts.io.OpenLayersParser.prototype.convertFromCollection = function(t) {
				var e, n = [];
				for (e = 0; e < t.components.length; e++) n.push(this.read(t.components[e]));
				return this.geometryFactory.createGeometryCollection(n)
			}, jsts.io.OpenLayersParser.prototype.write = function(t) {
				return "jsts.geom.Point" === t.CLASS_NAME ? this.convertToPoint(t.coordinate) : "jsts.geom.LineString" === t.CLASS_NAME ? this.convertToLineString(t) : "jsts.geom.LinearRing" === t.CLASS_NAME ? this.convertToLinearRing(t) : "jsts.geom.Polygon" === t.CLASS_NAME ? this.convertToPolygon(t) : "jsts.geom.MultiPoint" === t.CLASS_NAME ? this.convertToMultiPoint(t) : "jsts.geom.MultiLineString" === t.CLASS_NAME ? this.convertToMultiLineString(t) : "jsts.geom.MultiPolygon" === t.CLASS_NAME ? this.convertToMultiPolygon(t) : "jsts.geom.GeometryCollection" === t.CLASS_NAME ? this.convertToCollection(t) : void 0
			}, jsts.io.OpenLayersParser.prototype.convertToPoint = function(t) {
				return new OpenLayers.Geometry.Point(t.x, t.y)
			}, jsts.io.OpenLayersParser.prototype.convertToLineString = function(t) {
				var e, n = [];
				for (e = 0; e < t.points.length; e++) {
					var i = t.points[e];
					n.push(this.convertToPoint(i))
				}
				return new OpenLayers.Geometry.LineString(n)
			}, jsts.io.OpenLayersParser.prototype.convertToLinearRing = function(t) {
				var e, n = [];
				for (e = 0; e < t.points.length; e++) {
					var i = t.points[e];
					n.push(this.convertToPoint(i))
				}
				return new OpenLayers.Geometry.LinearRing(n)
			}, jsts.io.OpenLayersParser.prototype.convertToPolygon = function(t) {
				var e, n = [];
				for (n.push(this.convertToLinearRing(t.shell)), e = 0; e < t.holes.length; e++) {
					var i = t.holes[e];
					n.push(this.convertToLinearRing(i))
				}
				return new OpenLayers.Geometry.Polygon(n)
			}, jsts.io.OpenLayersParser.prototype.convertToMultiPoint = function(t) {
				var e, n = [];
				for (e = 0; e < t.geometries.length; e++) {
					var i = t.geometries[e].coordinate;
					n.push(new OpenLayers.Geometry.Point(i.x, i.y))
				}
				return new OpenLayers.Geometry.MultiPoint(n)
			}, jsts.io.OpenLayersParser.prototype.convertToMultiLineString = function(t) {
				var e, n = [];
				for (e = 0; e < t.geometries.length; e++) n.push(this.convertToLineString(t.geometries[e]));
				return new OpenLayers.Geometry.MultiLineString(n)
			}, jsts.io.OpenLayersParser.prototype.convertToMultiPolygon = function(t) {
				var e, n = [];
				for (e = 0; e < t.geometries.length; e++) n.push(this.convertToPolygon(t.geometries[e]));
				return new OpenLayers.Geometry.MultiPolygon(n)
			}, jsts.io.OpenLayersParser.prototype.convertToCollection = function(t) {
				var e, n = [];
				for (e = 0; e < t.geometries.length; e++) {
					var i = t.geometries[e],
						o = this.write(i);
					n.push(o)
				}
				return new OpenLayers.Geometry.Collection(n)
			}, jsts.index.quadtree.Quadtree = function() {
				this.root = new jsts.index.quadtree.Root, this.minExtent = 1
			}, jsts.index.quadtree.Quadtree.ensureExtent = function(t, e) {
				var n, i, o, r;
				return n = t.getMinX(), i = t.getMaxX(), o = t.getMinY(), r = t.getMaxY(), n !== i && o !== r ? t : (n === i && (n -= e / 2, i = n + e / 2), o === r && (o -= e / 2, r = o + e / 2), new jsts.geom.Envelope(n, i, o, r))
			}, jsts.index.quadtree.Quadtree.prototype.depth = function() {
				return this.root.depth()
			}, jsts.index.quadtree.Quadtree.prototype.size = function() {
				return this.root.size()
			}, jsts.index.quadtree.Quadtree.prototype.insert = function(t, e) {
				this.collectStats(t);
				var n = jsts.index.quadtree.Quadtree.ensureExtent(t, this.minExtent);
				this.root.insert(n, e)
			}, jsts.index.quadtree.Quadtree.prototype.remove = function(t, e) {
				var n = jsts.index.quadtree.Quadtree.ensureExtent(t, this.minExtent);
				return this.root.remove(n, e)
			}, jsts.index.quadtree.Quadtree.prototype.query = function() {
				return 1 === arguments.length ? jsts.index.quadtree.Quadtree.prototype.queryByEnvelope.apply(this, arguments) : void jsts.index.quadtree.Quadtree.prototype.queryWithVisitor.apply(this, arguments)
			}, jsts.index.quadtree.Quadtree.prototype.queryByEnvelope = function(t) {
				var e = new jsts.index.ArrayListVisitor;
				return this.query(t, e), e.getItems()
			}, jsts.index.quadtree.Quadtree.prototype.queryWithVisitor = function(t, e) {
				this.root.visit(t, e)
			}, jsts.index.quadtree.Quadtree.prototype.queryAll = function() {
				var t = [];
				return t = this.root.addAllItems(t)
			}, jsts.index.quadtree.Quadtree.prototype.collectStats = function(t) {
				var e = t.getWidth();
				e < this.minExtent && e > 0 && (this.minExtent = e);
				var n = t.getHeight();
				n < this.minExtent && n > 0 && (this.minExtent = n)
			}, jsts.operation.relate.RelateNodeFactory = function() {}, jsts.operation.relate.RelateNodeFactory.prototype = new jsts.geomgraph.NodeFactory, jsts.operation.relate.RelateNodeFactory.prototype.createNode = function(t) {
				return new jsts.operation.relate.RelateNode(t, new jsts.operation.relate.EdgeEndBundleStar)
			}, jsts.index.quadtree.Key = function(t) {
				this.pt = new jsts.geom.Coordinate, this.level = 0, this.env = null, this.computeKey(t)
			}, jsts.index.quadtree.Key.computeQuadLevel = function(t) {
				var e, n, i, o;
				return e = t.getWidth(), n = t.getHeight(), i = e > n ? e : n, o = jsts.index.DoubleBits.exponent(i) + 1
			}, jsts.index.quadtree.Key.prototype.getPoint = function() {
				return this.pt
			}, jsts.index.quadtree.Key.prototype.getLevel = function() {
				return this.level
			}, jsts.index.quadtree.Key.prototype.getEnvelope = function() {
				return this.env
			}, jsts.index.quadtree.Key.prototype.getCentre = function() {
				var t, e;
				return t = (this.env.getMinX() + this.env.getMaxX()) / 2, e = (this.env.getMinY() + this.env.getMaxY()) / 2, new jsts.geom.Coordinate(t, e)
			}, jsts.index.quadtree.Key.prototype.computeKey = function() {
				arguments[0] instanceof jsts.geom.Envelope ? this.computeKeyFromEnvelope(arguments[0]) : this.computeKeyFromLevel(arguments[0], arguments[1])
			}, jsts.index.quadtree.Key.prototype.computeKeyFromEnvelope = function(t) {
				for (this.level = jsts.index.quadtree.Key.computeQuadLevel(t), this.env = new jsts.geom.Envelope, this.computeKey(this.level, t); !this.env.contains(t);) this.level += 1, this.computeKey(this.level, t)
			}, jsts.index.quadtree.Key.prototype.computeKeyFromLevel = function(t, e) {
				var n = jsts.index.DoubleBits.powerOf2(t);
				this.pt.x = Math.floor(e.getMinX() / n) * n, this.pt.y = Math.floor(e.getMinY() / n) * n, this.env.init(this.pt.x, this.pt.x + n, this.pt.y, this.pt.y + n)
			}, jsts.geom.CoordinateArrays = function() {
				throw new jsts.error.AbstractMethodInvocationError
			}, jsts.geom.CoordinateArrays.copyDeep = function() {
				return 1 === arguments.length ? jsts.geom.CoordinateArrays.copyDeep1(arguments[0]) : void(5 === arguments.length && jsts.geom.CoordinateArrays.copyDeep2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]))
			}, jsts.geom.CoordinateArrays.copyDeep1 = function(t) {
				for (var e = [], n = 0; n < t.length; n++) e[n] = new jsts.geom.Coordinate(t[n]);
				return e
			}, jsts.geom.CoordinateArrays.copyDeep2 = function(t, e, n, i, o) {
				for (var r = 0; o > r; r++) n[i + r] = new jsts.geom.Coordinate(t[e + r])
			}, jsts.geom.CoordinateArrays.removeRepeatedPoints = function(t) {
				var e;
				return this.hasRepeatedPoints(t) ? (e = new jsts.geom.CoordinateList(t, (!1)), e.toCoordinateArray()) : t
			}, jsts.geom.CoordinateArrays.hasRepeatedPoints = function(t) {
				var e;
				for (e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;
				return !1
			}, jsts.geom.CoordinateArrays.ptNotInList = function(t, e) {
				for (var n = 0; n < t.length; n++) {
					var i = t[n];
					if (jsts.geom.CoordinateArrays.indexOf(i, e) < 0) return i
				}
				return null
			}, jsts.geom.CoordinateArrays.increasingDirection = function(t) {
				for (var e = 0; e < parseInt(t.length / 2); e++) {
					var n = t.length - 1 - e,
						i = t[e].compareTo(t[n]);
					if (0 != i) return i
				}
				return 1
			}, jsts.geom.CoordinateArrays.minCoordinate = function(t) {
				for (var e = null, n = 0; n < t.length; n++)(null === e || e.compareTo(t[n]) > 0) && (e = t[n]);
				return e
			}, jsts.geom.CoordinateArrays.scroll = function(t, e) {
				var n = jsts.geom.CoordinateArrays.indexOf(e, t);
				if (!(0 > n)) {
					var i = t.slice(n).concat(t.slice(0, n));
					for (n = 0; n < i.length; n++) t[n] = i[n]
				}
			}, jsts.geom.CoordinateArrays.indexOf = function(t, e) {
				for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;
				return -1
			}, jsts.operation.overlay.MinimalEdgeRing = function(t, e) {
				jsts.geomgraph.EdgeRing.call(this, t, e)
			}, jsts.operation.overlay.MinimalEdgeRing.prototype = new jsts.geomgraph.EdgeRing, jsts.operation.overlay.MinimalEdgeRing.constructor = jsts.operation.overlay.MinimalEdgeRing, jsts.operation.overlay.MinimalEdgeRing.prototype.getNext = function(t) {
				return t.getNextMin()
			}, jsts.operation.overlay.MinimalEdgeRing.prototype.setEdgeRing = function(t, e) {
				t.setMinEdgeRing(e)
			}, jsts.triangulate.DelaunayTriangulationBuilder = function() {
				this.siteCoords = null, this.tolerance = 0, this.subdiv = null
			}, jsts.triangulate.DelaunayTriangulationBuilder.extractUniqueCoordinates = function(t) {
				if (void 0 === t || null === t) return new jsts.geom.CoordinateList([], (!1)).toArray();
				var e = t.getCoordinates();
				return jsts.triangulate.DelaunayTriangulationBuilder.unique(e)
			}, jsts.triangulate.DelaunayTriangulationBuilder.unique = function(t) {
				t.sort(function(t, e) {
					return t.compareTo(e)
				});
				var e = new jsts.geom.CoordinateList(t, (!1));
				return e.toArray()
			}, jsts.triangulate.DelaunayTriangulationBuilder.toVertices = function(t) {
				var e, n = new Array(t.length),
					i = 0,
					o = t.length;
				for (i; o > i; i++) e = t[i], n[i] = new jsts.triangulate.quadedge.Vertex(e);
				return n
			}, jsts.triangulate.DelaunayTriangulationBuilder.envelope = function(t) {
				var e = new jsts.geom.Envelope,
					n = 0,
					i = t.length;
				for (n; i > n; n++) e.expandToInclude(t[n]);
				return e
			}, jsts.triangulate.DelaunayTriangulationBuilder.prototype.setSites = function() {
				var t = arguments[0];
				t instanceof jsts.geom.Geometry || t instanceof jsts.geom.Coordinate || t instanceof jsts.geom.Point || t instanceof jsts.geom.MultiPoint || t instanceof jsts.geom.LineString || t instanceof jsts.geom.MultiLineString || t instanceof jsts.geom.LinearRing || t instanceof jsts.geom.Polygon || t instanceof jsts.geom.MultiPolygon ? this.setSitesFromGeometry(t) : this.setSitesFromCollection(t)
			}, jsts.triangulate.DelaunayTriangulationBuilder.prototype.setSitesFromGeometry = function(t) {
				this.siteCoords = jsts.triangulate.DelaunayTriangulationBuilder.extractUniqueCoordinates(t)
			}, jsts.triangulate.DelaunayTriangulationBuilder.prototype.setSitesFromCollection = function(t) {
				this.siteCoords = jsts.triangulate.DelaunayTriangulationBuilder.unique(t)
			}, jsts.triangulate.DelaunayTriangulationBuilder.prototype.setTolerance = function(t) {
				this.tolerance = t
			}, jsts.triangulate.DelaunayTriangulationBuilder.prototype.create = function() {
				if (null === this.subdiv) {
					var t, e, n;
					t = jsts.triangulate.DelaunayTriangulationBuilder.envelope(this.siteCoords), e = jsts.triangulate.DelaunayTriangulationBuilder.toVertices(this.siteCoords), this.subdiv = new jsts.triangulate.quadedge.QuadEdgeSubdivision(t, this.tolerance), n = new jsts.triangulate.IncrementalDelaunayTriangulator(this.subdiv), n.insertSites(e)
				}
			}, jsts.triangulate.DelaunayTriangulationBuilder.prototype.getSubdivision = function() {
				return this.create(), this.subdiv
			}, jsts.triangulate.DelaunayTriangulationBuilder.prototype.getEdges = function(t) {
				return this.create(), this.subdiv.getEdges(t)
			}, jsts.triangulate.DelaunayTriangulationBuilder.prototype.getTriangles = function(t) {
				return this.create(), this.subdiv.getTriangles(t)
			}, jsts.algorithm.RayCrossingCounter = function(t) {
				this.p = t
			}, jsts.algorithm.RayCrossingCounter.locatePointInRing = function(t, e) {
				for (var n = new jsts.algorithm.RayCrossingCounter(t), i = 1; i < e.length; i++) {
					var o = e[i],
						r = e[i - 1];
					if (n.countSegment(o, r), n.isOnSegment()) return n.getLocation()
				}
				return n.getLocation()
			}, jsts.algorithm.RayCrossingCounter.prototype.p = null, jsts.algorithm.RayCrossingCounter.prototype.crossingCount = 0, jsts.algorithm.RayCrossingCounter.prototype.isPointOnSegment = !1, jsts.algorithm.RayCrossingCounter.prototype.countSegment = function(t, e) {
				if (!(t.x < this.p.x && e.x < this.p.x)) {
					if (this.p.x == e.x && this.p.y === e.y) return void(this.isPointOnSegment = !0);
					if (t.y === this.p.y && e.y === this.p.y) {
						var n = t.x,
							i = e.x;
						return n > i && (n = e.x, i = t.x), void(this.p.x >= n && this.p.x <= i && (this.isPointOnSegment = !0))
					}
					if (t.y > this.p.y && e.y <= this.p.y || e.y > this.p.y && t.y <= this.p.y) {
						var o = t.x - this.p.x,
							r = t.y - this.p.y,
							s = e.x - this.p.x,
							a = e.y - this.p.y,
							l = jsts.algorithm.RobustDeterminant.signOfDet2x2(o, r, s, a);
						if (0 === l) return void(this.isPointOnSegment = !0);
						r > a && (l = -l), l > 0 && this.crossingCount++
					}
				}
			}, jsts.algorithm.RayCrossingCounter.prototype.isOnSegment = function() {
				return jsts.geom.isPointOnSegment
			}, jsts.algorithm.RayCrossingCounter.prototype.getLocation = function() {
				return this.isPointOnSegment ? jsts.geom.Location.BOUNDARY : this.crossingCount % 2 === 1 ? jsts.geom.Location.INTERIOR : jsts.geom.Location.EXTERIOR
			}, jsts.algorithm.RayCrossingCounter.prototype.isPointInPolygon = function() {
				return this.getLocation() !== jsts.geom.Location.EXTERIOR
			}, jsts.operation.BoundaryOp = function(t, e) {
				this.geom = t, this.geomFact = t.getFactory(), this.bnRule = e || jsts.algorithm.BoundaryNodeRule.MOD2_BOUNDARY_RULE
			}, jsts.operation.BoundaryOp.prototype.geom = null, jsts.operation.BoundaryOp.prototype.geomFact = null, jsts.operation.BoundaryOp.prototype.bnRule = null, jsts.operation.BoundaryOp.prototype.getBoundary = function() {
				return this.geom instanceof jsts.geom.LineString ? this.boundaryLineString(this.geom) : this.geom instanceof jsts.geom.MultiLineString ? this.boundaryMultiLineString(this.geom) : this.geom.getBoundary()
			}, jsts.operation.BoundaryOp.prototype.getEmptyMultiPoint = function() {
				return this.geomFact.createMultiPoint(null)
			}, jsts.operation.BoundaryOp.prototype.boundaryMultiLineString = function(t) {
				if (this.geom.isEmpty()) return this.getEmptyMultiPoint();
				var e = this.computeBoundaryCoordinates(t);
				return 1 == e.length ? this.geomFact.createPoint(e[0]) : this.geomFact.createMultiPoint(e)
			}, jsts.operation.BoundaryOp.prototype.endpoints = null, jsts.operation.BoundaryOp.prototype.computeBoundaryCoordinates = function(t) {
				var e, n, i, o = [];
				for (this.endpoints = [], e = 0; e < t.getNumGeometries(); e++) n = t.getGeometryN(e), 0 != n.getNumPoints() && (this.addEndpoint(n.getCoordinateN(0)), this.addEndpoint(n.getCoordinateN(n.getNumPoints() - 1)));
				for (e = 0; e < this.endpoints.length; e++) i = this.endpoints[e], this.bnRule.isInBoundary(i.count) && o.push(i.coordinate);
				return o
			}, jsts.operation.BoundaryOp.prototype.addEndpoint = function(t) {
				var e, n, i = !1;
				for (e = 0; e < this.endpoints.length; e++) if (n = this.endpoints[e], n.coordinate.equals(t)) {
					i = !0;
					break
				}
				i || (n = {}, n.coordinate = t, n.count = 0, this.endpoints.push(n)), n.count++
			}, jsts.operation.BoundaryOp.prototype.boundaryLineString = function(t) {
				if (this.geom.isEmpty()) return this.getEmptyMultiPoint();
				if (t.isClosed()) {
					var e = this.bnRule.isInBoundary(2);
					return e ? t.getStartPoint() : this.geomFact.createMultiPoint(null);
				}
				return this.geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()])
			}, jsts.operation.buffer.OffsetCurveSetBuilder = function(t, e, n) {
				this.inputGeom = t, this.distance = e, this.curveBuilder = n, this.curveList = new javascript.util.ArrayList
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.inputGeom = null, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.distance = null, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.curveBuilder = null, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.curveList = null, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.getCurves = function() {
				return this.add(this.inputGeom), this.curveList
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addCurve = function(t, e, n) {
				if (!(null == t || t.length < 2)) {
					var i = new jsts.noding.NodedSegmentString(t, new jsts.geomgraph.Label(0, jsts.geom.Location.BOUNDARY, e, n));
					this.curveList.add(i)
				}
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.add = function(t) {
				if (!t.isEmpty()) if (t instanceof jsts.geom.Polygon) this.addPolygon(t);
				else if (t instanceof jsts.geom.LineString) this.addLineString(t);
				else if (t instanceof jsts.geom.Point) this.addPoint(t);
				else if (t instanceof jsts.geom.MultiPoint) this.addCollection(t);
				else if (t instanceof jsts.geom.MultiLineString) this.addCollection(t);
				else if (t instanceof jsts.geom.MultiPolygon) this.addCollection(t);
				else {
					if (!(t instanceof jsts.geom.GeometryCollection)) throw new jsts.error.IllegalArgumentError;
					this.addCollection(t)
				}
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addCollection = function(t) {
				for (var e = 0; e < t.getNumGeometries(); e++) {
					var n = t.getGeometryN(e);
					this.add(n)
				}
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addPoint = function(t) {
				if (!(this.distance <= 0)) {
					var e = t.getCoordinates(),
						n = this.curveBuilder.getLineCurve(e, this.distance);
					this.addCurve(n, jsts.geom.Location.EXTERIOR, jsts.geom.Location.INTERIOR)
				}
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addLineString = function(t) {
				if (!(this.distance <= 0) || this.curveBuilder.getBufferParameters().isSingleSided()) {
					var e = jsts.geom.CoordinateArrays.removeRepeatedPoints(t.getCoordinates()),
						n = this.curveBuilder.getLineCurve(e, this.distance);
					this.addCurve(n, jsts.geom.Location.EXTERIOR, jsts.geom.Location.INTERIOR)
				}
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addPolygon = function(t) {
				var e = this.distance,
					n = jsts.geomgraph.Position.LEFT;
				this.distance < 0 && (e = -this.distance, n = jsts.geomgraph.Position.RIGHT);
				var i = t.getExteriorRing(),
					o = jsts.geom.CoordinateArrays.removeRepeatedPoints(i.getCoordinates());
				if (!(this.distance < 0 && this.isErodedCompletely(i, this.distance) || this.distance <= 0 && o.length < 3)) {
					this.addPolygonRing(o, e, n, jsts.geom.Location.EXTERIOR, jsts.geom.Location.INTERIOR);
					for (var r = 0; r < t.getNumInteriorRing(); r++) {
						var s = t.getInteriorRingN(r),
							a = jsts.geom.CoordinateArrays.removeRepeatedPoints(s.getCoordinates());
						this.distance > 0 && this.isErodedCompletely(s, -this.distance) || this.addPolygonRing(a, e, jsts.geomgraph.Position.opposite(n), jsts.geom.Location.INTERIOR, jsts.geom.Location.EXTERIOR)
					}
				}
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.addPolygonRing = function(t, e, n, i, o) {
				if (!(0 == e && t.length < jsts.geom.LinearRing.MINIMUM_VALID_SIZE)) {
					var r = i,
						s = o;
					t.length >= jsts.geom.LinearRing.MINIMUM_VALID_SIZE && jsts.algorithm.CGAlgorithms.isCCW(t) && (r = o, s = i, n = jsts.geomgraph.Position.opposite(n));
					var a = this.curveBuilder.getRingCurve(t, n, e);
					this.addCurve(a, r, s)
				}
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.isErodedCompletely = function(t, e) {
				var n = t.getCoordinates();
				if (n.length < 4) return 0 > e;
				if (4 == n.length) return this.isTriangleErodedCompletely(n, e);
				var i = t.getEnvelopeInternal(),
					o = Math.min(i.getHeight(), i.getWidth());
				return 0 > e && 2 * Math.abs(e) > o
			}, jsts.operation.buffer.OffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function(t, e) {
				var n = new jsts.geom.Triangle(t[0], t[1], t[2]),
					i = n.inCentre(),
					o = jsts.algorithm.CGAlgorithms.distancePointLine(i, n.p0, n.p1);
				return o < Math.abs(e)
			}, jsts.operation.buffer.BufferSubgraph = function() {
				this.dirEdgeList = new javascript.util.ArrayList, this.nodes = new javascript.util.ArrayList, this.finder = new jsts.operation.buffer.RightmostEdgeFinder
			}, jsts.operation.buffer.BufferSubgraph.prototype.finder = null, jsts.operation.buffer.BufferSubgraph.prototype.dirEdgeList = null, jsts.operation.buffer.BufferSubgraph.prototype.nodes = null, jsts.operation.buffer.BufferSubgraph.prototype.rightMostCoord = null, jsts.operation.buffer.BufferSubgraph.prototype.env = null, jsts.operation.buffer.BufferSubgraph.prototype.getDirectedEdges = function() {
				return this.dirEdgeList
			}, jsts.operation.buffer.BufferSubgraph.prototype.getNodes = function() {
				return this.nodes
			}, jsts.operation.buffer.BufferSubgraph.prototype.getEnvelope = function() {
				if (null === this.env) {
					for (var t = new jsts.geom.Envelope, e = this.dirEdgeList.iterator(); e.hasNext();) for (var n = e.next(), i = n.getEdge().getCoordinates(), o = 0; o < i.length - 1; o++) t.expandToInclude(i[o]);
					this.env = t
				}
				return this.env
			}, jsts.operation.buffer.BufferSubgraph.prototype.getRightmostCoordinate = function() {
				return this.rightMostCoord
			}, jsts.operation.buffer.BufferSubgraph.prototype.create = function(t) {
				this.addReachable(t), this.finder.findEdge(this.dirEdgeList), this.rightMostCoord = this.finder.getCoordinate()
			}, jsts.operation.buffer.BufferSubgraph.prototype.addReachable = function(t) {
				var e = [];
				for (e.push(t); 0 !== e.length;) {
					var n = e.pop();
					this.add(n, e)
				}
			}, jsts.operation.buffer.BufferSubgraph.prototype.add = function(t, e) {
				t.setVisited(!0), this.nodes.add(t);
				for (var n = t.getEdges().iterator(); n.hasNext();) {
					var i = n.next();
					this.dirEdgeList.add(i);
					var o = i.getSym(),
						r = o.getNode();
					r.isVisited() || e.push(r)
				}
			}, jsts.operation.buffer.BufferSubgraph.prototype.clearVisitedEdges = function() {
				for (var t = this.dirEdgeList.iterator(); t.hasNext();) {
					var e = t.next();
					e.setVisited(!1)
				}
			}, jsts.operation.buffer.BufferSubgraph.prototype.computeDepth = function(t) {
				this.clearVisitedEdges();
				var e = this.finder.getEdge();
				e.getNode(), e.getLabel(), e.setEdgeDepths(jsts.geomgraph.Position.RIGHT, t), this.copySymDepths(e), this.computeDepths(e)
			}, jsts.operation.buffer.BufferSubgraph.prototype.computeDepths = function(t) {
				var e = [],
					n = [],
					i = t.getNode();
				for (n.push(i), e.push(i), t.setVisited(!0); 0 !== n.length;) {
					var o = n.shift();
					e.push(o), this.computeNodeDepth(o);
					for (var r = o.getEdges().iterator(); r.hasNext();) {
						var s = r.next(),
							a = s.getSym();
						if (!a.isVisited()) {
							var l = a.getNode(); - 1 === e.indexOf(l) && (n.push(l), e.push(l))
						}
					}
				}
			}, jsts.operation.buffer.BufferSubgraph.prototype.computeNodeDepth = function(t) {
				for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {
					var i = n.next();
					if (i.isVisited() || i.getSym().isVisited()) {
						e = i;
						break
					}
				}
				if (null == e) throw new jsts.error.TopologyError("unable to find edge to compute depths at " + t.getCoordinate());
				t.getEdges().computeDepths(e);
				for (var n = t.getEdges().iterator(); n.hasNext();) {
					var i = n.next();
					i.setVisited(!0), this.copySymDepths(i)
				}
			}, jsts.operation.buffer.BufferSubgraph.prototype.copySymDepths = function(t) {
				var e = t.getSym();
				e.setDepth(jsts.geomgraph.Position.LEFT, t.getDepth(jsts.geomgraph.Position.RIGHT)), e.setDepth(jsts.geomgraph.Position.RIGHT, t.getDepth(jsts.geomgraph.Position.LEFT))
			}, jsts.operation.buffer.BufferSubgraph.prototype.findResultEdges = function() {
				for (var t = this.dirEdgeList.iterator(); t.hasNext();) {
					var e = t.next();
					e.getDepth(jsts.geomgraph.Position.RIGHT) >= 1 && e.getDepth(jsts.geomgraph.Position.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0)
				}
			}, jsts.operation.buffer.BufferSubgraph.prototype.compareTo = function(t) {
				var e = t;
				return this.rightMostCoord.x < e.rightMostCoord.x ? -1 : this.rightMostCoord.x > e.rightMostCoord.x ? 1 : 0
			}, jsts.simplify.DPTransformer = function(t, e) {
				this.distanceTolerance = t, this.isEnsureValidTopology = e
			}, jsts.simplify.DPTransformer.prototype = new jsts.geom.util.GeometryTransformer, jsts.simplify.DPTransformer.prototype.distanceTolerance = null, jsts.simplify.DPTransformer.prototype.isEnsureValidTopology = null, jsts.simplify.DPTransformer.prototype.transformCoordinates = function(t) {
				var e = t,
					n = null;
				return n = 0 == e.length ? [] : jsts.simplify.DouglasPeuckerLineSimplifier.simplify(e, this.distanceTolerance)
			}, jsts.simplify.DPTransformer.prototype.transformPolygon = function(t, e) {
				if (t.isEmpty()) return null;
				var n = jsts.geom.util.GeometryTransformer.prototype.transformPolygon.apply(this, arguments);
				return e instanceof jsts.geom.MultiPolygon ? n : this.createValidArea(n)
			}, jsts.simplify.DPTransformer.prototype.transformLinearRing = function(t, e) {
				var n = e instanceof jsts.geom.Polygon,
					i = jsts.geom.util.GeometryTransformer.prototype.transformLinearRing.apply(this, arguments);
				return !n || i instanceof jsts.geom.LinearRing ? i : null
			}, jsts.simplify.DPTransformer.prototype.transformMultiPolygon = function() {
				var t = jsts.geom.util.GeometryTransformer.prototype.transformMultiPolygon.apply(this, arguments);
				return this.createValidArea(t)
			}, jsts.simplify.DPTransformer.prototype.createValidArea = function(t) {
				return this.isEnsureValidTopology ? t.buffer(0) : t
			}, jsts.geom.util.GeometryExtracter = function(t, e) {
				this.clz = t, this.comps = e
			}, jsts.geom.util.GeometryExtracter.prototype = new jsts.geom.GeometryFilter, jsts.geom.util.GeometryExtracter.prototype.clz = null, jsts.geom.util.GeometryExtracter.prototype.comps = null, jsts.geom.util.GeometryExtracter.extract = function(t, e, n) {
				return n = n || new javascript.util.ArrayList, t instanceof e ? n.add(t) : (t instanceof jsts.geom.GeometryCollection || t instanceof jsts.geom.MultiPoint || t instanceof jsts.geom.MultiLineString || t instanceof jsts.geom.MultiPolygon) && t.apply(new jsts.geom.util.GeometryExtracter(e, n)), n
			}, jsts.geom.util.GeometryExtracter.prototype.filter = function(t) {
				(null === this.clz || t instanceof this.clz) && this.comps.add(t)
			}, function() {
				var t = jsts.operation.overlay.OverlayOp,
					e = jsts.operation.overlay.snap.SnapOverlayOp,
					n = function(t, e) {
						this.geom = [], this.geom[0] = t, this.geom[1] = e
					};
				n.overlayOp = function(t, e, i) {
					var o = new n(t, e);
					return o.getResultGeometry(i)
				}, n.intersection = function(e, n) {
					return overlayOp(e, n, t.INTERSECTION)
				}, n.union = function(e, n) {
					return overlayOp(e, n, t.UNION)
				}, n.difference = function(e, n) {
					return overlayOp(e, n, t.DIFFERENCE)
				}, n.symDifference = function(e, n) {
					return overlayOp(e, n, t.SYMDIFFERENCE)
				}, n.prototype.geom = null, n.prototype.getResultGeometry = function(n) {
					var i = null,
						o = !1,
						r = null;
					try {
						i = t.overlayOp(this.geom[0], this.geom[1], n);
						var s = !0;
						s && (o = !0)
					} catch (a) {
						r = a
					}
					if (!o) try {
						i = e.overlayOp(this.geom[0], this.geom[1], n)
					} catch (a) {
						throw r
					}
					return i
				}, jsts.operation.overlay.snap.SnapIfNeededOverlayOp = n
			}(), function() {
				var t = jsts.geom.util.GeometryExtracter,
					e = jsts.operation.union.CascadedPolygonUnion,
					n = jsts.operation.union.PointGeometryUnion,
					i = jsts.operation.overlay.OverlayOp,
					o = jsts.operation.overlay.snap.SnapIfNeededOverlayOp,
					r = javascript.util.ArrayList;
				jsts.operation.union.UnaryUnionOp = function(t, e) {
					this.polygons = new r, this.lines = new r, this.points = new r, e && (this.geomFact = e), this.extract(t)
				}, jsts.operation.union.UnaryUnionOp.union = function(t, e) {
					var n = new jsts.operation.union.UnaryUnionOp(t, e);
					return n.union()
				}, jsts.operation.union.UnaryUnionOp.prototype.polygons = null, jsts.operation.union.UnaryUnionOp.prototype.lines = null, jsts.operation.union.UnaryUnionOp.prototype.points = null, jsts.operation.union.UnaryUnionOp.prototype.geomFact = null, jsts.operation.union.UnaryUnionOp.prototype.extract = function(e) {
					if (e instanceof r) for (var n = e.iterator(); n.hasNext();) {
						var i = n.next();
						this.extract(i)
					} else null === this.geomFact && (this.geomFact = e.getFactory()), t.extract(e, jsts.geom.Polygon, this.polygons), t.extract(e, jsts.geom.LineString, this.lines), t.extract(e, jsts.geom.Point, this.points)
				}, jsts.operation.union.UnaryUnionOp.prototype.union = function() {
					if (null === this.geomFact) return null;
					var t = null;
					if (this.points.size() > 0) {
						var i = this.geomFact.buildGeometry(this.points);
						t = this.unionNoOpt(i)
					}
					var o = null;
					if (this.lines.size() > 0) {
						var r = this.geomFact.buildGeometry(this.lines);
						o = this.unionNoOpt(r)
					}
					var s = null;
					this.polygons.size() > 0 && (s = e.union(this.polygons));
					var a = this.unionWithNull(o, s),
						l = null;
					return l = null === t ? a : null === a ? t : n(t, a), null === l ? this.geomFact.createGeometryCollection(null) : l
				}, jsts.operation.union.UnaryUnionOp.prototype.unionWithNull = function(t, e) {
					return null === t && null === e ? null : null === e ? t : null === t ? e : t.union(e)
				}, jsts.operation.union.UnaryUnionOp.prototype.unionNoOpt = function(t) {
					var e = this.geomFact.createPoint(null);
					return o.overlayOp(t, e, i.UNION)
				}
			}(), jsts.index.kdtree.KdNode = function() {
				this.left = null, this.right = null, this.count = 1, 2 === arguments.length ? this.initializeFromCoordinate.apply(this, arguments[0], arguments[1]) : 3 === arguments.length && this.initializeFromXY.apply(this, arguments[0], arguments[1], arguments[2])
			}, jsts.index.kdtree.KdNode.prototype.initializeFromXY = function(t, e, n) {
				this.p = new jsts.geom.Coordinate(t, e), this.data = n
			}, jsts.index.kdtree.KdNode.prototype.initializeFromCoordinate = function(t, e) {
				this.p = t, this.data = e
			}, jsts.index.kdtree.KdNode.prototype.getX = function() {
				return this.p.x
			}, jsts.index.kdtree.KdNode.prototype.getY = function() {
				return this.p.y
			}, jsts.index.kdtree.KdNode.prototype.getCoordinate = function() {
				return this.p
			}, jsts.index.kdtree.KdNode.prototype.getData = function() {
				return this.data
			}, jsts.index.kdtree.KdNode.prototype.getLeft = function() {
				return this.left
			}, jsts.index.kdtree.KdNode.prototype.getRight = function() {
				return this.right
			}, jsts.index.kdtree.KdNode.prototype.increment = function() {
				this.count += 1
			}, jsts.index.kdtree.KdNode.prototype.getCount = function() {
				return this.count
			}, jsts.index.kdtree.KdNode.prototype.isRepeated = function() {
				return count > 1
			}, jsts.index.kdtree.KdNode.prototype.setLeft = function(t) {
				this.left = t
			}, jsts.index.kdtree.KdNode.prototype.setRight = function(t) {
				this.right = t
			}, jsts.algorithm.InteriorPointPoint = function(t) {
				this.minDistance = Number.MAX_VALUE, this.interiorPoint = null, this.centroid = t.getCentroid().getCoordinate(), this.add(t)
			}, jsts.algorithm.InteriorPointPoint.prototype.add = function(t) {
				if (t instanceof jsts.geom.Point) this.addPoint(t.getCoordinate());
				else if (t instanceof jsts.geom.GeometryCollection) for (var e = 0; e < t.getNumGeometries(); e++) this.add(t.getGeometryN(e))
			}, jsts.algorithm.InteriorPointPoint.prototype.addPoint = function(t) {
				var e = t.distance(this.centroid);
				e < this.minDistance && (this.interiorPoint = new jsts.geom.Coordinate(t), this.minDistance = e)
			}, jsts.algorithm.InteriorPointPoint.prototype.getInteriorPoint = function() {
				return this.interiorPoint
			}, function() {
				jsts.geom.MultiLineString = function(t, e) {
					this.geometries = t || [], this.factory = e
				}, jsts.geom.MultiLineString.prototype = new jsts.geom.GeometryCollection, jsts.geom.MultiLineString.constructor = jsts.geom.MultiLineString, jsts.geom.MultiLineString.prototype.getBoundary = function() {
					return new jsts.operation.BoundaryOp(this).getBoundary()
				}, jsts.geom.MultiLineString.prototype.equalsExact = function(t, e) {
					return !!this.isEquivalentClass(t) && jsts.geom.GeometryCollection.prototype.equalsExact.call(this, t, e)
				}, jsts.geom.MultiLineString.prototype.CLASS_NAME = "jsts.geom.MultiLineString"
			}(), function() {
				var t = jsts.index.bintree.Interval,
					e = jsts.index.bintree.Root,
					n = function() {
						this.root = new e, this.minExtent = 1
					};
				n.ensureExtent = function(e, n) {
					var i, o;
					return i = e.getMin(), o = e.getMax(), i !== o ? e : (i === o && (i -= n / 2, o = i + n / 2), new t(i, o))
				}, n.prototype.depth = function() {
					return null !== this.root ? this.root.depth() : 0
				}, n.prototype.size = function() {
					return null !== this.root ? this.root.size() : 0
				}, n.prototype.nodeSize = function() {
					return null !== this.root ? this.root.nodeSize() : 0
				}, n.prototype.insert = function(t, e) {
					this.collectStats(t);
					var i = n.ensureExtent(t, this.minExtent);
					this.root.insert(i, e)
				}, n.prototype.remove = function(t, e) {
					var i = n.ensureExtent(t, this.minExtent);
					return this.root.remove(i, e)
				}, n.prototype.iterator = function() {
					var t = new javascript.util.ArrayList;
					return this.root.addAllItems(t), t.iterator()
				}, n.prototype.query = function() {
					if (2 !== arguments.length) {
						var e = arguments[0];
						return !e instanceof t && (e = new t(e, e)), this.queryInterval(e)
					}
					this.queryAndAdd(arguments[0], arguments[1])
				}, n.prototype.queryInterval = function(t) {
					var e = new javascript.util.ArrayList;
					return this.query(t, e), e
				}, n.prototype.queryAndAdd = function(t, e) {
					this.root.addAllItemsFromOverlapping(t, e)
				}, n.prototype.collectStats = function(t) {
					var e = t.getWidth();
					e < this.minExtent && e > 0 && (this.minExtent = e)
				}, jsts.index.bintree.Bintree = n
			}(), jsts.algorithm.InteriorPointArea = function(t) {
				this.factory, this.interiorPoint = null, this.maxWidth = 0, this.factory = t.getFactory(), this.add(t)
			}, jsts.algorithm.InteriorPointArea.avg = function(t, e) {
				return (t + e) / 2
			}, jsts.algorithm.InteriorPointArea.prototype.getInteriorPoint = function() {
				return this.interiorPoint
			}, jsts.algorithm.InteriorPointArea.prototype.add = function(t) {
				if (t instanceof jsts.geom.Polygon) this.addPolygon(t);
				else if (t instanceof jsts.geom.GeometryCollection) for (var e = 0; e < t.getNumGeometries(); e++) this.add(t.getGeometryN(e))
			}, jsts.algorithm.InteriorPointArea.prototype.addPolygon = function(t) {
				if (!t.isEmpty()) {
					var e, n = 0,
						i = this.horizontalBisector(t);
					if (0 == i.getLength()) n = 0, e = i.getCoordinate();
					else {
						var o = i.intersection(t),
							r = this.widestGeometry(o);
						n = r.getEnvelopeInternal().getWidth(), e = this.centre(r.getEnvelopeInternal())
					}(null == this.interiorPoint || n > this.maxWidth) && (this.interiorPoint = e, this.maxWidth = n)
				}
			}, jsts.algorithm.InteriorPointArea.prototype.widestGeometry = function(t) {
				if (t instanceof jsts.geom.GeometryCollection) {
					var e = t;
					if (e.isEmpty()) return e;
					for (var n = e.getGeometryN(0), i = 1; i < e.getNumGeometries(); i++) e.getGeometryN(i).getEnvelopeInternal().getWidth() > n.getEnvelopeInternal().getWidth() && (n = e.getGeometryN(i));
					return n
				}
				return t instanceof jsts.geom.Geometry ? t : void 0
			}, jsts.algorithm.InteriorPointArea.prototype.horizontalBisector = function(t) {
				var e = t.getEnvelopeInternal(),
					n = jsts.algorithm.SafeBisectorFinder.getBisectorY(t);
				return this.factory.createLineString([new jsts.geom.Coordinate(e.getMinX(), n), new jsts.geom.Coordinate(e.getMaxX(), n)])
			}, jsts.algorithm.InteriorPointArea.prototype.centre = function(t) {
				return new jsts.geom.Coordinate(jsts.algorithm.InteriorPointArea.avg(t.getMinX(), t.getMaxX()), jsts.algorithm.InteriorPointArea.avg(t.getMinY(), t.getMaxY()))
			}, jsts.algorithm.SafeBisectorFinder = function(t) {
				this.poly, this.centreY, this.hiY = Number.MAX_VALUE, this.loY = -Number.MAX_VALUE, this.poly = t, this.hiY = t.getEnvelopeInternal().getMaxY(), this.loY = t.getEnvelopeInternal().getMinY(), this.centreY = jsts.algorithm.InteriorPointArea.avg(this.loY, this.hiY)
			}, jsts.algorithm.SafeBisectorFinder.getBisectorY = function(t) {
				var e = new jsts.algorithm.SafeBisectorFinder(t);
				return e.getBisectorY()
			}, jsts.algorithm.SafeBisectorFinder.prototype.getBisectorY = function() {
				this.process(this.poly.getExteriorRing());
				for (var t = 0; t < this.poly.getNumInteriorRing(); t++) this.process(this.poly.getInteriorRingN(t));
				var e = jsts.algorithm.InteriorPointArea.avg(this.hiY, this.loY);
				return e
			}, jsts.algorithm.SafeBisectorFinder.prototype.process = function(t) {
				for (var e = t.getCoordinateSequence(), n = 0; n < e.length; n++) {
					var i = e[n].y;
					this.updateInterval(i)
				}
			}, jsts.algorithm.SafeBisectorFinder.prototype.updateInterval = function(t) {
				t <= this.centreY ? t > this.loY && (this.loY = t) : t > this.centreY && t < this.hiY && (this.hiY = t)
			}, jsts.operation.buffer.BufferParameters = function(t, e, n, i) {
				t && this.setQuadrantSegments(t), e && this.setEndCapStyle(e), n && this.setJoinStyle(n), i && this.setMitreLimit(i)
			}, jsts.operation.buffer.BufferParameters.CAP_ROUND = 1, jsts.operation.buffer.BufferParameters.CAP_FLAT = 2, jsts.operation.buffer.BufferParameters.CAP_SQUARE = 3, jsts.operation.buffer.BufferParameters.JOIN_ROUND = 1, jsts.operation.buffer.BufferParameters.JOIN_MITRE = 2, jsts.operation.buffer.BufferParameters.JOIN_BEVEL = 3, jsts.operation.buffer.BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8, jsts.operation.buffer.BufferParameters.DEFAULT_MITRE_LIMIT = 5, jsts.operation.buffer.BufferParameters.prototype.quadrantSegments = jsts.operation.buffer.BufferParameters.DEFAULT_QUADRANT_SEGMENTS, jsts.operation.buffer.BufferParameters.prototype.endCapStyle = jsts.operation.buffer.BufferParameters.CAP_ROUND, jsts.operation.buffer.BufferParameters.prototype.joinStyle = jsts.operation.buffer.BufferParameters.JOIN_ROUND, jsts.operation.buffer.BufferParameters.prototype.mitreLimit = jsts.operation.buffer.BufferParameters.DEFAULT_MITRE_LIMIT, jsts.operation.buffer.BufferParameters.prototype._isSingleSided = !1, jsts.operation.buffer.BufferParameters.prototype.getQuadrantSegments = function() {
				return this.quadrantSegments
			}, jsts.operation.buffer.BufferParameters.prototype.setQuadrantSegments = function(t) {
				this.quadrantSegments = t
			}, jsts.operation.buffer.BufferParameters.prototype.setQuadrantSegments = function(t) {
				this.quadrantSegments = t, 0 === this.quadrantSegments && (this.joinStyle = jsts.operation.buffer.BufferParameters.JOIN_BEVEL), this.quadrantSegments < 0 && (this.joinStyle = jsts.operation.buffer.BufferParameters.JOIN_MITRE, this.mitreLimit = Math.abs(this.quadrantSegments)), 0 >= t && (this.quadrantSegments = 1), this.joinStyle !== jsts.operation.buffer.BufferParameters.JOIN_ROUND && (this.quadrantSegments = jsts.operation.buffer.BufferParameters.DEFAULT_QUADRANT_SEGMENTS)
			}, jsts.operation.buffer.BufferParameters.bufferDistanceError = function(t) {
				var e = Math.PI / 2 / t;
				return 1 - Math.cos(e / 2)
			}, jsts.operation.buffer.BufferParameters.prototype.getEndCapStyle = function() {
				return this.endCapStyle
			}, jsts.operation.buffer.BufferParameters.prototype.setEndCapStyle = function(t) {
				this.endCapStyle = t
			}, jsts.operation.buffer.BufferParameters.prototype.getJoinStyle = function() {
				return this.joinStyle
			}, jsts.operation.buffer.BufferParameters.prototype.setJoinStyle = function(t) {
				this.joinStyle = t
			}, jsts.operation.buffer.BufferParameters.prototype.getMitreLimit = function() {
				return this.mitreLimit
			}, jsts.operation.buffer.BufferParameters.prototype.setMitreLimit = function(t) {
				this.mitreLimit = t
			}, jsts.operation.buffer.BufferParameters.prototype.setSingleSided = function(t) {
				this._isSingleSided = t
			}, jsts.operation.buffer.BufferParameters.prototype.isSingleSided = function() {
				return this._isSingleSided
			}, function() {
				jsts.geom.util.ShortCircuitedGeometryVisitor = function() {}, jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.isDone = !1, jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.applyTo = function(t) {
					for (var e = 0; e < t.getNumGeometries() && !this.isDone; e++) {
						var n = t.getGeometryN(e);
						if (n instanceof jsts.geom.GeometryCollection) this.applyTo(n);
						else if (this.visit(n), this.isDone()) return void(this.isDone = !0)
					}
				}, jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.visit = function() {}, jsts.geom.util.ShortCircuitedGeometryVisitor.prototype.isDone = function() {}
			}(), function() {
				var t = function(t) {
						this.rectEnv = t
					};
				t.prototype = new jsts.geom.util.ShortCircuitedGeometryVisitor, t.constructor = t, t.prototype.rectEnv = null, t.prototype.intersects = !1, t.prototype.intersects = function() {
					return this.intersects
				}, t.prototype.visit = function(t) {
					var e = t.getEnvelopeInternal();
					if (this.rectEnv.intersects(e)) return this.rectEnv.contains(e) ? void(this.intersects = !0) : e.getMinX() >= rectEnv.getMinX() && e.getMaxX() <= rectEnv.getMaxX() ? void(this.intersects = !0) : e.getMinY() >= rectEnv.getMinY() && e.getMaxY() <= rectEnv.getMaxY() ? void(this.intersects = !0) : void 0
				}, t.prototype.isDone = function() {
					return 1 == this.intersects
				};
				var e = function(t) {
						this.rectSeq = t.getExteriorRing().getCoordinateSequence(), this.rectEnv = t.getEnvelopeInternal()
					};
				e.prototype = new jsts.geom.util.ShortCircuitedGeometryVisitor, e.constructor = e, e.prototype.rectSeq = null, e.prototype.rectEnv = null, e.prototype.containsPoint = !1, e.prototype.containsPoint = function() {
					return this.containsPoint
				}, e.prototype.visit = function(t) {
					if (t instanceof jsts.geom.Polygon) {
						var e = t.getEnvelopeInternal();
						if (this.rectEnv.intersects(e)) for (var n = new jsts.geom.Coordinate, i = 0; 4 > i; i++) if (this.rectSeq.getCoordinate(i, n), e.contains(n) && SimplePointInAreaLocator.containsPointInPolygon(n, t)) return void(this.containsPoint = !0)
					}
				}, e.prototype.isDone = function() {
					return 1 == this.containsPoint
				};
				var n = function(t) {
						this.rectEnv = t.getEnvelopeInternal(), this.rectIntersector = new RectangleLineIntersector(rectEnv)
					};
				n.prototype = new jsts.geom.util.ShortCircuitedGeometryVisitor, n.constructor = n, n.prototype.rectEnv = null, n.prototype.rectIntersector = null, n.prototype.hasIntersection = !1, n.prototype.p0 = null, n.prototype.p1 = null, n.prototype.intersects = function() {
					return this.hasIntersection
				}, n.prototype.visit = function(t) {
					var e = t.getEnvelopeInternal();
					if (this.rectEnv.intersects(e)) {
						var n = LinearComponentExtracter.getLines(t);
						this.checkIntersectionWithLineStrings(n)
					}
				}, n.prototype.checkIntersectionWithLineStrings = function(t) {
					for (var e = t.iterator(); e.hasNext();) {
						var n = e.next();
						if (this.checkIntersectionWithSegments(n), this.hasIntersection) return
					}
				}, n.prototype.checkIntersectionWithSegments = function(t) {
					for (var e = t.getCoordinateSequence(), n = 1; n < e.length; n++) if (this.p0 = e[n - 1], this.p1 = e[n], rectIntersector.intersects(p0, p1)) return void(this.hasIntersection = !0)
				}, n.prototype.isDone = function() {
					return 1 == this.hasIntersection
				}, jsts.operation.predicate.RectangleIntersects = function(t) {
					this.rectangle = t, this.rectEnv = t.getEnvelopeInternal()
				}, jsts.operation.predicate.RectangleIntersects.intersects = function(t, e) {
					var n = new jsts.operation.predicate.RectangleIntersects(t);
					return n.intersects(e)
				}, jsts.operation.predicate.RectangleIntersects.prototype.rectangle = null, jsts.operation.predicate.RectangleIntersects.prototype.rectEnv = null, jsts.operation.predicate.RectangleIntersects.prototype.intersects = function(i) {
					if (!this.rectEnv.intersects(i.getEnvelopeInternal())) return !1;
					var o = new t(this.rectEnv);
					if (o.applyTo(i), o.intersects()) return !0;
					var r = new e(rectangle);
					if (r.applyTo(i), r.containsPoint()) return !0;
					var s = new n(rectangle);
					return s.applyTo(i), !! s.intersects()
				}
			}(), jsts.operation.buffer.BufferBuilder = function(t) {
				this.bufParams = t, this.edgeList = new jsts.geomgraph.EdgeList
			}, jsts.operation.buffer.BufferBuilder.depthDelta = function(t) {
				var e = t.getLocation(0, jsts.geomgraph.Position.LEFT),
					n = t.getLocation(0, jsts.geomgraph.Position.RIGHT);
				return e === jsts.geom.Location.INTERIOR && n === jsts.geom.Location.EXTERIOR ? 1 : e === jsts.geom.Location.EXTERIOR && n === jsts.geom.Location.INTERIOR ? -1 : 0
			}, jsts.operation.buffer.BufferBuilder.prototype.bufParams = null, jsts.operation.buffer.BufferBuilder.prototype.workingPrecisionModel = null, jsts.operation.buffer.BufferBuilder.prototype.workingNoder = null, jsts.operation.buffer.BufferBuilder.prototype.geomFact = null, jsts.operation.buffer.BufferBuilder.prototype.graph = null, jsts.operation.buffer.BufferBuilder.prototype.edgeList = null, jsts.operation.buffer.BufferBuilder.prototype.setWorkingPrecisionModel = function(t) {
				this.workingPrecisionModel = t
			}, jsts.operation.buffer.BufferBuilder.prototype.setNoder = function(t) {
				this.workingNoder = t
			}, jsts.operation.buffer.BufferBuilder.prototype.buffer = function(t, e) {
				var n = this.workingPrecisionModel;
				null === n && (n = t.getPrecisionModel()), this.geomFact = t.getFactory();
				var i = new jsts.operation.buffer.OffsetCurveBuilder(n, this.bufParams),
					o = new jsts.operation.buffer.OffsetCurveSetBuilder(t, e, i),
					r = o.getCurves();
				if (r.size() <= 0) return this.createEmptyResultGeometry();
				this.computeNodedEdges(r, n), this.graph = new jsts.geomgraph.PlanarGraph(new jsts.operation.overlay.OverlayNodeFactory), this.graph.addEdges(this.edgeList.getEdges());
				var s = this.createSubgraphs(this.graph),
					a = new jsts.operation.overlay.PolygonBuilder(this.geomFact);
				this.buildSubgraphs(s, a);
				var l = a.getPolygons();
				if (l.size() <= 0) return this.createEmptyResultGeometry();
				var u = this.geomFact.buildGeometry(l);
				return u
			}, jsts.operation.buffer.BufferBuilder.prototype.getNoder = function(t) {
				if (null !== this.workingNoder) return this.workingNoder;
				var e = new jsts.noding.MCIndexNoder,
					n = new jsts.algorithm.RobustLineIntersector;
				return n.setPrecisionModel(t), e.setSegmentIntersector(new jsts.noding.IntersectionAdder(n)), e
			}, jsts.operation.buffer.BufferBuilder.prototype.computeNodedEdges = function(t, e) {
				var n = this.getNoder(e);
				n.computeNodes(t);
				for (var i = n.getNodedSubstrings(), o = i.iterator(); o.hasNext();) {
					var r = o.next(),
						s = r.getData(),
						a = new jsts.geomgraph.Edge(r.getCoordinates(), new jsts.geomgraph.Label(s));
					this.insertUniqueEdge(a)
				}
			}, jsts.operation.buffer.BufferBuilder.prototype.insertUniqueEdge = function(t) {
				var e = this.edgeList.findEqualEdge(t);
				if (null != e) {
					var n = e.getLabel(),
						i = t.getLabel();
					e.isPointwiseEqual(t) || (i = new jsts.geomgraph.Label(t.getLabel()), i.flip()), n.merge(i);
					var o = jsts.operation.buffer.BufferBuilder.depthDelta(i),
						r = e.getDepthDelta(),
						s = r + o;
					e.setDepthDelta(s)
				} else this.edgeList.add(t), t.setDepthDelta(jsts.operation.buffer.BufferBuilder.depthDelta(t.getLabel()))
			}, jsts.operation.buffer.BufferBuilder.prototype.createSubgraphs = function(t) {
				for (var e = [], n = t.getNodes().iterator(); n.hasNext();) {
					var i = n.next();
					if (!i.isVisited()) {
						var o = new jsts.operation.buffer.BufferSubgraph;
						o.create(i), e.push(o)
					}
				}
				var r = function(t, e) {
						return t.compareTo(e)
					};
				return e.sort(r), e.reverse(), e
			}, jsts.operation.buffer.BufferBuilder.prototype.buildSubgraphs = function(t, e) {
				for (var n = [], i = 0; i < t.length; i++) {
					var o = t[i],
						r = o.getRightmostCoordinate(),
						s = new jsts.operation.buffer.SubgraphDepthLocater(n),
						a = s.getDepth(r);
					o.computeDepth(a), o.findResultEdges(), n.push(o), e.add(o.getDirectedEdges(), o.getNodes())
				}
			}, jsts.operation.buffer.BufferBuilder.convertSegStrings = function(t) {
				for (var e = new jsts.geom.GeometryFactory, n = new javascript.util.ArrayList; t.hasNext();) {
					var i = t.next(),
						o = e.createLineString(i.getCoordinates());
					n.add(o)
				}
				return e.buildGeometry(n)
			}, jsts.operation.buffer.BufferBuilder.prototype.createEmptyResultGeometry = function() {
				var t = this.geomFact.createPolygon(null, null);
				return t
			}, jsts.noding.SegmentPointComparator = function() {}, jsts.noding.SegmentPointComparator.compare = function(t, e, n) {
				if (e.equals2D(n)) return 0;
				var i = jsts.noding.SegmentPointComparator.relativeSign(e.x, n.x),
					o = jsts.noding.SegmentPointComparator.relativeSign(e.y, n.y);
				switch (t) {
				case 0:
					return jsts.noding.SegmentPointComparator.compareValue(i, o);
				case 1:
					return jsts.noding.SegmentPointComparator.compareValue(o, i);
				case 2:
					return jsts.noding.SegmentPointComparator.compareValue(o, -i);
				case 3:
					return jsts.noding.SegmentPointComparator.compareValue(-i, o);
				case 4:
					return jsts.noding.SegmentPointComparator.compareValue(-i, -o);
				case 5:
					return jsts.noding.SegmentPointComparator.compareValue(-o, -i);
				case 6:
					return jsts.noding.SegmentPointComparator.compareValue(-o, i);
				case 7:
					return jsts.noding.SegmentPointComparator.compareValue(i, -o)
				}
				return 0
			}, jsts.noding.SegmentPointComparator.relativeSign = function(t, e) {
				return e > t ? -1 : t > e ? 1 : 0
			}, jsts.noding.SegmentPointComparator.compareValue = function(t, e) {
				return 0 > t ? -1 : t > 0 ? 1 : 0 > e ? -1 : e > 0 ? 1 : 0
			}, jsts.operation.relate.RelateOp = function() {
				jsts.operation.GeometryGraphOperation.apply(this, arguments), this._relate = new jsts.operation.relate.RelateComputer(this.arg)
			}, jsts.operation.relate.RelateOp.prototype = new jsts.operation.GeometryGraphOperation, jsts.operation.relate.RelateOp.relate = function(t, e, n) {
				var i = new jsts.operation.relate.RelateOp(t, e, n),
					o = i.getIntersectionMatrix();
				return o
			}, jsts.operation.relate.RelateOp.prototype._relate = null, jsts.operation.relate.RelateOp.prototype.getIntersectionMatrix = function() {
				return this._relate.computeIM()
			}, jsts.index.chain.MonotoneChain = function(t, e, n, i) {
				this.pts = t, this.start = e, this.end = n, this.context = i
			}, jsts.index.chain.MonotoneChain.prototype.pts = null, jsts.index.chain.MonotoneChain.prototype.start = null, jsts.index.chain.MonotoneChain.prototype.end = null, jsts.index.chain.MonotoneChain.prototype.env = null, jsts.index.chain.MonotoneChain.prototype.context = null, jsts.index.chain.MonotoneChain.prototype.id = null, jsts.index.chain.MonotoneChain.prototype.setId = function(t) {
				this.id = t
			}, jsts.index.chain.MonotoneChain.prototype.getId = function() {
				return this.id
			}, jsts.index.chain.MonotoneChain.prototype.getContext = function() {
				return this.context
			}, jsts.index.chain.MonotoneChain.prototype.getEnvelope = function() {
				if (null == this.env) {
					var t = this.pts[this.start],
						e = this.pts[this.end];
					this.env = new jsts.geom.Envelope(t, e)
				}
				return this.env
			}, jsts.index.chain.MonotoneChain.prototype.getStartIndex = function() {
				return this.start
			}, jsts.index.chain.MonotoneChain.prototype.getEndIndex = function() {
				return this.end
			}, jsts.index.chain.MonotoneChain.prototype.getLineSegment = function(t, e) {
				e.p0 = this.pts[t], e.p1 = this.pts[t + 1]
			}, jsts.index.chain.MonotoneChain.prototype.getCoordinates = function() {
				for (var t = [], e = 0, n = this.start; n <= this.end; n++) t[e++] = this.pts[n];
				return t
			}, jsts.index.chain.MonotoneChain.prototype.select = function(t, e) {
				this.computeSelect2(t, this.start, this.end, e)
			}, jsts.index.chain.MonotoneChain.prototype.computeSelect2 = function(t, e, n, i) {
				var o = this.pts[e],
					r = this.pts[n];
				if (i.tempEnv1.init(o, r), n - e === 1) return void i.select(this, e);
				if (t.intersects(i.tempEnv1)) {
					var s = parseInt((e + n) / 2);
					s > e && this.computeSelect2(t, e, s, i), n > s && this.computeSelect2(t, s, n, i)
				}
			}, jsts.index.chain.MonotoneChain.prototype.computeOverlaps = function(t, e) {
				return 6 === arguments.length ? this.computeOverlaps2.apply(this, arguments) : void this.computeOverlaps2(this.start, this.end, t, t.start, t.end, e)
			}, jsts.index.chain.MonotoneChain.prototype.computeOverlaps2 = function(t, e, n, i, o, r) {
				var s = this.pts[t],
					a = this.pts[e],
					l = n.pts[i],
					u = n.pts[o];
				if (e - t === 1 && o - i === 1) return void r.overlap(this, t, n, i);
				if (r.tempEnv1.init(s, a), r.tempEnv2.init(l, u), r.tempEnv1.intersects(r.tempEnv2)) {
					var p = parseInt((t + e) / 2),
						h = parseInt((i + o) / 2);
					p > t && (h > i && this.computeOverlaps2(t, p, n, i, h, r), o > h && this.computeOverlaps2(t, p, n, h, o, r)), e > p && (h > i && this.computeOverlaps2(p, e, n, i, h, r), o > h && this.computeOverlaps2(p, e, n, h, o, r))
				}
			}, function() {
				var t = jsts.geom.Location,
					e = jsts.geom.Dimension;
				jsts.geom.IntersectionMatrix = function(n) {
					var i = n;
					void 0 === n || null === n ? (this.matrix = [
						[],
						[],
						[]
					], this.setAll(e.FALSE)) : "string" == typeof n ? this.set(n) : i instanceof jsts.geom.IntersectionMatrix && (this.matrix[t.INTERIOR][t.INTERIOR] = i.matrix[t.INTERIOR][t.INTERIOR], this.matrix[t.INTERIOR][t.BOUNDARY] = i.matrix[t.INTERIOR][t.BOUNDARY], this.matrix[t.INTERIOR][t.EXTERIOR] = i.matrix[t.INTERIOR][t.EXTERIOR], this.matrix[t.BOUNDARY][t.INTERIOR] = i.matrix[t.BOUNDARY][t.INTERIOR], this.matrix[t.BOUNDARY][t.BOUNDARY] = i.matrix[t.BOUNDARY][t.BOUNDARY], this.matrix[t.BOUNDARY][t.EXTERIOR] = i.matrix[t.BOUNDARY][t.EXTERIOR], this.matrix[t.EXTERIOR][t.INTERIOR] = i.matrix[t.EXTERIOR][t.INTERIOR], this.matrix[t.EXTERIOR][t.BOUNDARY] = i.matrix[t.EXTERIOR][t.BOUNDARY], this.matrix[t.EXTERIOR][t.EXTERIOR] = i.matrix[t.EXTERIOR][t.EXTERIOR])
				}, jsts.geom.IntersectionMatrix.prototype.matrix = null, jsts.geom.IntersectionMatrix.prototype.add = function(t) {
					var e, n;
					for (e = 0; 3 > e; e++) for (n = 0; 3 > n; n++) this.setAtLeast(e, n, t.get(e, n))
				}, jsts.geom.IntersectionMatrix.matches = function(t, n) {
					return "string" == typeof t ? jsts.geom.IntersectionMatrix.matches2.call(this, arguments) : "*" === n || ("T" === n && (t >= 0 || t === e.TRUE) || ("F" === n && t === e.FALSE || ("0" === n && t === e.P || ("1" === n && t === e.L || "2" === n && t === e.A))))
				}, jsts.geom.IntersectionMatrix.matches2 = function(t, e) {
					var n = new jsts.geom.IntersectionMatrix(t);
					return n.matches(e)
				}, jsts.geom.IntersectionMatrix.prototype.set = function(t, e, n) {
					return "string" == typeof t ? void this.set2(t) : void(this.matrix[t][e] = n)
				}, jsts.geom.IntersectionMatrix.prototype.set2 = function(t) {
					for (var n = 0; n < t.length(); n++) {
						var i = n / 3,
							o = n % 3;
						this.matrix[i][o] = e.toDimensionValue(t.charAt(n))
					}
				}, jsts.geom.IntersectionMatrix.prototype.setAtLeast = function(t, e, n) {
					return 1 === arguments.length ? void this.setAtLeast2(arguments[0]) : void(this.matrix[t][e] < n && (this.matrix[t][e] = n))
				}, jsts.geom.IntersectionMatrix.prototype.setAtLeastIfValid = function(t, e, n) {
					t >= 0 && e >= 0 && this.setAtLeast(t, e, n)
				}, jsts.geom.IntersectionMatrix.prototype.setAtLeast2 = function(t) {
					var e;
					for (e = 0; e < t.length; e++) {
						var n = parseInt(e / 3),
							i = parseInt(e % 3);
						this.setAtLeast(n, i, jsts.geom.Dimension.toDimensionValue(t.charAt(e)))
					}
				}, jsts.geom.IntersectionMatrix.prototype.setAll = function(t) {
					var e, n;
					for (e = 0; 3 > e; e++) for (n = 0; 3 > n; n++) this.matrix[e][n] = t
				}, jsts.geom.IntersectionMatrix.prototype.get = function(t, e) {
					return this.matrix[t][e]
				}, jsts.geom.IntersectionMatrix.prototype.isDisjoint = function() {
					return this.matrix[t.INTERIOR][t.INTERIOR] === e.FALSE && this.matrix[t.INTERIOR][t.BOUNDARY] === e.FALSE && this.matrix[t.BOUNDARY][t.INTERIOR] === e.FALSE && this.matrix[t.BOUNDARY][t.BOUNDARY] === e.FALSE
				}, jsts.geom.IntersectionMatrix.prototype.isIntersects = function() {
					return !this.isDisjoint()
				}, jsts.geom.IntersectionMatrix.prototype.isTouches = function(n, i) {
					return n > i ? this.isTouches(i, n) : (n == e.A && i == e.A || n == e.L && i == e.L || n == e.L && i == e.A || n == e.P && i == e.A || n == e.P && i == e.L) && (this.matrix[t.INTERIOR][t.INTERIOR] === e.FALSE && (jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.BOUNDARY], "T") || jsts.geom.IntersectionMatrix.matches(this.matrix[t.BOUNDARY][t.INTERIOR], "T") || jsts.geom.IntersectionMatrix.matches(this.matrix[t.BOUNDARY][t.BOUNDARY], "T")))
				}, jsts.geom.IntersectionMatrix.prototype.isCrosses = function(n, i) {
					return n == e.P && i == e.L || n == e.P && i == e.A || n == e.L && i == e.A ? jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.INTERIOR], "T") && jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.EXTERIOR], "T") : n == e.L && i == e.P || n == e.A && i == e.P || n == e.A && i == e.L ? jsts.geom.IntersectionMatrix.matches(matrix[t.INTERIOR][t.INTERIOR], "T") && jsts.geom.IntersectionMatrix.matches(this.matrix[t.EXTERIOR][t.INTERIOR], "T") : n === e.L && i === e.L && 0 === this.matrix[t.INTERIOR][t.INTERIOR]
				}, jsts.geom.IntersectionMatrix.prototype.isWithin = function() {
					return jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.INTERIOR], "T") && this.matrix[t.INTERIOR][t.EXTERIOR] == e.FALSE && this.matrix[t.BOUNDARY][t.EXTERIOR] == e.FALSE
				}, jsts.geom.IntersectionMatrix.prototype.isContains = function() {
					return jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.INTERIOR], "T") && this.matrix[t.EXTERIOR][t.INTERIOR] == e.FALSE && this.matrix[t.EXTERIOR][t.BOUNDARY] == e.FALSE
				}, jsts.geom.IntersectionMatrix.prototype.isCovers = function() {
					var n = jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.INTERIOR], "T") || jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.BOUNDARY], "T") || jsts.geom.IntersectionMatrix.matches(this.matrix[t.BOUNDARY][t.INTERIOR], "T") || jsts.geom.IntersectionMatrix.matches(this.matrix[t.BOUNDARY][t.BOUNDARY], "T");
					return n && this.matrix[t.EXTERIOR][t.INTERIOR] == e.FALSE && this.matrix[t.EXTERIOR][t.BOUNDARY] == e.FALSE
				}, jsts.geom.IntersectionMatrix.prototype.isCoveredBy = function() {
					var n = jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.INTERIOR], "T") || jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.BOUNDARY], "T") || jsts.geom.IntersectionMatrix.matches(this.matrix[t.BOUNDARY][t.INTERIOR], "T") || jsts.geom.IntersectionMatrix.matches(this.matrix[t.BOUNDARY][t.BOUNDARY], "T");
					return n && this.matrix[t.INTERIOR][t.EXTERIOR] === e.FALSE && this.matrix[t.BOUNDARY][t.EXTERIOR] === e.FALSE
				}, jsts.geom.IntersectionMatrix.prototype.isEquals = function(n, i) {
					return n === i && (jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.INTERIOR], "T") && this.matrix[t.EXTERIOR][t.INTERIOR] === e.FALSE && this.matrix[t.INTERIOR][t.EXTERIOR] === e.FALSE && this.matrix[t.EXTERIOR][t.BOUNDARY] === e.FALSE && this.matrix[t.BOUNDARY][t.EXTERIOR] === e.FALSE)
				}, jsts.geom.IntersectionMatrix.prototype.isOverlaps = function(n, i) {
					return n == e.P && i === e.P || n == e.A && i === e.A ? jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.INTERIOR], "T") && jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.EXTERIOR], "T") && jsts.geom.IntersectionMatrix.matches(this.matrix[t.EXTERIOR][t.INTERIOR], "T") : n === e.L && i === e.L && (1 == this.matrix[t.INTERIOR][t.INTERIOR] && jsts.geom.IntersectionMatrix.matches(this.matrix[t.INTERIOR][t.EXTERIOR], "T") && jsts.geom.IntersectionMatrix.matches(this.matrix[t.EXTERIOR][t.INTERIOR], "T"))
				}, jsts.geom.IntersectionMatrix.prototype.matches = function(t) {
					if (9 != t.length) throw new jsts.error.IllegalArgumentException("Should be length 9: " + t);
					for (var e = 0; 3 > e; e++) for (var n = 0; 3 > n; n++) if (!jsts.geom.IntersectionMatrix.matches(this.matrix[e][n], t.charAt(3 * e + n))) return !1;
					return !0
				}, jsts.geom.IntersectionMatrix.prototype.transpose = function() {
					var t = matrix[1][0];
					return this.matrix[1][0] = this.matrix[0][1], this.matrix[0][1] = t, t = this.matrix[2][0], this.matrix[2][0] = this.matrix[0][2], this.matrix[0][2] = t, t = this.matrix[2][1], this.matrix[2][1] = this.matrix[1][2], this.matrix[1][2] = t, this
				}, jsts.geom.IntersectionMatrix.prototype.toString = function() {
					var t, n, i = "";
					for (t = 0; 3 > t; t++) for (n = 0; 3 > n; n++) i += e.toDimensionSymbol(this.matrix[t][n]);
					return i
				}
			}(), jsts.triangulate.quadedge.LastFoundQuadEdgeLocator = function(t) {
				this.subdiv = t, this.lastEdge = null, this.init()
			}, jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.prototype.init = function() {
				this.lastEdge = this.findEdge()
			}, jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.prototype.findEdge = function() {
				var t = this.subdiv.getEdges();
				return t[0]
			}, jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.prototype.locate = function(t) {
				this.lastEdge.isLive() || this.init();
				var e = this.subdiv.locateFromEdge(t, this.lastEdge);
				return this.lastEdge = e, e
			}, jsts.noding.SegmentNodeList = function(t) {
				this.nodeMap = new javascript.util.TreeMap, this.edge = t
			}, jsts.noding.SegmentNodeList.prototype.nodeMap = null, jsts.noding.SegmentNodeList.prototype.iterator = function() {
				return this.nodeMap.values().iterator()
			}, jsts.noding.SegmentNodeList.prototype.edge = null, jsts.noding.SegmentNodeList.prototype.getEdge = function() {
				return this.edge
			}, jsts.noding.SegmentNodeList.prototype.add = function(t, e) {
				var n = new jsts.noding.SegmentNode(this.edge, t, e, this.edge.getSegmentOctant(e)),
					i = this.nodeMap.get(n);
				return null !== i ? (jsts.util.Assert.isTrue(i.coord.equals2D(t), "Found equal nodes with different coordinates"), i) : (this.nodeMap.put(n, n), n)
			}, jsts.noding.SegmentNodeList.prototype.addEndpoints = function() {
				var t = this.edge.size() - 1;
				this.add(this.edge.getCoordinate(0), 0), this.add(this.edge.getCoordinate(t), t)
			}, jsts.noding.SegmentNodeList.prototype.addCollapsedNodes = function() {
				var t = [];
				this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);
				for (var e = 0; e < t.length; e++) {
					var n = t[e];
					this.add(this.edge.getCoordinate(n), n)
				}
			}, jsts.noding.SegmentNodeList.prototype.findCollapsesFromExistingVertices = function(t) {
				for (var e = 0; e < this.edge.size() - 2; e++) {
					var n = this.edge.getCoordinate(e),
						i = (this.edge.getCoordinate(e + 1), this.edge.getCoordinate(e + 2));
					n.equals2D(i) && t.push(e + 1)
				}
			}, jsts.noding.SegmentNodeList.prototype.findCollapsesFromInsertedNodes = function(t) {
				for (var e = [null], n = this.iterator(), i = n.next(); n.hasNext();) {
					var o = n.next(),
						r = this.findCollapseIndex(i, o, e);
					r && t.push(e[0]), i = o
				}
			}, jsts.noding.SegmentNodeList.prototype.findCollapseIndex = function(t, e, n) {
				if (!t.coord.equals2D(e.coord)) return !1;
				var i = e.segmentIndex - t.segmentIndex;
				return e.isInterior() || i--, 1 === i && (n[0] = t.segmentIndex + 1, !0)
			}, jsts.noding.SegmentNodeList.prototype.addSplitEdges = function(t) {
				this.addEndpoints(), this.addCollapsedNodes();
				for (var e = this.iterator(), n = e.next(); e.hasNext();) {
					var i = e.next(),
						o = this.createSplitEdge(n, i);
					t.add(o), n = i
				}
			}, jsts.noding.SegmentNodeList.prototype.checkSplitEdgesCorrectness = function(t) {
				var e = edge.getCoordinates(),
					n = t[0],
					i = n.getCoordinate(0);
				if (!i.equals2D(e[0])) throw new Error("bad split edge start point at " + i);
				var o = t[t.length - 1],
					r = o.getCoordinates(),
					s = r[r.length - 1];
				if (!s.equals2D(e[e.length - 1])) throw new Error("bad split edge end point at " + s)
			}, jsts.noding.SegmentNodeList.prototype.createSplitEdge = function(t, e) {
				var n = e.segmentIndex - t.segmentIndex + 2,
					i = this.edge.getCoordinate(e.segmentIndex),
					o = e.isInterior() || !e.coord.equals2D(i);
				o || n--;
				var r = [],
					s = 0;
				r[s++] = new jsts.geom.Coordinate(t.coord);
				for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++) r[s++] = this.edge.getCoordinate(a);
				return o && (r[s] = e.coord), new jsts.noding.NodedSegmentString(r, this.edge.getData())
			}, jsts.io.WKTWriter = function() {
				this.parser = new jsts.io.WKTParser(this.geometryFactory)
			}, jsts.io.WKTWriter.prototype.write = function(t) {
				var e = this.parser.write(t);
				return e
			}, jsts.io.WKTWriter.toLineString = function(t, e) {
				if (2 !== arguments.length) throw new jsts.error.NotImplementedError;
				return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )"
			}, jsts.io.WKTReader = function(t) {
				this.geometryFactory = t || new jsts.geom.GeometryFactory, this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new jsts.io.WKTParser(this.geometryFactory)
			}, jsts.io.WKTReader.prototype.read = function(t) {
				var e = this.parser.read(t);
				return this.precisionModel.getType() === jsts.geom.PrecisionModel.FIXED && this.reducePrecision(e), e
			}, jsts.io.WKTReader.prototype.reducePrecision = function(t) {
				var e, n;
				if (t.coordinate) this.precisionModel.makePrecise(t.coordinate);
				else if (t.points) for (e = 0, n = t.points.length; n > e; e++) this.precisionModel.makePrecise(t.points[e]);
				else if (t.geometries) for (e = 0, n = t.geometries.length; n > e; e++) this.reducePrecision(t.geometries[e])
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision = function(t, e) {
				this.tolerance = e, this.edgeCoincidenceTolerance = e / jsts.triangulate.quadedge.QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR, this.visitedKey = 0, this.quadEdges = [], this.startingEdge, this.tolerance, this.edgeCoincidenceTolerance, this.frameEnv, this.locator = null, this.seg = new jsts.geom.LineSegment, this.triEdges = new Array(3), this.frameVertex = new Array(3), this.createFrame(t), this.startingEdge = this.initSubdiv(), this.locator = new jsts.triangulate.quadedge.LastFoundQuadEdgeLocator(this)
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1e3, jsts.triangulate.quadedge.QuadEdgeSubdivision.getTriangleEdges = function(t, e) {
				if (e[0] = t, e[1] = e[0].lNext(), e[2] = e[1].lNext(), e[2].lNext() != e[0]) throw new jsts.IllegalArgumentError("Edges do not form a triangle")
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.createFrame = function(t) {
				var e, n, i;
				e = t.getWidth(), n = t.getHeight(), i = 0, i = e > n ? 10 * e : 10 * n, this.frameVertex[0] = new jsts.triangulate.quadedge.Vertex((t.getMaxX() + t.getMinX()) / 2, t.getMaxY() + i), this.frameVertex[1] = new jsts.triangulate.quadedge.Vertex(t.getMinX() - i, t.getMinY() - i), this.frameVertex[2] = new jsts.triangulate.quadedge.Vertex(t.getMaxX() + i, t.getMinY() - i), this.frameEnv = new jsts.geom.Envelope(this.frameVertex[0].getCoordinate(), this.frameVertex[1].getCoordinate()), this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.initSubdiv = function() {
				var t, e, n;
				return t = this.makeEdge(this.frameVertex[0], this.frameVertex[1]), e = this.makeEdge(this.frameVertex[1], this.frameVertex[2]), jsts.triangulate.quadedge.QuadEdge.splice(t.sym(), e), n = this.makeEdge(this.frameVertex[2], this.frameVertex[0]), jsts.triangulate.quadedge.QuadEdge.splice(e.sym(), n), jsts.triangulate.quadedge.QuadEdge.splice(n.sym(), t), t
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTolerance = function() {
				return this.tolerance
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getEnvelope = function() {
				return new jsts.geom.Envelope(this.frameEnv)
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getEdges = function() {
				return arguments.length > 0 ? this.getEdgesByFactory(arguments[0]) : this.quadEdges
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.setLocator = function(t) {
				this.locator = t
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.makeEdge = function(t, e) {
				var n = jsts.triangulate.quadedge.QuadEdge.makeEdge(t, e);
				return this.quadEdges.push(n), n
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.connect = function(t, e) {
				var n = jsts.triangulate.quadedge.QuadEdge.connect(t, e);
				return this.quadEdges.push(n), n
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.delete_jsts = function(t) {
				jsts.triangulate.quadedge.QuadEdge.splice(t, t.oPrev()), jsts.triangulate.quadedge.QuadEdge.splice(t.sym(), t.sym().oPrev());
				var e, n, i;
				t.eSym = t.sym(), n = t.rot, i = t.rot.sym();
				var o = this.quadEdges.indexOf(t); - 1 !== o && this.quadEdges.splice(o, 1), o = this.quadEdges.indexOf(e), -1 !== o && this.quadEdges.splice(o, 1), o = this.quadEdges.indexOf(n), -1 !== o && this.quadEdges.splice(o, 1), o = this.quadEdges.indexOf(i), -1 !== o && this.quadEdges.splice(o, 1), t.delete_jsts(), e.delete_jsts(), n.delete_jsts(), i.delete_jsts()
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateFromEdge = function(t, e) {
				var n, i = 0,
					o = this.quadEdges.length;
				for (n = e;;) {
					if (i++, i > o) throw new jsts.error.LocateFailureError(n.toLineSegment());
					if (t.equals(n.orig()) || t.equals(n.dest())) break;
					if (t.rightOf(n)) n = n.sym();
					else if (t.rightOf(n.oNext())) {
						if (t.rightOf(n.dPrev())) break;
						n = n.dPrev()
					} else n = n.oNext()
				}
				return n
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locate = function() {
				return 1 === arguments.length ? arguments[0] instanceof jsts.triangulate.quadedge.Vertex ? this.locateByVertex(arguments[0]) : this.locateByCoordinate(arguments[0]) : this.locateByCoordinates(arguments[0], arguments[1])
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateByVertex = function(t) {
				return this.locator.locate(t)
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateByCoordinate = function(t) {
				return this.locator.locate(new jsts.triangulate.quadedge.Vertex(t))
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.locateByCoordinates = function(t, e) {
				var n, i, o, n = this.locator.locate(new jsts.triangulate.quadedge.Vertex(t));
				if (null === n) return null;
				i = n, n.dest().getCoordinate().equals2D(t) && (i = n.sym()), o = i;
				do {
					if (o.dest().getCoordinate().equals2D(e)) return o;
					o = o.oNext()
				} while (o != i);
				return null
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.insertSite = function(t) {
				var e, n, i;
				if (e = this.locate(t), t.equals(e.orig(), this.tolerance) || t.equals(e.dest(), this.tolerance)) return e;
				n = this.makeEdge(e.orig(), t), jsts.triangulate.quadedge.QuadEdge.splice(n, e), i = n;
				do n = this.connect(e, n.sym()), e = n.oPrev();
				while (e.lNext() != i);
				return i
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isFrameEdge = function(t) {
				return !(!this.isFrameVertex(t.orig()) && !this.isFrameVertex(t.dest()))
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isFrameBorderEdge = function(t) {
				var e, n, i, o;
				return e = new Array(3), this.getTriangleEdges(t, e), n = new Array(3), this.getTriangleEdges(t.sym(), n), i = t.lNext().dest(), !! this.isFrameVertex(i) || (o = t.sym().lNext().dest(), !! this.isFrameVertex(o))
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isFrameVertex = function(t) {
				return !!t.equals(this.frameVertex[0]) || ( !! t.equals(this.frameVertex[1]) || !! t.equals(this.frameVertex[2]))
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isOnEdge = function(t, e) {
				this.seg.setCoordinates(t.orig().getCoordinate(), t.dest().getCoordinate());
				var n = this.seg.distance(e);
				return n < this.edgeCoincidenceTolerance
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.isVertexOfEdge = function(t, e) {
				return !(!e.equals(t.orig(), this.tolerance) && !e.equals(t.dest(), this.tolerance))
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVertices = function(t) {
				var e, n, i, o, r, s = [];
				for (e = 0, n = this.quadEdges.length, e; n > e; e++) i = this.quadEdges[e], o = i.orig(), (t || !this.isFrameVertex(o)) && s.push(o), r = i.dest(), (t || !this.isFrameVertex(r)) && s.push(r);
				return s
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVertexUniqueEdges = function(t) {
				var e, n, i, o, r, s, a, l;
				for (e = [], n = [], i = 0, o = this.quadEdges.length, i; o > i; i++) r = this.quadEdges[i], s = r.orig(), -1 === n.indexOf(s) && (n.push(s), (t || !this.isFrameVertex(s)) && e.push(r)), a = r.sym(), l = a.orig(), -1 === n.indexOf(l) && (n.push(l), (t || !this.isFrameVertex(l)) && e.push(a));
				return e
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getPrimaryEdges = function(t) {
				this.visitedKey++;
				var e, n, i, o, r;
				for (e = [], n = [], n.push(this.startingEdge), i = []; n.length > 0;) o = n.pop(), -1 === i.indexOf(o) && (r = o.getPrimary(), (t || !this.isFrameEdge(r)) && e.push(r), n.push(o.oNext()), n.push(o.sym().oNext()), i.push(o), i.push(o.sym()));
				return e
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.visitTriangles = function(t, e) {
				this.visitedKey++;
				var n, i, o, r;
				for (n = [], n.push(this.startingEdge), i = []; n.length > 0;) o = n.pop(), -1 === i.indexOf(o) && (r = this.fetchTriangleToVisit(o, n, e, i), null !== r && t.visit(r))
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.fetchTriangleToVisit = function(t, e, n, i) {
				var o, r, s, a;
				o = t, r = 0, s = !1;
				do this.triEdges[r] = o, this.isFrameEdge(o) && (s = !0), a = o.sym(), -1 === i.indexOf(a) && e.push(a), i.push(o), r++, o = o.lNext();
				while (o !== t);
				return s && !n ? null : this.triEdges
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangleEdges = function(t) {
				var e = new jsts.triangulate.quadedge.TriangleEdgesListVisitor;
				return this.visitTriangles(e, t), e.getTriangleEdges()
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangleVertices = function(t) {
				var e = new TriangleVertexListVisitor;
				return this.visitTriangles(e, t), e.getTriangleVertices()
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangleCoordinates = function(t) {
				var e = new jsts.triangulate.quadedge.TriangleCoordinatesVisitor;
				return this.visitTriangles(e, t), e.getTriangles()
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getEdgesByFactory = function(t) {
				var e, n, i, o, r, s;
				for (e = this.getPrimaryEdges(!1), n = [], i = 0, o = e.length, i; o > i; i++) r = e[i], s = [], s[0] = r.orig().getCoordinate(), s[1] = r.dest().getCoordinate(), n[i] = t.createLineString(s);
				return t.createMultiLineString(n)
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getTriangles = function(t) {
				var e, n, i, o, r;
				for (e = this.getTriangleCoordinates(!1), n = new Array(e.length), o = 0, r = e.length, o; r > o; o++) i = e[o], n[o] = t.createPolygon(t.createLinearRing(i, null));
				return t.createGeometryCollection(n)
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVoronoiDiagram = function(t) {
				var e = this.getVoronoiCellPolygons(t);
				return t.createGeometryCollection(e)
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVoronoiCellPolygons = function(t) {
				this.visitTriangles(new jsts.triangulate.quadedge.TriangleCircumcentreVisitor, !0);
				var e, n, i, o, r;
				for (e = [], n = this.getVertexUniqueEdges(!1), i = 0, o = n.length, i; o > i; i++) r = n[i], e.push(this.getVoronoiCellPolygon(r, t));
				return e
			}, jsts.triangulate.quadedge.QuadEdgeSubdivision.prototype.getVoronoiCellPolygon = function(t, e) {
				var n, i, o, r, s;
				n = [], startQE = t;
				do i = t.rot.orig().getCoordinate(), n.push(i), t = t.oPrev();
				while (t !== startQE);
				return o = new jsts.geom.CoordinateList([], (!1)), o.add(n, !1), o.closeRing(), o.size() < 4 && o.add(o.get(o.size() - 1), !0), r = e.createPolygon(e.createLinearRing(o.toArray()), null), s = startQE.orig(), r
			}, jsts.triangulate.quadedge.TriangleCircumcentreVisitor = function() {}, jsts.triangulate.quadedge.TriangleCircumcentreVisitor.prototype.visit = function(t) {
				var e, n, i, o, r, s;
				for (e = t[0].orig().getCoordinate(), n = t[1].orig().getCoordinate(), i = t[2].orig().getCoordinate(), o = jsts.geom.Triangle.circumcentre(e, n, i), r = new jsts.triangulate.quadedge.Vertex(o), s = 0; 3 > s; s++) t[s].rot.setOrig(r)
			}, jsts.triangulate.quadedge.TriangleEdgesListVisitor = function() {
				this.triList = []
			}, jsts.triangulate.quadedge.TriangleEdgesListVisitor.prototype.visit = function(t) {
				var e = t.concat();
				this.triList.push(e)
			}, jsts.triangulate.quadedge.TriangleEdgesListVisitor.prototype.getTriangleEdges = function() {
				return this.triList
			}, jsts.triangulate.quadedge.TriangleVertexListVisitor = function() {
				this.triList = []
			}, jsts.triangulate.quadedge.TriangleVertexListVisitor.prototype.visit = function() {
				var t = [];
				t.push(trieEdges[0].orig()), t.push(trieEdges[1].orig()), t.push(trieEdges[2].orig()), this.triList.push(t)
			}, jsts.triangulate.quadedge.TriangleVertexListVisitor.prototype.getTriangleVertices = function() {
				return this.triList
			}, jsts.triangulate.quadedge.TriangleCoordinatesVisitor = function() {
				this.coordList = new jsts.geom.CoordinateList([], (!1)), this.triCoords = []
			}, jsts.triangulate.quadedge.TriangleCoordinatesVisitor.prototype.visit = function(t) {
				this.coordList = new jsts.geom.CoordinateList([], (!1));
				var e, n, i = 0;
				for (i; 3 > i; i++) e = t[i].orig(), this.coordList.add(e.getCoordinate());
				if (this.coordList.size() > 0) {
					if (this.coordList.closeRing(), n = this.coordList.toArray(), 4 !== n.length) return;
					this.triCoords.push(n)
				}
			}, jsts.triangulate.quadedge.TriangleCoordinatesVisitor.prototype.getTriangles = function() {
				return this.triCoords
			}, jsts.operation.relate.EdgeEndBundle = function() {
				this.edgeEnds = [];
				var t = arguments[0] instanceof jsts.geomgraph.EdgeEnd ? arguments[0] : arguments[1],
					e = t.getEdge(),
					n = t.getCoordinate(),
					i = t.getDirectedCoordinate(),
					o = new jsts.geomgraph.Label(t.getLabel());
				jsts.geomgraph.EdgeEnd.call(this, e, n, i, o), this.insert(t)
			}, jsts.operation.relate.EdgeEndBundle.prototype = new jsts.geomgraph.EdgeEnd, jsts.operation.relate.EdgeEndBundle.prototype.edgeEnds = null, jsts.operation.relate.EdgeEndBundle.prototype.getLabel = function() {
				return this.label
			}, jsts.operation.relate.EdgeEndBundle.prototype.getEdgeEnds = function() {
				return this.edgeEnds
			}, jsts.operation.relate.EdgeEndBundle.prototype.insert = function(t) {
				this.edgeEnds.push(t)
			}, jsts.operation.relate.EdgeEndBundle.prototype.computeLabel = function(t) {
				for (var e = !1, n = 0; n < this.edgeEnds.length; n++) {
					var i = this.edgeEnds[n];
					i.getLabel().isArea() && (e = !0)
				}
				this.label = e ? new jsts.geomgraph.Label(jsts.geom.Location.NONE, jsts.geom.Location.NONE, jsts.geom.Location.NONE) : new jsts.geomgraph.Label(jsts.geom.Location.NONE);
				for (var n = 0; 2 > n; n++) this.computeLabelOn(n, t), e && this.computeLabelSides(n)
			}, jsts.operation.relate.EdgeEndBundle.prototype.computeLabelOn = function(t, e) {
				for (var n = 0, i = !1, o = 0; o < this.edgeEnds.length; o++) {
					var r = this.edgeEnds[o],
						s = r.getLabel().getLocation(t);
					s == jsts.geom.Location.BOUNDARY && n++, s == jsts.geom.Location.INTERIOR && (i = !0)
				}
				var s = jsts.geom.Location.NONE;
				i && (s = jsts.geom.Location.INTERIOR), n > 0 && (s = jsts.geomgraph.GeometryGraph.determineBoundary(e, n)), this.label.setLocation(t, s)
			}, jsts.operation.relate.EdgeEndBundle.prototype.computeLabelSides = function(t) {
				this.computeLabelSide(t, jsts.geomgraph.Position.LEFT), this.computeLabelSide(t, jsts.geomgraph.Position.RIGHT)
			}, jsts.operation.relate.EdgeEndBundle.prototype.computeLabelSide = function(t, e) {
				for (var n = 0; n < this.edgeEnds.length; n++) {
					var i = this.edgeEnds[n];
					if (i.getLabel().isArea()) {
						var o = i.getLabel().getLocation(t, e);
						if (o === jsts.geom.Location.INTERIOR) return void this.label.setLocation(t, e, jsts.geom.Location.INTERIOR);
						o === jsts.geom.Location.EXTERIOR && this.label.setLocation(t, e, jsts.geom.Location.EXTERIOR)
					}
				}
			}, jsts.operation.relate.EdgeEndBundle.prototype.updateIM = function(t) {
				jsts.geomgraph.Edge.updateIM(this.label, t)
			}, jsts.index.kdtree.KdTree = function(t) {
				var e = 0;
				void 0 !== t && (e = t), this.root = null, this.last = null, this.numberOfNodes = 0, this.tolerance = e
			}, jsts.index.kdtree.KdTree.prototype.insert = function() {
				return 1 === arguments.length ? this.insertCoordinate.apply(this, arguments[0]) : this.insertWithData.apply(this, arguments[0], arguments[1])
			}, jsts.index.kdtree.KdTree.prototype.insertCoordinate = function(t) {
				return this.insertWithData(t, null)
			}, jsts.index.kdtree.KdTree.prototype.insertWithData = function(t, e) {
				if (null === this.root) return this.root = new jsts.index.kdtree.KdNode(t, e), this.root;
				for (var n = this.root, i = this.root, o = !0, r = !0; n !== last;) {
					if (r = o ? t.x < n.getX() : t.y < n.getY(), i = n, n = r ? n.getLeft() : n.getRight(), null !== n) {
						var s = t.distance(n.getCoordinate()) <= this.tolerance;
						if (s) return n.increment(), n
					}
					o = !o
				}
				this.numberOfNodes = numberOfNodes + 1;
				var a = new jsts.index.kdtree.KdNode(t, e);
				return a.setLeft(this.last), a.setRight(this.last), r ? i.setLeft(a) : i.setRight(a), a
			}, jsts.index.kdtree.KdTree.prototype.queryNode = function(t, e, n, i, o) {
				if (t !== e) {
					var r, s, a;
					i ? (r = n.getMinX(), s = n.getMaxX(), a = t.getX()) : (r = n.getMinY(), s = n.getMaxY(), a = t.getY());
					var l = a > r,
						u = s >= a;
					l && this.queryNode(t.getLeft(), e, n, !i, o), n.contains(t.getCoordinate()) && o.add(t), u && this.queryNode(t.getRight(), e, n, !i, o)
				}
			}, jsts.index.kdtree.KdTree.prototype.query = function() {
				return 1 === arguments.length ? this.queryByEnvelope.apply(this, arguments[0]) : this.queryWithArray.apply(this, arguments[0], arguments[1])
			}, jsts.index.kdtree.KdTree.prototype.queryByEnvelope = function(t) {
				var e = [];
				return this.queryNode(this.root, this.last, t, !0, e), e
			}, jsts.index.kdtree.KdTree.prototype.queryWithArray = function(t, e) {
				this.queryNode(this.root, this.last, t, !0, e)
			}, jsts.geom.Triangle = function(t, e, n) {
				this.p0 = t, this.p1 = e, this.p2 = n
			}, jsts.geom.Triangle.isAcute = function(t, e, n) {
				return !!(jsts.algorithm.Angle.isAcute(t, e, n) && jsts.algorithm.Angle.isAcute(e, n, t) && jsts.algorithm.Angle.isAcute(n, t, e))
			}, jsts.geom.Triangle.perpendicularBisector = function(t, e) {
				var n, i, o, r;
				return n = e.x - t.x, i = e.y - t.y, o = new jsts.algorithm.HCoordinate(t.x + n / 2, t.y + i / 2, 1), r = new jsts.algorithm.HCoordinate(t.x - i + n / 2, t.y + n + i / 2, 1), new jsts.algorithm.HCoordinate(o, r)
			}, jsts.geom.Triangle.circumcentre = function(t, e, n) {
				var i, o, r, s, a, l, u, p, h, c, g;
				return i = n.x, o = n.y, r = t.x - i, s = t.y - o, a = e.x - i, l = e.y - o, u = 2 * jsts.geom.Triangle.det(r, s, a, l), p = jsts.geom.Triangle.det(s, r * r + s * s, l, a * a + l * l), h = jsts.geom.Triangle.det(r, r * r + s * s, a, a * a + l * l), c = i - p / u, g = o + h / u, new jsts.geom.Coordinate(c, g)
			}, jsts.geom.Triangle.det = function(t, e, n, i) {
				return t * i - e * n
			}, jsts.geom.Triangle.inCentre = function(t, e, n) {
				var i, o, r, s, a, l;
				return i = e.distance(n), o = t.distance(n), r = t.distance(e), s = i + o + r, a = (i * t.x + o * e.x + r * n.x) / s, l = (i * t.y + o * e.y + r * n.y) / s, new jsts.geom.Coordinate(a, l)
			}, jsts.geom.Triangle.centroid = function(t, e, n) {
				var i, o;
				return i = (t.x + e.x + n.x) / 3, o = (t.y + e.y + n.y) / 3, new jsts.geom.Coordinate(i, o)
			}, jsts.geom.Triangle.longestSideLength = function(t, e, n) {
				var i, o, r, s;
				return i = t.distance(e), o = e.distance(n), r = n.distance(t), s = i, o > s && (s = o), r > s && (s = r), s
			}, jsts.geom.Triangle.angleBisector = function(t, e, n) {
				var i, o, r, s, a, l;
				return i = e.distance(t), o = e.distance(n), r = i / (i + o), s = n.x - t.x, a = n.y - t.y, l = new jsts.geom.Coordinate(t.x + r * s, t.y + r * a)
			}, jsts.geom.Triangle.area = function(t, e, n) {
				return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2)
			}, jsts.geom.Triangle.signedArea = function(t, e, n) {
				return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2
			}, jsts.geom.Triangle.prototype.inCentre = function() {
				return jsts.geom.Triangle.inCentre(this.p0, this.p1, this.p2)
			}, jsts.noding.OrientedCoordinateArray = function(t) {
				this.pts = t, this._orientation = jsts.noding.OrientedCoordinateArray.orientation(t)
			}, jsts.noding.OrientedCoordinateArray.prototype.pts = null, jsts.noding.OrientedCoordinateArray.prototype._orientation = void 0, jsts.noding.OrientedCoordinateArray.orientation = function(t) {
				return 1 === jsts.geom.CoordinateArrays.increasingDirection(t)
			}, jsts.noding.OrientedCoordinateArray.prototype.compareTo = function(t) {
				var e = t,
					n = jsts.noding.OrientedCoordinateArray.compareOriented(this.pts, this._orientation, e.pts, e._orientation);
				return n
			}, jsts.noding.OrientedCoordinateArray.compareOriented = function(t, e, n, i) {
				for (var o = e ? 1 : -1, r = i ? 1 : -1, s = e ? t.length : -1, a = i ? n.length : -1, l = e ? 0 : t.length - 1, u = i ? 0 : n.length - 1;;) {
					var p = t[l].compareTo(n[u]);
					if (0 !== p) return p;
					l += o, u += r;
					var h = l === s,
						c = u === a;
					if (h && !c) return -1;
					if (!h && c) return 1;
					if (h && c) return 0
				}
			}, jsts.algorithm.CentralEndpointIntersector = function(t, e, n, i) {
				this.pts = [t, e, n, i], this.compute()
			}, jsts.algorithm.CentralEndpointIntersector.getIntersection = function(t, e, n, i) {
				var o = new jsts.algorithm.CentralEndpointIntersector(t, e, n, i);
				return o.getIntersection()
			}, jsts.algorithm.CentralEndpointIntersector.prototype.pts = null, jsts.algorithm.CentralEndpointIntersector.prototype.intPt = null, jsts.algorithm.CentralEndpointIntersector.prototype.compute = function() {
				var t = jsts.algorithm.CentralEndpointIntersector.average(this.pts);
				this.intPt = this.findNearestPoint(t, this.pts)
			}, jsts.algorithm.CentralEndpointIntersector.prototype.getIntersection = function() {
				return this.intPt
			}, jsts.algorithm.CentralEndpointIntersector.average = function(t) {
				var e, n = new jsts.geom.Coordinate,
					i = t.length;
				for (e = 0; i > e; e++) n.x += t[e].x, n.y += t[e].y;
				return i > 0 && (n.x /= i, n.y /= i), n
			}, jsts.algorithm.CentralEndpointIntersector.prototype.findNearestPoint = function(t, e) {
				var n, i, o = Number.MAX_VALUE,
					r = null;
				for (n = 0; n < e.length; n++) i = t.distance(e[n]), o > i && (o = i, r = e[n]);
				return r
			}, jsts.operation.buffer.BufferOp = function(t, e) {
				this.argGeom = t, this.bufParams = e ? e : new jsts.operation.buffer.BufferParameters
			}, jsts.operation.buffer.BufferOp.MAX_PRECISION_DIGITS = 12, jsts.operation.buffer.BufferOp.precisionScaleFactor = function(t, e, n) {
				var i = t.getEnvelopeInternal(),
					o = Math.max(i.getHeight(), i.getWidth()),
					r = e > 0 ? e : 0,
					s = o + 2 * r,
					a = Math.log(s) / Math.log(10) + 1,
					l = a - n,
					u = Math.pow(10, -l);
				return u
			}, jsts.operation.buffer.BufferOp.bufferOp = function(t, e) {
				if (arguments.length > 2) return jsts.operation.buffer.BufferOp.bufferOp2.apply(this, arguments);
				var n = new jsts.operation.buffer.BufferOp(t),
					i = n.getResultGeometry(e);
				return i
			}, jsts.operation.buffer.BufferOp.bufferOp2 = function(t, e, n) {
				if (arguments.length > 3) return jsts.operation.buffer.BufferOp.bufferOp3.apply(this, arguments);
				var i = new jsts.operation.buffer.BufferOp(t, n),
					o = i.getResultGeometry(e);
				return o
			}, jsts.operation.buffer.BufferOp.bufferOp3 = function(t, e, n) {
				if (arguments.length > 4) return jsts.operation.buffer.BufferOp.bufferOp4.apply(this, arguments);
				var i = new jsts.operation.buffer.BufferOp(t);
				i.setQuadrantSegments(n);
				var o = i.getResultGeometry(e);
				return o
			}, jsts.operation.buffer.BufferOp.bufferOp4 = function(t, e, n, i) {
				var o = new jsts.operation.buffer.BufferOp(t);
				o.setQuadrantSegments(n), o.setEndCapStyle(i);
				var r = o.getResultGeometry(e);
				return r
			}, jsts.operation.buffer.BufferOp.prototype.argGeom = null, jsts.operation.buffer.BufferOp.prototype.distance = null, jsts.operation.buffer.BufferOp.prototype.bufParams = null, jsts.operation.buffer.BufferOp.prototype.resultGeometry = null, jsts.operation.buffer.BufferOp.prototype.setEndCapStyle = function(t) {
				this.bufParams.setEndCapStyle(t)
			}, jsts.operation.buffer.BufferOp.prototype.setQuadrantSegments = function(t) {
				this.bufParams.setQuadrantSegments(t)
			}, jsts.operation.buffer.BufferOp.prototype.getResultGeometry = function(t) {
				return this.distance = t, this.computeGeometry(), this.resultGeometry
			}, jsts.operation.buffer.BufferOp.prototype.computeGeometry = function() {
				if (this.bufferOriginalPrecision(), null === this.resultGeometry) {
					var t = this.argGeom.getPrecisionModel();
					t.getType() === jsts.geom.PrecisionModel.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
				}
			}, jsts.operation.buffer.BufferOp.prototype.bufferReducedPrecision = function() {
				var t, e = null;
				for (t = jsts.operation.buffer.BufferOp.MAX_PRECISION_DIGITS; t >= 0; t--) {
					try {
						this.bufferReducedPrecision2(t)
					} catch (n) {
						e = n
					}
					if (null !== this.resultGeometry) return
				}
				throw e
			}, jsts.operation.buffer.BufferOp.prototype.bufferOriginalPrecision = function() {
				try {
					var t = new jsts.operation.buffer.BufferBuilder(this.bufParams);
					this.resultGeometry = t.buffer(this.argGeom, this.distance)
				} catch (e) {}
			}, jsts.operation.buffer.BufferOp.prototype.bufferReducedPrecision2 = function(t) {
				var e = jsts.operation.buffer.BufferOp.precisionScaleFactor(this.argGeom, this.distance, t),
					n = new jsts.geom.PrecisionModel(e);
				this.bufferFixedPrecision(n)
			}, jsts.operation.buffer.BufferOp.prototype.bufferFixedPrecision = function(t) {
				var e = new jsts.noding.ScaledNoder(new jsts.noding.snapround.MCIndexSnapRounder(new jsts.geom.PrecisionModel(1)), t.getScale()),
					n = new jsts.operation.buffer.BufferBuilder(this.bufParams);
				n.setWorkingPrecisionModel(t), n.setNoder(e), this.resultGeometry = n.buffer(this.argGeom, this.distance)
			}, function() {
				var t = jsts.geom.Location,
					e = jsts.geomgraph.Position,
					n = jsts.util.Assert;
				jsts.geomgraph.GeometryGraph = function(t, e, n) {
					jsts.geomgraph.PlanarGraph.call(this), this.lineEdgeMap = new javascript.util.HashMap, this.ptLocator = new jsts.algorithm.PointLocator, this.argIndex = t, this.parentGeom = e, this.boundaryNodeRule = n || jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE, null !== e && this.add(e)
				}, jsts.geomgraph.GeometryGraph.prototype = new jsts.geomgraph.PlanarGraph, jsts.geomgraph.GeometryGraph.constructor = jsts.geomgraph.GeometryGraph, jsts.geomgraph.GeometryGraph.prototype.createEdgeSetIntersector = function() {
					return new jsts.geomgraph.index.SimpleMCSweepLineIntersector
				}, jsts.geomgraph.GeometryGraph.determineBoundary = function(e, n) {
					return e.isInBoundary(n) ? t.BOUNDARY : t.INTERIOR
				}, jsts.geomgraph.GeometryGraph.prototype.parentGeom = null, jsts.geomgraph.GeometryGraph.prototype.lineEdgeMap = null, jsts.geomgraph.GeometryGraph.prototype.boundaryNodeRule = null, jsts.geomgraph.GeometryGraph.prototype.useBoundaryDeterminationRule = !0, jsts.geomgraph.GeometryGraph.prototype.argIndex = null, jsts.geomgraph.GeometryGraph.prototype.boundaryNodes = null, jsts.geomgraph.GeometryGraph.prototype.hasTooFewPoints = !1, jsts.geomgraph.GeometryGraph.prototype.invalidPoint = null, jsts.geomgraph.GeometryGraph.prototype.areaPtLocator = null, jsts.geomgraph.GeometryGraph.prototype.ptLocator = null, jsts.geomgraph.GeometryGraph.prototype.getGeometry = function() {
					return this.parentGeom
				}, jsts.geomgraph.GeometryGraph.prototype.getBoundaryNodes = function() {
					return null === this.boundaryNodes && (this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex)), this.boundaryNodes
				}, jsts.geomgraph.GeometryGraph.prototype.getBoundaryNodeRule = function() {
					return this.boundaryNodeRule
				}, jsts.geomgraph.GeometryGraph.prototype.findEdge = function(t) {
					return this.lineEdgeMap.get(t)
				}, jsts.geomgraph.GeometryGraph.prototype.computeSplitEdges = function(t) {
					for (var e = this.edges.iterator(); e.hasNext();) {
						var n = e.next();
						n.eiList.addSplitEdges(t)
					}
				}, jsts.geomgraph.GeometryGraph.prototype.add = function(t) {
					if (!t.isEmpty()) if (t instanceof jsts.geom.MultiPolygon && (this.useBoundaryDeterminationRule = !1), t instanceof jsts.geom.Polygon) this.addPolygon(t);
					else if (t instanceof jsts.geom.LineString) this.addLineString(t);
					else if (t instanceof jsts.geom.Point) this.addPoint(t);
					else if (t instanceof jsts.geom.MultiPoint) this.addCollection(t);
					else if (t instanceof jsts.geom.MultiLineString) this.addCollection(t);
					else if (t instanceof jsts.geom.MultiPolygon) this.addCollection(t);
					else {
						if (!(t instanceof jsts.geom.GeometryCollection)) throw new jsts.error.IllegalArgumentError("Geometry type not supported.");
						this.addCollection(t)
					}
				}, jsts.geomgraph.GeometryGraph.prototype.addCollection = function(t) {
					for (var e = 0; e < t.getNumGeometries(); e++) {
						var n = t.getGeometryN(e);
						this.add(n)
					}
				}, jsts.geomgraph.GeometryGraph.prototype.addEdge = function(e) {
					this.insertEdge(e);
					var n = e.getCoordinates();
					this.insertPoint(this.argIndex, n[0], t.BOUNDARY), this.insertPoint(this.argIndex, n[n.length - 1], t.BOUNDARY)
				}, jsts.geomgraph.GeometryGraph.prototype.addPoint = function(e) {
					var n = e.getCoordinate();
					this.insertPoint(this.argIndex, n, t.INTERIOR)
				}, jsts.geomgraph.GeometryGraph.prototype.addLineString = function(e) {
					var i = jsts.geom.CoordinateArrays.removeRepeatedPoints(e.getCoordinates());
					if (i.length < 2) return this.hasTooFewPoints = !0, void(this.invalidPoint = coords[0]);
					var o = new jsts.geomgraph.Edge(i, new jsts.geomgraph.Label(this.argIndex, t.INTERIOR));
					this.lineEdgeMap.put(e, o), this.insertEdge(o), n.isTrue(i.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this.argIndex, i[0]), this.insertBoundaryPoint(this.argIndex, i[i.length - 1])
				}, jsts.geomgraph.GeometryGraph.prototype.addPolygonRing = function(e, n, i) {
					if (!e.isEmpty()) {
						var o = jsts.geom.CoordinateArrays.removeRepeatedPoints(e.getCoordinates());
						if (o.length < 4) return this.hasTooFewPoints = !0, void(this.invalidPoint = o[0]);
						var r = n,
							s = i;
						jsts.algorithm.CGAlgorithms.isCCW(o) && (r = i, s = n);
						var a = new jsts.geomgraph.Edge(o, new jsts.geomgraph.Label(this.argIndex, t.BOUNDARY, r, s));
						this.lineEdgeMap.put(e, a), this.insertEdge(a), this.insertPoint(this.argIndex, o[0], t.BOUNDARY)
					}
				}, jsts.geomgraph.GeometryGraph.prototype.addPolygon = function(e) {
					this.addPolygonRing(e.getExteriorRing(), t.EXTERIOR, t.INTERIOR);
					for (var n = 0; n < e.getNumInteriorRing(); n++) {
						var i = e.getInteriorRingN(n);
						this.addPolygonRing(i, t.INTERIOR, t.EXTERIOR)
					}
				}, jsts.geomgraph.GeometryGraph.prototype.computeEdgeIntersections = function(t, e, n) {
					var i = new jsts.geomgraph.index.SegmentIntersector(e, n, (!0));
					i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes());
					var o = this.createEdgeSetIntersector();
					return o.computeIntersections(this.edges, t.edges, i), i
				}, jsts.geomgraph.GeometryGraph.prototype.computeSelfNodes = function(t, e) {
					var n = new jsts.geomgraph.index.SegmentIntersector(t, (!0), (!1)),
						i = this.createEdgeSetIntersector();
					return !e && (this.parentGeom instanceof jsts.geom.LinearRing || this.parentGeom instanceof jsts.geom.Polygon || this.parentGeom instanceof jsts.geom.MultiPolygon) ? i.computeIntersections(this.edges, n, !1) : i.computeIntersections(this.edges, n, !0), this.addSelfIntersectionNodes(this.argIndex), n
				}, jsts.geomgraph.GeometryGraph.prototype.insertPoint = function(t, e, n) {
					var i = this.nodes.addNode(e),
						o = i.getLabel();
					null == o ? i.label = new jsts.geomgraph.Label(t, n) : o.setLocation(t, n)
				}, jsts.geomgraph.GeometryGraph.prototype.insertBoundaryPoint = function(n, i) {
					var o = this.nodes.addNode(i),
						r = o.getLabel(),
						s = 1,
						a = t.NONE;
					null !== r && (a = r.getLocation(n, e.ON)), a === t.BOUNDARY && s++;
					var l = jsts.geomgraph.GeometryGraph.determineBoundary(this.boundaryNodeRule, s);
					r.setLocation(n, l)
				}, jsts.geomgraph.GeometryGraph.prototype.addSelfIntersectionNodes = function(t) {
					for (var e = this.edges.iterator(); e.hasNext();) for (var n = e.next(), i = n.getLabel().getLocation(t), o = n.eiList.iterator(); o.hasNext();) {
						var r = o.next();
						this.addSelfIntersectionNode(t, r.coord, i)
					}
				}, jsts.geomgraph.GeometryGraph.prototype.addSelfIntersectionNode = function(e, n, i) {
					this.isBoundaryNode(e, n) || (i === t.BOUNDARY && this.useBoundaryDeterminationRule ? this.insertBoundaryPoint(e, n) : this.insertPoint(e, n, i))
				}, jsts.geomgraph.GeometryGraph.prototype.getInvalidPoint = function() {
					return this.invalidPoint
				}
			}(), jsts.operation.buffer.OffsetSegmentString = function() {
				this.ptList = []
			}, jsts.operation.buffer.OffsetSegmentString.prototype.ptList = null, jsts.operation.buffer.OffsetSegmentString.prototype.precisionModel = null, jsts.operation.buffer.OffsetSegmentString.prototype.minimimVertexDistance = 0, jsts.operation.buffer.OffsetSegmentString.prototype.setPrecisionModel = function(t) {
				this.precisionModel = t
			}, jsts.operation.buffer.OffsetSegmentString.prototype.setMinimumVertexDistance = function(t) {
				this.minimimVertexDistance = t
			}, jsts.operation.buffer.OffsetSegmentString.prototype.addPt = function(t) {
				var e = new jsts.geom.Coordinate(t);
				this.precisionModel.makePrecise(e), this.isRedundant(e) || this.ptList.push(e)
			}, jsts.operation.buffer.OffsetSegmentString.prototype.addPts = function(t, e) {
				if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]);
				else for (var n = t.length - 1; n >= 0; n--) this.addPt(t[n])
			}, jsts.operation.buffer.OffsetSegmentString.prototype.isRedundant = function(t) {
				if (this.ptList.length < 1) return !1;
				var e = this.ptList[this.ptList.length - 1],
					n = t.distance(e);
				return n < this.minimimVertexDistance
			}, jsts.operation.buffer.OffsetSegmentString.prototype.closeRing = function() {
				if (!(this.ptList.length < 1)) {
					var t = new jsts.geom.Coordinate(this.ptList[0]),
						e = this.ptList[this.ptList.length - 1],
						n = null;
					this.ptList.length >= 2 && (n = this.ptList[this.ptList.length - 2]), t.equals(e) || this.ptList.push(t)
				}
			}, jsts.operation.buffer.OffsetSegmentString.prototype.reverse = function() {}, jsts.operation.buffer.OffsetSegmentString.prototype.getCoordinates = function() {
				return this.ptList
			}, jsts.algorithm.distance.PointPairDistance = function() {
				this.pt = [new jsts.geom.Coordinate, new jsts.geom.Coordinate]
			}, jsts.algorithm.distance.PointPairDistance.prototype.pt = null, jsts.algorithm.distance.PointPairDistance.prototype.distance = NaN, jsts.algorithm.distance.PointPairDistance.prototype.isNull = !0, jsts.algorithm.distance.PointPairDistance.prototype.initialize = function(t, e, n) {
				return void 0 === t ? void(this.isNull = !0) : (this.pt[0].setCoordinate(t), this.pt[1].setCoordinate(e), this.distance = void 0 !== n ? n : t.distance(e), void(this.isNull = !1))
			}, jsts.algorithm.distance.PointPairDistance.prototype.getDistance = function() {
				return this.distance
			}, jsts.algorithm.distance.PointPairDistance.prototype.getCoordinates = function() {
				return this.pt
			}, jsts.algorithm.distance.PointPairDistance.prototype.getCoordinate = function(t) {
				return this.pt[t]
			}, jsts.algorithm.distance.PointPairDistance.prototype.setMaximum = function(t) {
				return 2 === arguments.length ? void this.setMaximum2.apply(this, arguments) : void this.setMaximum(t.pt[0], t.pt[1])
			}, jsts.algorithm.distance.PointPairDistance.prototype.setMaximum2 = function(t, e) {
				if (this.isNull) return void this.initialize(t, e);
				var n = t.distance(e);
				n > this.distance && this.initialize(t, e, n)
			}, jsts.algorithm.distance.PointPairDistance.prototype.setMinimum = function(t) {
				return 2 === arguments.length ? void this.setMinimum2.apply(this, arguments) : void this.setMinimum(t.pt[0], t.pt[1])
			}, jsts.algorithm.distance.PointPairDistance.prototype.setMinimum2 = function(t, e) {
				if (this.isNull) return void this.initialize(t, e);
				var n = t.distance(e);
				n < this.distance && this.initialize(t, e, n)
			}, function() {
				var t = jsts.algorithm.distance.PointPairDistance,
					e = jsts.algorithm.distance.DistanceToPoint,
					n = function(n) {
						this.maxPtDist = new t, this.minPtDist = new t, this.euclideanDist = new e, this.geom = n
					};
				n.prototype = new jsts.geom.CoordinateFilter, n.prototype.maxPtDist = new t, n.prototype.minPtDist = new t, n.prototype.euclideanDist = new e, n.prototype.geom, n.prototype.filter = function(t) {
					this.minPtDist.initialize(), e.computeDistance(this.geom, t, this.minPtDist), this.maxPtDist.setMaximum(this.minPtDist)
				}, n.prototype.getMaxPointDistance = function() {
					return this.maxPtDist
				};
				var i = function(e, n) {
						this.maxPtDist = new t, this.minPtDist = new t, this.geom = e, this.numSubSegs = Math.round(1 / n)
					};
				i.prototype = new jsts.geom.CoordinateSequenceFilter, i.prototype.maxPtDist = new t, i.prototype.minPtDist = new t, i.prototype.geom, i.prototype.numSubSegs = 0, i.prototype.filter = function(t, n) {
					if (0 != n) for (var i = t[n - 1], o = t[n], r = (o.x - i.x) / this.numSubSegs, s = (o.y - i.y) / this.numSubSegs, a = 0; a < this.numSubSegs; a++) {
						var l = i.x + a * r,
							u = i.y + a * s,
							p = new jsts.geom.Coordinate(l, u);
						this.minPtDist.initialize(), e.computeDistance(this.geom, p, this.minPtDist), this.maxPtDist.setMaximum(this.minPtDist)
					}
				}, i.prototype.isGeometryChanged = function() {
					return !1
				}, i.prototype.isDone = function() {
					return !1
				}, i.prototype.getMaxPointDistance = function() {
					return this.maxPtDist
				}, jsts.algorithm.distance.DiscreteHausdorffDistance = function(t, e) {
					this.g0 = t, this.g1 = e, this.ptDist = new jsts.algorithm.distance.PointPairDistance
				}, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.g0 = null, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.g1 = null, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.ptDist = null, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.densifyFrac = 0, jsts.algorithm.distance.DiscreteHausdorffDistance.distance = function(t, e, n) {
					var i = new jsts.algorithm.distance.DiscreteHausdorffDistance(t, e);
					return void 0 !== n && i.setDensifyFraction(n), i.distance()
				}, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.setDensifyFraction = function(t) {
					if (t > 1 || 0 >= t) throw new jsts.error.IllegalArgumentError("Fraction is not in range (0.0 - 1.0]");
					this.densifyFrac = t
				}, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.distance = function() {
					return this.compute(this.g0, this.g1), ptDist.getDistance()
				}, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.orientedDistance = function() {
					return this.computeOrientedDistance(this.g0, this.g1, this.ptDist), this.ptDist.getDistance()
				}, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.getCoordinates = function() {
					return ptDist.getCoordinates()
				}, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.compute = function(t, e) {
					this.computeOrientedDistance(t, e, this.ptDist), this.computeOrientedDistance(e, t, this.ptDist)
				}, jsts.algorithm.distance.DiscreteHausdorffDistance.prototype.computeOrientedDistance = function(t, e, o) {
					var r = new n(e);
					if (t.apply(r), o.setMaximum(r.getMaxPointDistance()), this.densifyFrac > 0) {
						var s = new i(e, this.densifyFrac);
						t.apply(s), o.setMaximum(s.getMaxPointDistance())
					}
				}
			}(), jsts.algorithm.MinimumBoundingCircle = function(t) {
				this.input = null, this.extremalPts = null, this.centre = null, this.radius = 0, this.input = t
			}, jsts.algorithm.MinimumBoundingCircle.prototype.getCircle = function() {
				if (this.compute(), null === this.centre) return this.input.getFactory().createPolygon(null, null);
				var t = this.input.getFactory().createPoint(this.centre);
				return 0 === this.radius ? t : t.buffer(this.radius)
			}, jsts.algorithm.MinimumBoundingCircle.prototype.getExtremalPoints = function() {
				return this.compute(), this.extremalPts
			}, jsts.algorithm.MinimumBoundingCircle.prototype.getCentre = function() {
				return this.compute(), this.centre
			}, jsts.algorithm.MinimumBoundingCircle.prototype.getRadius = function() {
				return this.compute(), this.radius
			}, jsts.algorithm.MinimumBoundingCircle.prototype.computeCentre = function() {
				switch (this.extremalPts.length) {
				case 0:
					this.centre = null;
					break;
				case 1:
					this.centre = this.extremalPts[0];
					break;
				case 2:
					this.centre = new jsts.geom.Coordinate((this.extremalPts[0].x + this.extremalPts[1].x) / 2, (this.extremalPts[0].y + this.extremalPts[1].y) / 2);
					break;
				case 3:
					this.centre = jsts.geom.Triangle.circumcentre(this.extremalPts[0], this.extremalPts[1], this.extremalPts[2])
				}
			}, jsts.algorithm.MinimumBoundingCircle.prototype.compute = function() {
				null === this.extremalPts && (this.computeCirclePoints(), this.computeCentre(), null !== this.centre && (this.radius = this.centre.distance(this.extremalPts[0])))
			}, jsts.algorithm.MinimumBoundingCircle.prototype.computeCirclePoints = function() {
				if (this.input.isEmpty()) return void(this.extremalPts = []);
				var t;
				if (1 === this.input.getNumPoints()) return t = this.input.getCoordinates(), void(this.extremalPts = [new jsts.geom.Coordinate(t[0])]);
				var e = this.input.convexHull(),
					n = e.getCoordinates();
				if (t = n, n[0].equals2D(n[n.length - 1]) && (t = [], jsts.geom.CoordinateArrays.copyDeep(n, 0, t, 0, n.length - 1)), t.length <= 2) return void(this.extremalPts = jsts.geom.CoordinateArrays.copyDeep(t));
				for (var i = jsts.algorithm.MinimumBoundingCircle.lowestPoint(t), o = jsts.algorithm.MinimumBoundingCircle.pointWitMinAngleWithX(t, i), r = 0; r < t.length; r++) {
					var s = jsts.algorithm.MinimumBoundingCircle.pointWithMinAngleWithSegment(t, i, o);
					if (jsts.algorithm.Angle.isObtuse(i, s, o)) return void(this.extremalPts = [new jsts.geom.Coordinate(i), new jsts.geom.Coordinate(o)]);
					if (jsts.algorithm.Angle.isObtuse(s, i, o)) i = s;
					else {
						if (!jsts.algorithm.Angle.isObtuse(s, o, i)) return void(this.extremalPts = [new jsts.geom.Coordinate(i), new jsts.geom.Coordinate(o), new jsts.geom.Coordinate(s)]);
						o = s
					}
				}
				throw new Error("Logic failure in Minimum Bounding Circle algorithm!")
			}, jsts.algorithm.MinimumBoundingCircle.lowestPoint = function(t) {
				for (var e = t[0], n = 1; n < t.length; n++) t[n].y < e.y && (e = t[n]);
				return e
			}, jsts.algorithm.MinimumBoundingCircle.pointWitMinAngleWithX = function(t, e) {
				for (var n = Number.MAX_VALUE, i = null, o = 0; o < t.length; o++) {
					var r = t[o];
					if (r !== e) {
						var s = r.x - e.x,
							a = r.y - e.y;
						0 > a && (a = -a);
						var l = Math.sqrt(s * s + a * a),
							u = a / l;
						n > u && (n = u, i = r)
					}
				}
				return i
			}, jsts.algorithm.MinimumBoundingCircle.pointWithMinAngleWithSegment = function(t, e, n) {
				for (var i = Number.MAX_VALUE, o = null, r = 0; r < t.length; r++) {
					var s = t[r];
					if (s !== e && s !== n) {
						var a = jsts.algorithm.Angle.angleBetween(e, s, n);
						i > a && (i = a, o = s)
					}
				}
				return o
			}, jsts.noding.ScaledNoder = function(t, e, n, i) {
				this.offsetX = n ? n : 0, this.offsetY = i ? i : 0, this.noder = t, this.scaleFactor = e, this.isScaled = !this.isIntegerPrecision()
			}, jsts.noding.ScaledNoder.prototype = new jsts.noding.Noder, jsts.noding.ScaledNoder.constructor = jsts.noding.ScaledNoder, jsts.noding.ScaledNoder.prototype.noder = null, jsts.noding.ScaledNoder.prototype.scaleFactor = void 0, jsts.noding.ScaledNoder.prototype.offsetX = void 0, jsts.noding.ScaledNoder.prototype.offsetY = void 0, jsts.noding.ScaledNoder.prototype.isScaled = !1, jsts.noding.ScaledNoder.prototype.isIntegerPrecision = function() {
				return 1 === this.scaleFactor
			}, jsts.noding.ScaledNoder.prototype.getNodedSubstrings = function() {
				var t = this.noder.getNodedSubstrings();
				return this.isScaled && this.rescale(t), t
			}, jsts.noding.ScaledNoder.prototype.computeNodes = function(t) {
				var e = t;
				this.isScaled && (e = this.scale(t)), this.noder.computeNodes(e)
			}, jsts.noding.ScaledNoder.prototype.scale = function(t) {
				if (t instanceof Array) return this.scale2(t);
				for (var e = new javascript.util.ArrayList, n = t.iterator(); n.hasNext();) {
					var i = n.next();
					e.add(new jsts.noding.NodedSegmentString(this.scale(i.getCoordinates()), i.getData()))
				}
				return e
			}, jsts.noding.ScaledNoder.prototype.scale2 = function(t) {
				for (var e = [], n = 0; n < t.length; n++) e[n] = new jsts.geom.Coordinate(Math.round((t[n].x - this.offsetX) * this.scaleFactor), Math.round((t[n].y - this.offsetY) * this.scaleFactor));
				var i = jsts.geom.CoordinateArrays.removeRepeatedPoints(e);
				return i
			}, jsts.noding.ScaledNoder.prototype.rescale = function(t) {
				if (t instanceof Array) return void this.rescale2(t);
				for (var e = t.iterator(); e.hasNext();) {
					var n = e.next();
					this.rescale(n.getCoordinates())
				}
			}, jsts.noding.ScaledNoder.prototype.rescale2 = function(t) {
				for (var e = 0; e < t.length; e++) t[e].x = t[e].x / this.scaleFactor + this.offsetX, t[e].y = t[e].y / this.scaleFactor + this.offsetY
			}, function() {
				javascript.util.ArrayList, jsts.geomgraph.index.SegmentIntersector = function(t, e, n) {
					this.li = t, this.includeProper = e, this.recordIsolated = n
				}, jsts.geomgraph.index.SegmentIntersector.isAdjacentSegments = function(t, e) {
					return 1 === Math.abs(t - e)
				}, jsts.geomgraph.index.SegmentIntersector.prototype._hasIntersection = !1, jsts.geomgraph.index.SegmentIntersector.prototype.hasProper = !1, jsts.geomgraph.index.SegmentIntersector.prototype.hasProperInterior = !1, jsts.geomgraph.index.SegmentIntersector.prototype.properIntersectionPoint = null, jsts.geomgraph.index.SegmentIntersector.prototype.li = null, jsts.geomgraph.index.SegmentIntersector.prototype.includeProper = null, jsts.geomgraph.index.SegmentIntersector.prototype.recordIsolated = null, jsts.geomgraph.index.SegmentIntersector.prototype.isSelfIntersection = null, jsts.geomgraph.index.SegmentIntersector.prototype.numIntersections = 0, jsts.geomgraph.index.SegmentIntersector.prototype.numTests = 0, jsts.geomgraph.index.SegmentIntersector.prototype.bdyNodes = null, jsts.geomgraph.index.SegmentIntersector.prototype.setBoundaryNodes = function(t, e) {
					this.bdyNodes = [], this.bdyNodes[0] = t, this.bdyNodes[1] = e
				}, jsts.geomgraph.index.SegmentIntersector.prototype.getProperIntersectionPoint = function() {
					return this.properIntersectionPoint
				}, jsts.geomgraph.index.SegmentIntersector.prototype.hasIntersection = function() {
					return this._hasIntersection
				}, jsts.geomgraph.index.SegmentIntersector.prototype.hasProperIntersection = function() {
					return this.hasProper
				}, jsts.geomgraph.index.SegmentIntersector.prototype.hasProperInteriorIntersection = function() {
					return this.hasProperInterior
				}, jsts.geomgraph.index.SegmentIntersector.prototype.isTrivialIntersection = function(t, e, n, i) {
					if (t === n && 1 === this.li.getIntersectionNum()) {
						if (jsts.geomgraph.index.SegmentIntersector.isAdjacentSegments(e, i)) return !0;
						if (t.isClosed()) {
							var o = t.getNumPoints() - 1;
							if (0 === e && i === o || 0 === i && e === o) return !0
						}
					}
					return !1
				}, jsts.geomgraph.index.SegmentIntersector.prototype.addIntersections = function(t, e, n, i) {
					if (t !== n || e !== i) {
						this.numTests++;
						var o = t.getCoordinates()[e],
							r = t.getCoordinates()[e + 1],
							s = n.getCoordinates()[i],
							a = n.getCoordinates()[i + 1];
						this.li.computeIntersection(o, r, s, a), this.li.hasIntersection() && (this.recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this.numIntersections++, this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0, (this.includeProper || !this.li.isProper()) && (t.addIntersections(this.li, e, 0), n.addIntersections(this.li, i, 1)), this.li.isProper() && (this.properIntersectionPoint = this.li.getIntersection(0).clone(), this.hasProper = !0, this.isBoundaryPoint(this.li, this.bdyNodes) || (this.hasProperInterior = !0))))
					}
				}, jsts.geomgraph.index.SegmentIntersector.prototype.isBoundaryPoint = function(t, e) {
					if (null === e) return !1;
					if (e instanceof Array) return !!this.isBoundaryPoint(t, e[0]) || !! this.isBoundaryPoint(t, e[1]);
					for (var n = e.iterator(); n.hasNext();) {
						var i = n.next(),
							o = i.getCoordinate();
						if (t.isIntersection(o)) return !0
					}
					return !1
				}
			}()
		}, {}],
		19: [function() {
			(function(t) {
				(function() {
					function e(t, e) {
						var n = t.split("."),
							i = N;
						n[0] in i || !i.execScript || i.execScript("var " + n[0]);
						for (var o; n.length && (o = n.shift());) n.length || void 0 === e ? i = i[o] ? i[o] : i[o] = {} : i[o] = e
					}
					function n(t, e) {
						function n() {}
						n.prototype = e.prototype, t.q = e.prototype, t.prototype = new n, t.prototype.constructor = t, t.p = function(t, n) {
							var i = Array.prototype.slice.call(arguments, 2);
							return e.prototype[n].apply(t, i)
						}
					}
					function i(t) {
						this.message = t || ""
					}
					function o(t) {
						this.message = t || ""
					}
					function r() {}
					function s() {}
					function a() {}
					function l() {}
					function u(t) {
						this.message = t || ""
					}
					function p(t) {
						this.message = t || ""
					}
					function h(t) {
						this.a = [], t instanceof s && this.e(t)
					}
					function c(t) {
						this.j = t
					}
					function g() {}
					function d() {
						this.i = {}
					}
					function f() {}
					function m(t) {
						this.a = [], t instanceof s && this.e(t)
					}
					function y(t) {
						this.k = t
					}
					function v() {}
					function x() {}
					function j() {
						this.a = []
					}
					function E(t) {
						return null == t ? null : t.parent
					}
					function I(t, e) {
						null !== t && (t.color = e)
					}
					function C(t) {
						return null == t ? null : t.left
					}
					function S(t) {
						return null == t ? null : t.right
					}
					function b() {
						this.d = null, this.n = 0
					}
					function L(t, e) {
						if (null != e) {
							var n = e.right;
							e.right = n.left, null != n.left && (n.left.parent = e), n.parent = e.parent, null == e.parent ? t.d = n : e.parent.left == e ? e.parent.left = n : e.parent.right = n, n.left = e, e.parent = n
						}
					}
					function w(t, e) {
						if (null != e) {
							var n = e.left;
							e.left = n.right, null != n.right && (n.right.parent = e), n.parent = e.parent, null == e.parent ? t.d = n : e.parent.right == e ? e.parent.right = n : e.parent.left = n, n.right = e, e.parent = n
						}
					}
					function P(t) {
						if (null === t) return null;
						if (null !== t.right) for (var e = t.right; null !== e.left;) e = e.left;
						else for (e = t.parent; null !== e && t === e.right;) t = e, e = e.parent;
						return e
					}
					function M(t) {
						this.a = [], t instanceof s && this.e(t)
					}
					function _(t) {
						this.l = t
					}
					var N = this;
					n(i, Error), e("javascript.util.EmptyStackException", i), i.prototype.name = "EmptyStackException", n(o, Error), e("javascript.util.IndexOutOfBoundsException", o), o.prototype.name = "IndexOutOfBoundsException", e("javascript.util.Iterator", r), r.prototype.hasNext = r.prototype.c, r.prototype.next = r.prototype.next, r.prototype.remove = r.prototype.remove, e("javascript.util.Collection", s), n(a, s), e("javascript.util.List", a), e("javascript.util.Map", l), n(u, Error), e("javascript.util.NoSuchElementException", u), u.prototype.name = "NoSuchElementException", n(p, Error), p.prototype.name = "OperationNotSupported", n(h, a), e("javascript.util.ArrayList", h), h.prototype.a = null, h.prototype.add = function(t) {
						return this.a.push(t), !0
					}, h.prototype.add = h.prototype.add, h.prototype.e = function(t) {
						for (t = t.f(); t.c();) this.add(t.next());
						return !0
					}, h.prototype.addAll = h.prototype.e, h.prototype.set = function(t, e) {
						var n = this.a[t];
						return this.a[t] = e, n
					}, h.prototype.set = h.prototype.set, h.prototype.f = function() {
						return new c(this)
					}, h.prototype.iterator = h.prototype.f, h.prototype.get = function(t) {
						if (0 > t || t >= this.size()) throw new o;
						return this.a[t]
					}, h.prototype.get = h.prototype.get, h.prototype.g = function() {
						return 0 === this.a.length
					}, h.prototype.isEmpty = h.prototype.g, h.prototype.size = function() {
						return this.a.length
					}, h.prototype.size = h.prototype.size, h.prototype.h = function() {
						for (var t = [], e = 0, n = this.a.length; n > e; e++) t.push(this.a[e]);
						return t
					}, h.prototype.toArray = h.prototype.h, h.prototype.remove = function(t) {
						for (var e = !1, n = 0, i = this.a.length; i > n; n++) if (this.a[n] === t) {
							this.a.splice(n, 1), e = !0;
							break
						}
						return e
					}, h.prototype.remove = h.prototype.remove, e("$jscomp.scope.Iterator_", c), c.prototype.j = null, c.prototype.b = 0, c.prototype.next = function() {
						if (this.b === this.j.size()) throw new u;
						return this.j.get(this.b++)
					}, c.prototype.next = c.prototype.next, c.prototype.c = function() {
						return this.b < this.j.size()
					}, c.prototype.hasNext = c.prototype.c, c.prototype.remove = function() {
						throw new p
					}, c.prototype.remove = c.prototype.remove, e("javascript.util.Arrays", g), g.sort = function() {
						var t, e, n, i = arguments[0];
						if (1 === arguments.length) i.sort();
						else if (2 === arguments.length) e = arguments[1], n = function(t, n) {
							return e.compare(t, n)
						}, i.sort(n);
						else if (3 === arguments.length) for (t = i.slice(arguments[1], arguments[2]), t.sort(), n = i.slice(0, arguments[1]).concat(t, i.slice(arguments[2], i.length)), i.splice(0, i.length), t = 0; t < n.length; t++) i.push(n[t]);
						else if (4 === arguments.length) for (t = i.slice(arguments[1], arguments[2]), e = arguments[3], n = function(t, n) {
							return e.compare(t, n)
						}, t.sort(n), n = i.slice(0, arguments[1]).concat(t, i.slice(arguments[2], i.length)), i.splice(0, i.length), t = 0; t < n.length; t++) i.push(n[t])
					}, g.asList = function(t) {
						for (var e = new h, n = 0, i = t.length; i > n; n++) e.add(t[n]);
						return e
					}, n(d, l), e("javascript.util.HashMap", d), d.prototype.i = null, d.prototype.get = function(t) {
						return this.i[t] || null
					}, d.prototype.get = d.prototype.get, d.prototype.put = function(t, e) {
						return this.i[t] = e
					}, d.prototype.put = d.prototype.put, d.prototype.m = function() {
						var t, e = new h;
						for (t in this.i) this.i.hasOwnProperty(t) && e.add(this.i[t]);
						return e
					}, d.prototype.values = d.prototype.m, d.prototype.size = function() {
						return this.m().size()
					}, d.prototype.size = d.prototype.size, n(f, s), e("javascript.util.Set", f), n(m, f), e("javascript.util.HashSet", m), m.prototype.a = null, m.prototype.contains = function(t) {
						for (var e = 0, n = this.a.length; n > e; e++) if (this.a[e] === t) return !0;
						return !1
					}, m.prototype.contains = m.prototype.contains, m.prototype.add = function(t) {
						return !this.contains(t) && (this.a.push(t), !0)
					}, m.prototype.add = m.prototype.add, m.prototype.e = function(t) {
						for (t = t.f(); t.c();) this.add(t.next());
						return !0
					}, m.prototype.addAll = m.prototype.e, m.prototype.remove = function() {
						throw new p
					}, m.prototype.remove = m.prototype.remove, m.prototype.size = function() {
						return this.a.length
					}, m.prototype.g = function() {
						return 0 === this.a.length
					}, m.prototype.isEmpty = m.prototype.g, m.prototype.h = function() {
						for (var t = [], e = 0, n = this.a.length; n > e; e++) t.push(this.a[e]);
						return t
					}, m.prototype.toArray = m.prototype.h, m.prototype.f = function() {
						return new y(this)
					}, m.prototype.iterator = m.prototype.f, e("$jscomp.scope.Iterator_$1", y), y.prototype.k = null, y.prototype.b = 0, y.prototype.next = function() {
						if (this.b === this.k.size()) throw new u;
						return this.k.a[this.b++]
					}, y.prototype.next = y.prototype.next, y.prototype.c = function() {
						return this.b < this.k.size()
					}, y.prototype.hasNext = y.prototype.c, y.prototype.remove = function() {
						throw new p
					}, y.prototype.remove = y.prototype.remove, n(v, l), e("javascript.util.SortedMap", v), n(x, f), e("javascript.util.SortedSet", x), n(j, a), e("javascript.util.Stack", j), j.prototype.a = null, j.prototype.push = function(t) {
						return this.a.push(t), t
					}, j.prototype.push = j.prototype.push, j.prototype.pop = function() {
						if (0 === this.a.length) throw new i;
						return this.a.pop()
					}, j.prototype.pop = j.prototype.pop, j.prototype.o = function() {
						if (0 === this.a.length) throw new i;
						return this.a[this.a.length - 1]
					}, j.prototype.peek = j.prototype.o, j.prototype.empty = function() {
						return 0 === this.a.length
					}, j.prototype.empty = j.prototype.empty, j.prototype.g = function() {
						return this.empty()
					}, j.prototype.isEmpty = j.prototype.g, j.prototype.search = function(t) {
						return this.a.indexOf(t)
					}, j.prototype.search = j.prototype.search, j.prototype.size = function() {
						return this.a.length
					}, j.prototype.size = j.prototype.size, j.prototype.h = function() {
						for (var t = [], e = 0, n = this.a.length; n > e; e++) t.push(this.a[e]);
						return t
					}, j.prototype.toArray = j.prototype.h, n(b, v), e("javascript.util.TreeMap", b), b.prototype.get = function(t) {
						for (var e = this.d; null !== e;) {
							var n = t.compareTo(e.key);
							if (0 > n) e = e.left;
							else {
								if (!(n > 0)) return e.value;
								e = e.right
							}
						}
						return null
					}, b.prototype.get = b.prototype.get, b.prototype.put = function(t, e) {
						if (null === this.d) return this.d = {
							key: t,
							value: e,
							left: null,
							right: null,
							parent: null,
							color: 0
						}, this.n = 1, null;
						var n, i, o = this.d;
						do
						if (n = o, i = t.compareTo(o.key), 0 > i) o = o.left;
						else {
							if (!(i > 0)) return n = o.value, o.value = e, n;
							o = o.right
						}
						while (null !== o);
						for (o = {
							key: t,
							left: null,
							right: null,
							value: e,
							parent: n,
							color: 0
						}, 0 > i ? n.left = o : n.right = o, o.color = 1; null != o && o != this.d && 1 == o.parent.color;) E(o) == C(E(E(o))) ? (n = S(E(E(o))), 1 == (null == n ? 0 : n.color) ? (I(E(o), 0), I(n, 0), I(E(E(o)), 1), o = E(E(o))) : (o == S(E(o)) && (o = E(o), L(this, o)), I(E(o), 0), I(E(E(o)), 1), w(this, E(E(o))))) : (n = C(E(E(o))), 1 == (null == n ? 0 : n.color) ? (I(E(o), 0), I(n, 0), I(E(E(o)), 1), o = E(E(o))) : (o == C(E(o)) && (o = E(o), w(this, o)), I(E(o), 0), I(E(E(o)), 1), L(this, E(E(o)))));
						return this.d.color = 0, this.n++, null
					}, b.prototype.put = b.prototype.put, b.prototype.m = function() {
						var t, e = new h;
						if (t = this.d, null != t) for (; null != t.left;) t = t.left;
						if (null !== t) for (e.add(t.value); null !== (t = P(t));) e.add(t.value);
						return e
					}, b.prototype.values = b.prototype.m, b.prototype.size = function() {
						return this.n
					}, b.prototype.size = b.prototype.size, n(M, x), e("javascript.util.TreeSet", M), M.prototype.a = null, M.prototype.contains = function(t) {
						for (var e = 0, n = this.a.length; n > e; e++) if (0 === this.a[e].compareTo(t)) return !0;
						return !1
					}, M.prototype.contains = M.prototype.contains, M.prototype.add = function(t) {
						if (this.contains(t)) return !1;
						for (var e = 0, n = this.a.length; n > e; e++) if (1 === this.a[e].compareTo(t)) return this.a.splice(e, 0, t), !0;
						return this.a.push(t), !0
					}, M.prototype.add = M.prototype.add, M.prototype.e = function(t) {
						for (t = t.f(); t.c();) this.add(t.next());
						return !0
					}, M.prototype.addAll = M.prototype.e, M.prototype.remove = function() {
						throw new p
					}, M.prototype.remove = M.prototype.remove, M.prototype.size = function() {
						return this.a.length
					}, M.prototype.size = M.prototype.size, M.prototype.g = function() {
						return 0 === this.a.length
					}, M.prototype.isEmpty = M.prototype.g, M.prototype.h = function() {
						for (var t = [], e = 0, n = this.a.length; n > e; e++) t.push(this.a[e]);
						return t
					}, M.prototype.toArray = M.prototype.h, M.prototype.f = function() {
						return new _(this)
					}, M.prototype.iterator = M.prototype.f, e("$jscomp.scope.Iterator_$2", _), _.prototype.l = null, _.prototype.b = 0, _.prototype.next = function() {
						if (this.b === this.l.size()) throw new u;
						return this.l.a[this.b++]
					}, _.prototype.next = _.prototype.next, _.prototype.c = function() {
						return this.b < this.l.size()
					}, _.prototype.hasNext = _.prototype.c, _.prototype.remove = function() {
						throw new p
					}, _.prototype.remove = _.prototype.remove, "undefined" != typeof t && (t.javascript = {}, t.javascript.util = {}, t.javascript.util.ArrayList = h, t.javascript.util.Arrays = g, t.javascript.util.Collection = s, t.javascript.util.EmptyStackException = i, t.javascript.util.HashMap = d, t.javascript.util.HashSet = m, t.javascript.util.IndexOutOfBoundsException = o, t.javascript.util.Iterator = r, t.javascript.util.List = a, t.javascript.util.Map = l, t.javascript.util.NoSuchElementException = u, t.javascript.util.OperationNotSupported = p, t.javascript.util.Set = f, t.javascript.util.SortedMap = v, t.javascript.util.SortedSet = x, t.javascript.util.Stack = j, t.javascript.util.TreeMap = b, t.javascript.util.TreeSet = M)
				}).call(this)
			}).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
		}, {}],
		20: [function(t) {
			t("./dist/javascript.util-node.min.js")
		}, {
			"./dist/javascript.util-node.min.js": 19
		}],
		21: [function(t, e) {
			var n = t("turf-extent"),
				i = t("turf-point");
			e.exports = function(t) {
				var e = n(t),
					o = (e[0] + e[2]) / 2,
					r = (e[1] + e[3]) / 2;
				return i([o, r])
			}
		}, {
			"turf-extent": 70,
			"turf-point": 102
		}],
		22: [function(t, e) {
			var n = t("turf-meta").coordEach,
				i = t("turf-point");
			e.exports = function(t) {
				var e = 0,
					o = 0,
					r = 0;
				return n(t, function(t) {
					e += t[0], o += t[1], r++
				}, !0), i([e / r, o / r])
			}
		}, {
			"turf-meta": 23,
			"turf-point": 102
		}],
		23: [function(t, e) {
			function n(t, e, n) {
				var i, o, r, s, a, u, p, h, c, g = 0,
					d = "FeatureCollection" === t.type,
					f = "Feature" === t.type,
					m = d ? t.features.length : 1;
				for (i = 0; m > i; i++) for (h = d ? t.features[i].geometry : f ? t.geometry : t, c = "GeometryCollection" === h.type, u = c ? h.geometries.length : 1, s = 0; u > s; s++) if (a = c ? h.geometries[s] : h, p = a.coordinates, g = !n || "Polygon" !== a.type && "MultiPolygon" !== a.type ? 0 : 1, "Point" === a.type) e(p);
				else if ("LineString" === a.type || "MultiPoint" === a.type) for (o = 0; o < p.length; o++) e(p[o]);
				else if ("Polygon" === a.type || "MultiLineString" === a.type) for (o = 0; o < p.length; o++) for (r = 0; r < p[o].length - g; r++) e(p[o][r]);
				else {
					if ("MultiPolygon" !== a.type) throw new Error("Unknown Geometry Type");
					for (o = 0; o < p.length; o++) for (r = 0; r < p[o].length; r++) for (l = 0; l < p[o][r].length - g; l++) e(p[o][r][l])
				}
			}
			function i(t, e, i, o) {
				return n(t, function(t) {
					i = e(i, t)
				}, o), i
			}
			function o(t, e) {
				var n;
				switch (t.type) {
				case "FeatureCollection":
					for (features = t.features, n = 0; n < t.features.length; n++) e(t.features[n].properties);
					break;
				case "Feature":
					e(t.properties)
				}
			}
			function r(t, e, n) {
				return o(t, function(t) {
					n = e(n, t)
				}), n
			}
			e.exports.coordEach = n, e.exports.coordReduce = i, e.exports.propEach = o, e.exports.propReduce = r
		}, {}],
		24: [function(t, e) {
			function n(t) {
				return t.map(function(t) {
					return t.coordinates
				})
			}
			e.exports = function(t) {
				var e = t.features[0].geometry.type,
					i = t.features.map(function(t) {
						return t.geometry
					});
				switch (e) {
				case "Point":
					return {
						type: "Feature",
						properties: {},
						geometry: {
							type: "MultiPoint",
							coordinates: n(i)
						}
					};
				case "LineString":
					return {
						type: "Feature",
						properties: {},
						geometry: {
							type: "MultiLineString",
							coordinates: n(i)
						}
					};
				case "Polygon":
					return {
						type: "Feature",
						properties: {},
						geometry: {
							type: "MultiPolygon",
							coordinates: n(i)
						}
					};
				default:
					return t
				}
			}
		}, {}],
		25: [function(t, e) {
			var n = {};
			n.tin = t("turf-tin"), n.merge = t("turf-merge"), n.distance = t("turf-distance"), n.point = t("turf-point"), e.exports = function(t, e, i) {
				function o(t) {
					var o = n.point(t.geometry.coordinates[0][0]),
						r = n.point(t.geometry.coordinates[0][1]),
						s = n.point(t.geometry.coordinates[0][2]),
						a = n.distance(o, r, i),
						l = n.distance(r, s, i),
						u = n.distance(o, s, i);
					return e >= a && e >= l && e >= u
				}
				if ("number" != typeof e) throw new Error("maxEdge parameter is required");
				if ("string" != typeof i) throw new Error("units parameter is required");
				var r = n.tin(t),
					s = r.features.filter(o);
				return r.features = s, n.merge(r)
			}
		}, {
			"turf-distance": 60,
			"turf-merge": 93,
			"turf-point": 102,
			"turf-tin": 118
		}],
		26: [function(t, e) {
			var n = t("turf-meta").coordEach,
				i = t("convex-hull"),
				o = t("turf-polygon");
			e.exports = function(t) {
				var e = [];
				n(t, function(t) {
					e.push(t)
				});
				for (var r = i(e), s = [], a = 0; a < r.length; a++) s.push(e[r[a][0]]);
				return s.push(e[r[r.length - 1][1]]), o([s])
			}
		}, {
			"convex-hull": 27,
			"turf-meta": 55,
			"turf-polygon": 103
		}],
		27: [function(t, e) {
			"use strict";

			function n(t) {
				var e = t.length;
				if (0 === e) return [];
				if (1 === e) return [[0]];
				var n = t[0].length;
				return 0 === n ? [] : 1 === n ? i(t) : 2 === n ? o(t) : r(t, n)
			}
			var i = t("./lib/ch1d"),
				o = t("./lib/ch2d"),
				r = t("./lib/chnd");
			e.exports = n
		}, {
			"./lib/ch1d": 28,
			"./lib/ch2d": 29,
			"./lib/chnd": 30
		}],
		28: [function(t, e) {
			"use strict";

			function n(t) {
				for (var e = 0, n = 0, i = 1; i < t.length; ++i) t[i][0] < t[e][0] && (e = i), t[i][0] > t[n][0] && (n = i);
				return n > e ? [
					[e],
					[n]
				] : e > n ? [
					[n],
					[e]
				] : [
					[e]
				]
			}
			e.exports = n
		}, {}],
		29: [function(t, e) {
			"use strict";

			function n(t) {
				var e = i(t),
					n = e.length;
				if (2 >= n) return [];
				for (var o = new Array(n), r = e[n - 1], s = 0; n > s; ++s) {
					var a = e[s];
					o[s] = [r, a], r = a
				}
				return o
			}
			e.exports = n;
			var i = t("monotone-convex-hull-2d")
		}, {
			"monotone-convex-hull-2d": 48
		}],
		30: [function(t, e) {
			"use strict";

			function n(t, e) {
				for (var n = t.length, i = new Array(n), o = 0; o < e.length; ++o) i[o] = t[e[o]];
				for (var r = e.length, o = 0; n > o; ++o) e.indexOf(o) < 0 && (i[r++] = t[o]);
				return i
			}
			function i(t, e) {
				for (var n = t.length, i = e.length, o = 0; n > o; ++o) for (var r = t[o], s = 0; s < r.length; ++s) {
					var a = r[s];
					if (i > a) r[s] = e[a];
					else {
						a -= i;
						for (var l = 0; i > l; ++l) a >= e[l] && (a += 1);
						r[s] = a
					}
				}
				return t
			}
			function o(t, e) {
				try {
					return r(t, !0)
				} catch (o) {
					var a = s(t);
					if (a.length <= e) return [];
					var l = n(t, a),
						u = r(l, !0);
					return i(u, a)
				}
			}
			e.exports = o;
			var r = t("incremental-convex-hull"),
				s = t("affine-hull")
		}, {
			"affine-hull": 31,
			"incremental-convex-hull": 38
		}],
		31: [function(t, e) {
			"use strict";

			function n(t, e) {
				for (var n = new Array(e + 1), i = 0; i < t.length; ++i) n[i] = t[i];
				for (var i = 0; i <= t.length; ++i) {
					for (var r = t.length; e >= r; ++r) {
						for (var s = new Array(e), a = 0; e > a; ++a) s[a] = Math.pow(r + 1 - i, a);
						n[r] = s
					}
					var l = o.apply(void 0, n);
					if (l) return !0
				}
				return !1
			}
			function i(t) {
				var e = t.length;
				if (0 === e) return [];
				if (1 === e) return [0];
				for (var i = t[0].length, o = [t[0]], r = [0], s = 1; e > s; ++s) if (o.push(t[s]), n(o, i)) {
					if (r.push(s), r.length === i + 1) return r
				} else o.pop();
				return r
			}
			e.exports = i;
			var o = t("robust-orientation")
		}, {
			"robust-orientation": 37
		}],
		32: [function(t, e) {
			"use strict";

			function n(t, e, n) {
				var i = t + e,
					o = i - t,
					r = i - o,
					s = e - o,
					a = t - r;
				return n ? (n[0] = a + s, n[1] = i, n) : [a + s, i]
			}
			e.exports = n
		}, {}],
		33: [function(t, e) {
			"use strict";

			function n(t, e) {
				var n = t.length;
				if (1 === n) {
					var r = i(t[0], e);
					return r[0] ? r : [r[1]]
				}
				var s = new Array(2 * n),
					a = [.1, .1],
					l = [.1, .1],
					u = 0;
				i(t[0], e, a), a[0] && (s[u++] = a[0]);
				for (var p = 1; n > p; ++p) {
					i(t[p], e, l);
					var h = a[1];
					o(h, l[0], a), a[0] && (s[u++] = a[0]);
					var c = l[1],
						g = a[1],
						d = c + g,
						f = d - c,
						m = g - f;
					a[1] = d, m && (s[u++] = m)
				}
				return a[1] && (s[u++] = a[1]), 0 === u && (s[u++] = 0), s.length = u, s
			}
			var i = t("two-product"),
				o = t("two-sum");
			e.exports = n
		}, {
			"two-product": 36,
			"two-sum": 32
		}],
		34: [function(t, e) {
			"use strict";

			function n(t, e) {
				var n = t + e,
					i = n - t,
					o = n - i,
					r = e - i,
					s = t - o,
					a = s + r;
				return a ? [a, n] : [n]
			}
			function i(t, e) {
				var i = 0 | t.length,
					o = 0 | e.length;
				if (1 === i && 1 === o) return n(t[0], -e[0]);
				var r, s, a = i + o,
					l = new Array(a),
					u = 0,
					p = 0,
					h = 0,
					c = Math.abs,
					g = t[p],
					d = c(g),
					f = -e[h],
					m = c(f);
				m > d ? (s = g, p += 1, i > p && (g = t[p], d = c(g))) : (s = f, h += 1, o > h && (f = -e[h], m = c(f))), i > p && m > d || h >= o ? (r = g, p += 1, i > p && (g = t[p], d = c(g))) : (r = f, h += 1, o > h && (f = -e[h], m = c(f)));
				for (var y, v, x, j, E, I = r + s, C = I - r, S = s - C, b = S, L = I; i > p && o > h;) m > d ? (r = g, p += 1, i > p && (g = t[p], d = c(g))) : (r = f, h += 1, o > h && (f = -e[h], m = c(f))), s = b, I = r + s, C = I - r, S = s - C, S && (l[u++] = S), y = L + I, v = y - L, x = y - v, j = I - v, E = L - x, b = E + j, L = y;
				for (; i > p;) r = g, s = b, I = r + s, C = I - r, S = s - C, S && (l[u++] = S), y = L + I, v = y - L, x = y - v, j = I - v, E = L - x, b = E + j, L = y, p += 1, i > p && (g = t[p]);
				for (; o > h;) r = f, s = b, I = r + s, C = I - r, S = s - C, S && (l[u++] = S), y = L + I, v = y - L, x = y - v, j = I - v, E = L - x, b = E + j, L = y, h += 1, o > h && (f = -e[h]);
				return b && (l[u++] = b), L && (l[u++] = L), u || (l[u++] = 0), l.length = u, l
			}
			e.exports = i
		}, {}],
		35: [function(t, e) {
			"use strict";

			function n(t, e) {
				var n = t + e,
					i = n - t,
					o = n - i,
					r = e - i,
					s = t - o,
					a = s + r;
				return a ? [a, n] : [n]
			}
			function i(t, e) {
				var i = 0 | t.length,
					o = 0 | e.length;
				if (1 === i && 1 === o) return n(t[0], e[0]);
				var r, s, a = i + o,
					l = new Array(a),
					u = 0,
					p = 0,
					h = 0,
					c = Math.abs,
					g = t[p],
					d = c(g),
					f = e[h],
					m = c(f);
				m > d ? (s = g, p += 1, i > p && (g = t[p], d = c(g))) : (s = f, h += 1, o > h && (f = e[h], m = c(f))), i > p && m > d || h >= o ? (r = g, p += 1, i > p && (g = t[p], d = c(g))) : (r = f, h += 1, o > h && (f = e[h], m = c(f)));
				for (var y, v, x, j, E, I = r + s, C = I - r, S = s - C, b = S, L = I; i > p && o > h;) m > d ? (r = g, p += 1, i > p && (g = t[p], d = c(g))) : (r = f, h += 1, o > h && (f = e[h], m = c(f))), s = b, I = r + s, C = I - r, S = s - C, S && (l[u++] = S), y = L + I, v = y - L, x = y - v, j = I - v, E = L - x, b = E + j, L = y;
				for (; i > p;) r = g, s = b, I = r + s, C = I - r, S = s - C, S && (l[u++] = S), y = L + I, v = y - L, x = y - v, j = I - v, E = L - x, b = E + j, L = y, p += 1, i > p && (g = t[p]);
				for (; o > h;) r = f, s = b, I = r + s, C = I - r, S = s - C, S && (l[u++] = S), y = L + I, v = y - L, x = y - v, j = I - v, E = L - x, b = E + j, L = y, h += 1, o > h && (f = e[h]);
				return b && (l[u++] = b), L && (l[u++] = L), u || (l[u++] = 0), l.length = u, l
			}
			e.exports = i
		}, {}],
		36: [function(t, e) {
			"use strict";

			function n(t, e, n) {
				var o = t * e,
					r = i * t,
					s = r - t,
					a = r - s,
					l = t - a,
					u = i * e,
					p = u - e,
					h = u - p,
					c = e - h,
					g = o - a * h,
					d = g - l * h,
					f = d - a * c,
					m = l * c - f;
				return n ? (n[0] = m, n[1] = o, n) : [m, o]
			}
			e.exports = n;
			var i = +(Math.pow(2, 27) + 1)
		}, {}],
		37: [function(t, e) {
			"use strict";

			function n(t, e) {
				for (var n = new Array(t.length - 1), i = 1; i < t.length; ++i) for (var o = n[i - 1] = new Array(t.length - 1), r = 0, s = 0; r < t.length; ++r) r !== e && (o[s++] = t[i][r]);
				return n
			}
			function i(t) {
				for (var e = new Array(t), n = 0; t > n; ++n) {
					e[n] = new Array(t);
					for (var i = 0; t > i; ++i) e[n][i] = ["m", i, "[", t - n - 1, "]"].join("")
				}
				return e
			}
			function o(t) {
				return 1 & t ? "-" : ""
			}
			function r(t) {
				if (1 === t.length) return t[0];
				if (2 === t.length) return ["sum(", t[0], ",", t[1], ")"].join("");
				var e = t.length >> 1;
				return ["sum(", r(t.slice(0, e)), ",", r(t.slice(e)), ")"].join("")
			}
			function s(t) {
				if (2 === t.length) return [["sum(prod(", t[0][0], ",", t[1][1], "),prod(-", t[0][1], ",", t[1][0], "))"].join("")];
				for (var e = [], i = 0; i < t.length; ++i) e.push(["scale(", r(s(n(t, i))), ",", o(i), t[0][i], ")"].join(""));
				return e
			}
			function a(t) {
				for (var e = [], o = [], a = i(t), l = [], u = 0; t > u; ++u) 0 === (1 & u) ? e.push.apply(e, s(n(a, u))) : o.push.apply(o, s(n(a, u))), l.push("m" + u);
				var d = r(e),
					f = r(o),
					m = "orientation" + t + "Exact",
					y = ["function ", m, "(", l.join(), "){var p=", d, ",n=", f, ",d=sub(p,n);return d[d.length-1];};return ", m].join(""),
					v = new Function("sum", "prod", "scale", "sub", y);
				return v(h, p, c, g)
			}
			function l(t) {
				var e = j[t.length];
				return e || (e = j[t.length] = a(t.length)), e.apply(void 0, t)
			}
			function u() {
				for (; j.length <= d;) j.push(a(j.length));
				for (var t = [], n = ["slow"], i = 0; d >= i; ++i) t.push("a" + i), n.push("o" + i);
				for (var o = ["function getOrientation(", t.join(), "){switch(arguments.length){case 0:case 1:return 0;"], i = 2; d >= i; ++i) o.push("case ", i, ":return o", i, "(", t.slice(0, i).join(), ");");
				o.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation"), n.push(o.join(""));
				var r = Function.apply(void 0, n);
				e.exports = r.apply(void 0, [l].concat(j));
				for (var i = 0; d >= i; ++i) e.exports[i] = j[i]
			}
			var p = t("two-product"),
				h = t("robust-sum"),
				c = t("robust-scale"),
				g = t("robust-subtract"),
				d = 5,
				f = 1.1102230246251565e-16,
				m = (3 + 16 * f) * f,
				y = (7 + 56 * f) * f,
				v = a(3),
				x = a(4),
				j = [function() {
					return 0
				}, function() {
					return 0
				}, function(t, e) {
					return e[0] - t[0]
				}, function(t, e, n) {
					var i, o = (t[1] - n[1]) * (e[0] - n[0]),
						r = (t[0] - n[0]) * (e[1] - n[1]),
						s = o - r;
					if (o > 0) {
						if (0 >= r) return s;
						i = o + r
					} else {
						if (!(0 > o)) return s;
						if (r >= 0) return s;
						i = -(o + r)
					}
					var a = m * i;
					return s >= a || -a >= s ? s : v(t, e, n)
				}, function(t, e, n, i) {
					var o = t[0] - i[0],
						r = e[0] - i[0],
						s = n[0] - i[0],
						a = t[1] - i[1],
						l = e[1] - i[1],
						u = n[1] - i[1],
						p = t[2] - i[2],
						h = e[2] - i[2],
						c = n[2] - i[2],
						g = r * u,
						d = s * l,
						f = s * a,
						m = o * u,
						v = o * l,
						j = r * a,
						E = p * (g - d) + h * (f - m) + c * (v - j),
						I = (Math.abs(g) + Math.abs(d)) * Math.abs(p) + (Math.abs(f) + Math.abs(m)) * Math.abs(h) + (Math.abs(v) + Math.abs(j)) * Math.abs(c),
						C = y * I;
					return E > C || -E > C ? E : x(t, e, n, i)
				}];
			u()
		}, {
			"robust-scale": 33,
			"robust-subtract": 34,
			"robust-sum": 35,
			"two-product": 36
		}],
		38: [function(t, e) {
			"use strict";

			function n(t, e, n) {
				this.vertices = t, this.adjacent = e, this.boundary = n, this.lastVisited = -1
			}
			function i(t, e, n) {
				this.vertices = t, this.cell = e, this.index = n
			}
			function o(t, e) {
				return u(t.vertices, e.vertices)
			}
			function r(t) {
				for (var e = ["function orient(){var tuple=this.tuple;return test("], n = 0; t >= n; ++n) n > 0 && e.push(","), e.push("tuple[", n, "]");
				e.push(")}return orient");
				var i = new Function("test", e.join("")),
					o = l[t + 1];
				return o || (o = l), i(o)
			}
			function s(t, e, n) {
				this.dimension = t, this.vertices = e, this.simplices = n, this.interior = n.filter(function(t) {
					return !t.boundary
				}), this.tuple = new Array(t + 1);
				for (var i = 0; t >= i; ++i) this.tuple[i] = this.vertices[i];
				var o = p[t];
				o || (o = p[t] = r(t)), this.orient = o
			}
			function a(t, e) {
				var i = t.length;
				if (0 === i) throw new Error("Must have at least d+1 points");
				var o = t[0].length;
				if (o >= i) throw new Error("Must input at least d+1 points");
				var r = t.slice(0, o + 1),
					a = l.apply(void 0, r);
				if (0 === a) throw new Error("Input not in general position");
				for (var u = new Array(o + 1), p = 0; o >= p; ++p) u[p] = p;
				0 > a && (u[0] = 1, u[1] = 0);
				for (var h = new n(u, new Array(o + 1), (!1)), c = h.adjacent, g = new Array(o + 2), p = 0; o >= p; ++p) {
					for (var d = u.slice(), f = 0; o >= f; ++f) f === p && (d[f] = -1);
					var m = d[0];
					d[0] = d[1], d[1] = m;
					var y = new n(d, new Array(o + 1), (!0));
					c[p] = y, g[p] = y
				}
				g[o + 1] = h;
				for (var p = 0; o >= p; ++p) for (var d = c[p].vertices, v = c[p].adjacent, f = 0; o >= f; ++f) {
					var x = d[f];
					if (0 > x) v[f] = h;
					else for (var j = 0; o >= j; ++j) c[j].vertices.indexOf(x) < 0 && (v[f] = c[j])
				}
				for (var E = new s(o, r, g), I = !! e, p = o + 1; i > p; ++p) E.insert(t[p], I);
				return E.boundary()
			}
			e.exports = a;
			var l = t("robust-orientation"),
				u = t("simplicial-complex").compareCells;
			n.prototype.flip = function() {
				var t = this.vertices[0];
				this.vertices[0] = this.vertices[1], this.vertices[1] = t;
				var e = this.adjacent[0];
				this.adjacent[0] = this.adjacent[1], this.adjacent[1] = e
			};
			var p = [],
				h = s.prototype;
			h.handleBoundaryDegeneracy = function(t, e) {
				var n = this.dimension,
					i = this.vertices.length - 1,
					o = this.tuple,
					r = this.vertices,
					s = [t];
				for (t.lastVisited = -i; s.length > 0;) {
					t = s.pop();
					for (var a = (t.vertices, t.adjacent), l = 0; n >= l; ++l) {
						var u = a[l];
						if (u.boundary && !(u.lastVisited <= -i)) {
							for (var p = u.vertices, h = 0; n >= h; ++h) {
								var c = p[h];
								o[h] = 0 > c ? e : r[c]
							}
							var g = this.orient();
							if (g > 0) return u;
							u.lastVisited = -i, 0 === g && s.push(u)
						}
					}
				}
				return null
			}, h.walk = function(t, e) {
				var n = this.vertices.length - 1,
					i = this.dimension,
					o = this.vertices,
					r = this.tuple,
					s = e ? this.interior.length * Math.random() | 0 : this.interior.length - 1,
					a = this.interior[s];
				t: for (; !a.boundary;) {
					for (var l = a.vertices, u = a.adjacent, p = 0; i >= p; ++p) r[p] = o[l[p]];
					a.lastVisited = n;
					for (var p = 0; i >= p; ++p) {
						var h = u[p];
						if (!(h.lastVisited >= n)) {
							var c = r[p];
							r[p] = t;
							var g = this.orient();
							if (r[p] = c, 0 > g) {
								a = h;
								continue t
							}
							h.lastVisited = h.boundary ? -n : n
						}
					}
					return
				}
				return a
			}, h.addPeaks = function(t, e) {
				var r = this.vertices.length - 1,
					s = this.dimension,
					a = this.vertices,
					l = this.tuple,
					u = this.interior,
					p = this.simplices,
					h = [e];
				e.lastVisited = r, e.vertices[e.vertices.indexOf(-1)] = r, e.boundary = !1, u.push(e);
				for (var c = []; h.length > 0;) {
					var e = h.pop(),
						g = e.vertices,
						d = e.adjacent,
						f = g.indexOf(r);
					if (!(0 > f)) for (var m = 0; s >= m; ++m) if (m !== f) {
						var y = d[m];
						if (y.boundary && !(y.lastVisited >= r)) {
							var v = y.vertices;
							if (y.lastVisited !== -r) {
								for (var x = 0, j = 0; s >= j; ++j) v[j] < 0 ? (x = j, l[j] = t) : l[j] = a[v[j]];
								var E = this.orient();
								if (E > 0) {
									v[x] = r, y.boundary = !1, u.push(y), h.push(y), y.lastVisited = r;
									continue
								}
								y.lastVisited = -r
							}
							var I = y.adjacent,
								C = g.slice(),
								S = d.slice(),
								b = new n(C, S, (!0));
							p.push(b);
							var L = I.indexOf(e);
							if (!(0 > L)) {
								I[L] = b, S[f] = y, C[m] = -1, S[m] = e, d[m] = b, b.flip();
								for (var j = 0; s >= j; ++j) {
									var w = C[j];
									if (!(0 > w || w === r)) {
										for (var P = new Array(s - 1), M = 0, _ = 0; s >= _; ++_) {
											var N = C[_];
											0 > N || _ === j || (P[M++] = N)
										}
										c.push(new i(P, b, j))
									}
								}
							}
						}
					}
				}
				c.sort(o);
				for (var m = 0; m + 1 < c.length; m += 2) {
					var A = c[m],
						T = c[m + 1],
						R = A.index,
						O = T.index;
					0 > R || 0 > O || (A.cell.adjacent[A.index] = T.cell, T.cell.adjacent[T.index] = A.cell)
				}
			}, h.insert = function(t, e) {
				var n = this.vertices;
				n.push(t);
				var i = this.walk(t, e);
				if (i) {
					for (var o = this.dimension, r = this.tuple, s = 0; o >= s; ++s) {
						var a = i.vertices[s];
						r[s] = 0 > a ? t : n[a]
					}
					var l = this.orient(r);
					0 > l || (0 !== l || (i = this.handleBoundaryDegeneracy(i, t))) && this.addPeaks(t, i)
				}
			}, h.boundary = function() {
				for (var t = this.dimension, e = [], n = this.simplices, i = n.length, o = 0; i > o; ++o) {
					var r = n[o];
					if (r.boundary) {
						for (var s = new Array(t), a = r.vertices, l = 0, u = 0, p = 0; t >= p; ++p) a[p] >= 0 ? s[l++] = a[p] : u = 1 & p;
						if (u === (1 & t)) {
							var h = s[0];
							s[0] = s[1], s[1] = h
						}
						e.push(s)
					}
				}
				return e
			}
		}, {
			"robust-orientation": 44,
			"simplicial-complex": 47
		}],
		39: [function(t, e, n) {
			arguments[4][32][0].apply(n, arguments)
		}, {
			dup: 32
		}],
		40: [function(t, e, n) {
			arguments[4][33][0].apply(n, arguments)
		}, {
			dup: 33,
			"two-product": 43,
			"two-sum": 39
		}],
		41: [function(t, e, n) {
			arguments[4][34][0].apply(n, arguments)
		}, {
			dup: 34
		}],
		42: [function(t, e, n) {
			arguments[4][35][0].apply(n, arguments)
		}, {
			dup: 35
		}],
		43: [function(t, e, n) {
			arguments[4][36][0].apply(n, arguments)
		}, {
			dup: 36
		}],
		44: [function(t, e, n) {
			arguments[4][37][0].apply(n, arguments)
		}, {
			dup: 37,
			"robust-scale": 40,
			"robust-subtract": 41,
			"robust-sum": 42,
			"two-product": 43
		}],
		45: [function(t, e, n) {
			"use strict";
			"use restrict";

			function i(t) {
				var e = 32;
				return t &= -t, t && e--, 65535 & t && (e -= 16), 16711935 & t && (e -= 8), 252645135 & t && (e -= 4), 858993459 & t && (e -= 2), 1431655765 & t && (e -= 1), e
			}
			var o = 32;
			n.INT_BITS = o, n.INT_MAX = 2147483647, n.INT_MIN = -1 << o - 1, n.sign = function(t) {
				return (t > 0) - (0 > t)
			}, n.abs = function(t) {
				var e = t >> o - 1;
				return (t ^ e) - e
			}, n.min = function(t, e) {
				return e ^ (t ^ e) & -(e > t)
			}, n.max = function(t, e) {
				return t ^ (t ^ e) & -(e > t)
			}, n.isPow2 = function(t) {
				return !(t & t - 1 || !t)
			}, n.log2 = function(t) {
				var e, n;
				return e = (t > 65535) << 4, t >>>= e, n = (t > 255) << 3, t >>>= n, e |= n, n = (t > 15) << 2, t >>>= n, e |= n, n = (t > 3) << 1, t >>>= n, e |= n, e | t >> 1
			}, n.log10 = function(t) {
				return t >= 1e9 ? 9 : t >= 1e8 ? 8 : t >= 1e7 ? 7 : t >= 1e6 ? 6 : t >= 1e5 ? 5 : t >= 1e4 ? 4 : t >= 1e3 ? 3 : t >= 100 ? 2 : t >= 10 ? 1 : 0
			}, n.popCount = function(t) {
				return t -= t >>> 1 & 1431655765, t = (858993459 & t) + (t >>> 2 & 858993459), 16843009 * (t + (t >>> 4) & 252645135) >>> 24
			}, n.countTrailingZeros = i, n.nextPow2 = function(t) {
				return t += 0 === t, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t + 1
			}, n.prevPow2 = function(t) {
				return t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t - (t >>> 1)
			}, n.parity = function(t) {
				return t ^= t >>> 16, t ^= t >>> 8, t ^= t >>> 4, t &= 15, 27030 >>> t & 1
			};
			var r = new Array(256);
			!
			function(t) {
				for (var e = 0; 256 > e; ++e) {
					var n = e,
						i = e,
						o = 7;
					for (n >>>= 1; n; n >>>= 1) i <<= 1, i |= 1 & n, --o;
					t[e] = i << o & 255
				}
			}(r), n.reverse = function(t) {
				return r[255 & t] << 24 | r[t >>> 8 & 255] << 16 | r[t >>> 16 & 255] << 8 | r[t >>> 24 & 255]
			}, n.interleave2 = function(t, e) {
				return t &= 65535, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e &= 65535, e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1
			}, n.deinterleave2 = function(t, e) {
				return t = t >>> e & 1431655765, t = 858993459 & (t | t >>> 1), t = 252645135 & (t | t >>> 2), t = 16711935 & (t | t >>> 4), t = 65535 & (t | t >>> 16), t << 16 >> 16
			}, n.interleave3 = function(t, e, n) {
				return t &= 1023, t = 4278190335 & (t | t << 16), t = 251719695 & (t | t << 8), t = 3272356035 & (t | t << 4), t = 1227133513 & (t | t << 2), e &= 1023, e = 4278190335 & (e | e << 16), e = 251719695 & (e | e << 8), e = 3272356035 & (e | e << 4), e = 1227133513 & (e | e << 2), t |= e << 1, n &= 1023, n = 4278190335 & (n | n << 16), n = 251719695 & (n | n << 8), n = 3272356035 & (n | n << 4), n = 1227133513 & (n | n << 2), t | n << 2
			}, n.deinterleave3 = function(t, e) {
				return t = t >>> e & 1227133513, t = 3272356035 & (t | t >>> 2), t = 251719695 & (t | t >>> 4), t = 4278190335 & (t | t >>> 8), t = 1023 & (t | t >>> 16), t << 22 >> 22
			}, n.nextCombination = function(t) {
				var e = t | t - 1;
				return e + 1 | (~e & -~e) - 1 >>> i(t) + 1
			}
		}, {}],
		46: [function(t, e) {
			"use strict";
			"use restrict";

			function n(t) {
				this.roots = new Array(t), this.ranks = new Array(t);
				for (var e = 0; t > e; ++e) this.roots[e] = e, this.ranks[e] = 0
			}
			e.exports = n;
			var i = n.prototype;
			Object.defineProperty(i, "length", {
				get: function() {
					return this.roots.length
				}
			}), i.makeSet = function() {
				var t = this.roots.length;
				return this.roots.push(t), this.ranks.push(0), t
			}, i.find = function(t) {
				for (var e = this.roots; e[t] !== t;) {
					var n = e[t];
					e[t] = e[n], t = n
				}
				return t
			}, i.link = function(t, e) {
				var n = this.find(t),
					i = this.find(e);
				if (n !== i) {
					var o = this.ranks,
						r = this.roots,
						s = o[n],
						a = o[i];
					a > s ? r[n] = i : s > a ? r[i] = n : (r[i] = n, ++o[n])
				}
			}
		}, {}],
		47: [function(t, e, n) {
			"use strict";
			"use restrict";

			function i(t) {
				for (var e = 0, n = Math.max, i = 0, o = t.length; o > i; ++i) e = n(e, t[i].length);
				return e - 1
			}
			function o(t) {
				for (var e = -1, n = Math.max, i = 0, o = t.length; o > i; ++i) for (var r = t[i], s = 0, a = r.length; a > s; ++s) e = n(e, r[s]);
				return e + 1
			}
			function r(t) {
				for (var e = new Array(t.length), n = 0, i = t.length; i > n; ++n) e[n] = t[n].slice(0);
				return e
			}
			function s(t, e) {
				var n = t.length,
					i = t.length - e.length,
					o = Math.min;
				if (i) return i;
				switch (n) {
				case 0:
					return 0;
				case 1:
					return t[0] - e[0];
				case 2:
					var r = t[0] + t[1] - e[0] - e[1];
					return r ? r : o(t[0], t[1]) - o(e[0], e[1]);
				case 3:
					var s = t[0] + t[1],
						a = e[0] + e[1];
					if (r = s + t[2] - (a + e[2])) return r;
					var l = o(t[0], t[1]),
						u = o(e[0], e[1]),
						r = o(l, t[2]) - o(u, e[2]);
					return r ? r : o(l + t[2], s) - o(u + e[2], a);
				default:
					var p = t.slice(0);
					p.sort();
					var h = e.slice(0);
					h.sort();
					for (var c = 0; n > c; ++c) if (i = p[c] - h[c]) return i;
					return 0
				}
			}
			function a(t, e) {
				return s(t[0], e[0])
			}
			function l(t, e) {
				if (e) {
					for (var n = t.length, i = new Array(n), o = 0; n > o; ++o) i[o] = [t[o], e[o]];
					i.sort(a);
					for (var o = 0; n > o; ++o) t[o] = i[o][0], e[o] = i[o][1];
					return t
				}
				return t.sort(s), t
			}
			function u(t) {
				if (0 === t.length) return [];
				for (var e = 1, n = t.length, i = 1; n > i; ++i) {
					var o = t[i];
					if (s(o, t[i - 1])) {
						if (i === e) {
							e++;
							continue
						}
						t[e++] = o
					}
				}
				return t.length = e, t
			}
			function p(t, e) {
				for (var n = 0, i = t.length - 1, o = -1; i >= n;) {
					var r = n + i >> 1,
						a = s(t[r], e);
					0 >= a ? (0 === a && (o = r), n = r + 1) : a > 0 && (i = r - 1)
				}
				return o
			}
			function h(t, e) {
				for (var n = new Array(t.length), i = 0, o = n.length; o > i; ++i) n[i] = [];
				for (var r = [], i = 0, a = e.length; a > i; ++i) for (var l = e[i], u = l.length, h = 1, c = 1 << u; c > h; ++h) {
					r.length = x.popCount(h);
					for (var g = 0, d = 0; u > d; ++d) h & 1 << d && (r[g++] = l[d]);
					var f = p(t, r);
					if (!(0 > f)) for (; n[f++].push(i), !(f >= t.length || 0 !== s(t[f], r)););
				}
				return n
			}
			function c(t, e) {
				if (!e) return h(u(d(t, 0)), t, 0);
				for (var n = new Array(e), i = 0; e > i; ++i) n[i] = [];
				for (var i = 0, o = t.length; o > i; ++i) for (var r = t[i], s = 0, a = r.length; a > s; ++s) n[r[s]].push(i);
				return n
			}
			function g(t) {
				for (var e = [], n = 0, i = t.length; i > n; ++n) for (var o = t[n], r = 0 | o.length, s = 1, a = 1 << r; a > s; ++s) {
					for (var u = [], p = 0; r > p; ++p) s >>> p & 1 && u.push(o[p]);
					e.push(u)
				}
				return l(e)
			}
			function d(t, e) {
				if (0 > e) return [];
				for (var n = [], i = (1 << e + 1) - 1, o = 0; o < t.length; ++o) for (var r = t[o], s = i; s < 1 << r.length; s = x.nextCombination(s)) {
					for (var a = new Array(e + 1), u = 0, p = 0; p < r.length; ++p) s & 1 << p && (a[u++] = r[p]);
					n.push(a)
				}
				return l(n)
			}
			function f(t) {
				for (var e = [], n = 0, i = t.length; i > n; ++n) for (var o = t[n], r = 0, s = o.length; s > r; ++r) {
					for (var a = new Array(o.length - 1), u = 0, p = 0; s > u; ++u) u !== r && (a[p++] = o[u]);
					e.push(a)
				}
				return l(e)
			}
			function m(t, e) {
				for (var n = new j(e), i = 0; i < t.length; ++i) for (var o = t[i], r = 0; r < o.length; ++r) for (var s = r + 1; s < o.length; ++s) n.link(o[r], o[s]);
				for (var a = [], l = n.ranks, i = 0; i < l.length; ++i) l[i] = -1;
				for (var i = 0; i < t.length; ++i) {
					var u = n.find(t[i][0]);
					l[u] < 0 ? (l[u] = a.length, a.push([t[i].slice(0)])) : a[l[u]].push(t[i].slice(0))
				}
				return a
			}
			function y(t) {
				for (var e = u(l(d(t, 0))), n = new j(e.length), i = 0; i < t.length; ++i) for (var o = t[i], r = 0; r < o.length; ++r) for (var s = p(e, [o[r]]), a = r + 1; a < o.length; ++a) n.link(s, p(e, [o[a]]));
				for (var h = [], c = n.ranks, i = 0; i < c.length; ++i) c[i] = -1;
				for (var i = 0; i < t.length; ++i) {
					var g = n.find(p(e, [t[i][0]]));
					c[g] < 0 ? (c[g] = h.length, h.push([t[i].slice(0)])) : h[c[g]].push(t[i].slice(0))
				}
				return h
			}
			function v(t, e) {
				return e ? m(t, e) : y(t)
			}
			var x = t("bit-twiddle"),
				j = t("union-find");
			n.dimension = i, n.countVertices = o, n.cloneCells = r, n.compareCells = s, n.normalize = l, n.unique = u, n.findCell = p, n.incidence = h, n.dual = c, n.explode = g, n.skeleton = d, n.boundary = f, n.connectedComponents = v
		}, {
			"bit-twiddle": 45,
			"union-find": 46
		}],
		48: [function(t, e) {
			"use strict";

			function n(t) {
				var e = t.length;
				if (3 > e) {
					for (var n = new Array(e), o = 0; e > o; ++o) n[o] = o;
					return 2 === e && t[0][0] === t[1][0] && t[0][1] === t[1][1] ? [0] : n
				}
				for (var r = new Array(e), o = 0; e > o; ++o) r[o] = o;
				r.sort(function(e, n) {
					var i = t[e][0] - t[n][0];
					return i ? i : t[e][1] - t[n][1]
				});
				for (var s = [r[0], r[1]], a = [r[0], r[1]], o = 2; e > o; ++o) {
					for (var l = r[o], u = t[l], p = s.length; p > 1 && i(t[s[p - 2]], t[s[p - 1]], u) <= 0;) p -= 1, s.pop();
					for (s.push(l), p = a.length; p > 1 && i(t[a[p - 2]], t[a[p - 1]], u) >= 0;) p -= 1, a.pop();
					a.push(l)
				}
				for (var n = new Array(a.length + s.length - 2), h = 0, o = 0, c = s.length; c > o; ++o) n[h++] = s[o];
				for (var g = a.length - 2; g > 0; --g) n[h++] = a[g];
				return n
			}
			e.exports = n;
			var i = t("robust-orientation")[3]
		}, {
			"robust-orientation": 54
		}],
		49: [function(t, e, n) {
			arguments[4][32][0].apply(n, arguments)
		}, {
			dup: 32
		}],
		50: [function(t, e, n) {
			arguments[4][33][0].apply(n, arguments)
		}, {
			dup: 33,
			"two-product": 53,
			"two-sum": 49
		}],
		51: [function(t, e, n) {
			arguments[4][34][0].apply(n, arguments)
		}, {
			dup: 34
		}],
		52: [function(t, e, n) {
			arguments[4][35][0].apply(n, arguments)
		}, {
			dup: 35
		}],
		53: [function(t, e, n) {
			arguments[4][36][0].apply(n, arguments)
		}, {
			dup: 36
		}],
		54: [function(t, e, n) {
			arguments[4][37][0].apply(n, arguments)
		}, {
			dup: 37,
			"robust-scale": 50,
			"robust-subtract": 51,
			"robust-sum": 52,
			"two-product": 53
		}],
		55: [function(t, e, n) {
			arguments[4][23][0].apply(n, arguments)
		}, {
			dup: 23
		}],
		56: [function(t, e) {
			var n = t("turf-inside");
			e.exports = function(t, e, i) {
				for (var o = 0; o < t.features.length; o++) {
					var r = t.features[o];
					r.properties || (r.properties = {});
					for (var s = 0, a = 0; a < e.features.length; a++) {
						var l = e.features[a];
						n(l, r) && s++
					}
					r.properties[i] = s
				}
				return t
			}
		}, {
			"turf-inside": 76
		}],
		57: [function(t, e) {
			function n(t) {
				return t * Math.PI / 180
			}
			function i(t) {
				return 180 * t / Math.PI
			}
			var o = t("turf-point");
			e.exports = function(t, e, r, s) {
				var a = t.geometry.coordinates,
					l = n(a[0]),
					u = n(a[1]),
					p = n(r),
					h = 0;
				switch (s) {
				case "miles":
					h = 3960;
					break;
				case "kilometers":
					h = 6373;
					break;
				case "degrees":
					h = 57.2957795;
					break;
				case "radians":
					h = 1
				}
				var c = Math.asin(Math.sin(u) * Math.cos(e / h) + Math.cos(u) * Math.sin(e / h) * Math.cos(p)),
					g = l + Math.atan2(Math.sin(p) * Math.sin(e / h) * Math.cos(u), Math.cos(e / h) - Math.sin(u) * Math.sin(c));
				return o([i(g), i(c)])
			}
		}, {
			"turf-point": 102
		}],
		58: [function(t, e) {
			var n = t("simple-statistics"),
				i = t("turf-inside");
			e.exports = function(t, e, o, r) {
				return t.features.forEach(function(t) {
					t.properties || (t.properties = {});
					var s = [];
					e.features.forEach(function(e) {
						i(e, t) && s.push(e.properties[o])
					}), t.properties[r] = n.standard_deviation(s)
				}), t
			}
		}, {
			"simple-statistics": 59,
			"turf-inside": 76
		}],
		59: [function(t, e) {
			!
			function() {
				function t() {
					var t = {},
						e = [];
					return t.data = function(n) {
						return arguments.length ? (e = n.slice(), t) : e
					}, t.mb = function() {
						var t, n, i = e.length;
						if (1 === i) t = 0, n = e[0][1];
						else {
							for (var o, r, s, a = 0, l = 0, u = 0, p = 0, h = 0; i > h; h++) o = e[h], r = o[0], s = o[1], a += r, l += s, u += r * r, p += r * s;
							t = (i * p - a * l) / (i * u - a * a), n = l / i - t * a / i
						}
						return {
							m: t,
							b: n
						}
					}, t.m = function() {
						return t.mb().m
					}, t.b = function() {
						return t.mb().b
					}, t.line = function() {
						var e = t.mb(),
							n = e.m,
							i = e.b;
						return function(t) {
							return i + n * t
						}
					}, t
				}
				function n(t, e) {
					if (t.length < 2) return 1;
					for (var n, i = 0, o = 0; o < t.length; o++) i += t[o][1];
					n = i / t.length;
					for (var r = 0, s = 0; s < t.length; s++) r += Math.pow(n - t[s][1], 2);
					for (var a = 0, l = 0; l < t.length; l++) a += Math.pow(t[l][1] - e(t[l][0]), 2);
					return 1 - a / r
				}
				function i() {
					var t = {},
						e = 0,
						n = {};
					return t.train = function(t, i) {
						n[i] || (n[i] = {});
						for (var o in t) {
							var r = t[o];
							void 0 === n[i][o] && (n[i][o] = {}), void 0 === n[i][o][r] && (n[i][o][r] = 0), n[i][o][t[o]]++
						}
						e++
					}, t.score = function(t) {
						var i, o = {};
						for (var r in t) {
							var s = t[r];
							for (i in n) void 0 === o[i] && (o[i] = {}), o[i][r + "_" + s] = n[i][r] ? (n[i][r][s] || 0) / e : 0
						}
						var a = {};
						for (i in o) for (var l in o[i]) void 0 === a[i] && (a[i] = 0), a[i] += o[i][l];
						return a
					}, t
				}
				function o(t) {
					for (var e = 0, n = 0; n < t.length; n++) e += t[n];
					return e
				}
				function r(t) {
					return 0 === t.length ? null : o(t) / t.length
				}
				function s(t) {
					if (0 === t.length) return null;
					for (var e = 1, n = 0; n < t.length; n++) {
						if (t[n] <= 0) return null;
						e *= t[n]
					}
					return Math.pow(e, 1 / t.length)
				}
				function a(t) {
					if (0 === t.length) return null;
					for (var e = 0, n = 0; n < t.length; n++) {
						if (t[n] <= 0) return null;
						e += 1 / t[n]
					}
					return t.length / e
				}
				function l(t) {
					for (var e, n = 0; n < t.length; n++)(t[n] < e || void 0 === e) && (e = t[n]);
					return e
				}
				function u(t) {
					for (var e, n = 0; n < t.length; n++)(t[n] > e || void 0 === e) && (e = t[n]);
					return e
				}
				function p(t) {
					if (0 === t.length) return null;
					for (var e = r(t), n = [], i = 0; i < t.length; i++) n.push(Math.pow(t[i] - e, 2));
					return r(n)
				}
				function h(t) {
					return 0 === t.length ? null : Math.sqrt(p(t))
				}
				function c(t, e) {
					for (var n = r(t), i = 0, o = 0; o < t.length; o++) i += Math.pow(t[o] - n, e);
					return i
				}
				function g(t) {
					if (t.length <= 1) return null;
					var e = c(t, 2);
					return e / (t.length - 1)
				}
				function d(t) {
					return t.length <= 1 ? null : Math.sqrt(g(t))
				}
				function f(t, e) {
					if (t.length <= 1 || t.length != e.length) return null;
					for (var n = r(t), i = r(e), o = 0, s = 0; s < t.length; s++) o += (t[s] - n) * (e[s] - i);
					return o / (t.length - 1)
				}
				function m(t, e) {
					var n = f(t, e),
						i = d(t),
						o = d(e);
					return null === n || null === i || null === o ? null : n / i / o
				}
				function y(t) {
					if (0 === t.length) return null;
					var e = t.slice().sort(function(t, e) {
						return t - e
					});
					if (e.length % 2 === 1) return e[(e.length - 1) / 2];
					var n = e[e.length / 2 - 1],
						i = e[e.length / 2];
					return (n + i) / 2
				}
				function v(t) {
					if (0 === t.length) return null;
					if (1 === t.length) return t[0];
					for (var e, n = t.slice().sort(function(t, e) {
						return t - e
					}), i = n[0], o = 0, r = 1, s = 1; s < n.length + 1; s++) n[s] !== i ? (r > o && (o = r, e = i), r = 1, i = n[s]) : r++;
					return e
				}
				function x(t, e) {
					var n = r(t),
						i = h(t),
						o = Math.sqrt(t.length);
					return (n - e) / (i / o)
				}
				function j(t, e, n) {
					var i = t.length,
						o = e.length;
					if (!i || !o) return null;
					n || (n = 0);
					var s = r(t),
						a = r(e),
						l = ((i - 1) * g(t) + (o - 1) * g(e)) / (i + o - 2);
					return (s - a - n) / Math.sqrt(l * (1 / i + 1 / o))
				}
				function E(t, e) {
					var n = [];
					if (0 >= e) return null;
					for (var i = 0; i < t.length; i += e) n.push(t.slice(i, i + e));
					return n
				}
				function I(t, e) {
					e = e || Math.random;
					for (var n, i, o = t.length; o > 0;) i = Math.floor(e() * o--), n = t[o], t[o] = t[i], t[i] = n;
					return t
				}
				function C(t, e) {
					return t = t.slice(), I(t.slice(), e)
				}
				function S(t, e, n) {
					var i = C(t, n);
					return i.slice(0, e)
				}
				function b(t, e) {
					if (0 === t.length) return null;
					var n = t.slice().sort(function(t, e) {
						return t - e
					});
					if (e.length) {
						for (var i = [], o = 0; o < e.length; o++) i[o] = L(n, e[o]);
						return i
					}
					return L(n, e)
				}
				function L(t, e) {
					var n = t.length * e;
					return 0 > e || e > 1 ? null : 1 === e ? t[t.length - 1] : 0 === e ? t[0] : n % 1 !== 0 ? t[Math.ceil(n) - 1] : t.length % 2 === 0 ? (t[n - 1] + t[n]) / 2 : t[n]
				}
				function w(t) {
					return 0 === t.length ? null : b(t, .75) - b(t, .25)
				}
				function P(t) {
					if (!t || 0 === t.length) return null;
					for (var e = y(t), n = [], i = 0; i < t.length; i++) n.push(Math.abs(t[i] - e));
					return y(n)
				}
				function M(t, e) {
					var n, i, o = [],
						r = [],
						s = 0;
					for (n = 0; n < t.length + 1; n++) {
						var a = [],
							l = [];
						for (i = 0; e + 1 > i; i++) a.push(0), l.push(0);
						o.push(a), r.push(l)
					}
					for (n = 1; e + 1 > n; n++) for (o[1][n] = 1, r[1][n] = 0, i = 2; i < t.length + 1; i++) r[i][n] = 1 / 0;
					for (var u = 2; u < t.length + 1; u++) {
						for (var p = 0, h = 0, c = 0, g = 0, d = 1; u + 1 > d; d++) {
							var f = u - d + 1,
								m = t[f - 1];
							if (c++, p += m, h += m * m, s = h - p * p / c, g = f - 1, 0 !== g) for (i = 2; e + 1 > i; i++) r[u][i] >= s + r[g][i - 1] && (o[u][i] = f, r[u][i] = s + r[g][i - 1])
						}
						o[u][1] = 1, r[u][1] = s
					}
					return {
						lower_class_limits: o,
						variance_combinations: r
					}
				}
				function _(t, e, n) {
					var i = t.length - 1,
						o = [],
						r = n;
					for (o[n] = t[t.length - 1], o[0] = t[0]; r > 1;) o[r - 1] = t[e[i][r] - 2], i = e[i][r] - 1, r--;
					return o
				}
				function N(t, e) {
					if (e > t.length) return null;
					t = t.slice().sort(function(t, e) {
						return t - e
					});
					var n = M(t, e),
						i = n.lower_class_limits;
					return _(t, i, e)
				}
				function A(t) {
					if (t.length < 3) return null;
					var e = t.length,
						n = Math.pow(d(t), 3),
						i = c(t, 3);
					return e * i / ((e - 1) * (e - 2) * n)
				}
				function T(t) {
					var e = Math.abs(t),
						n = Math.floor(10 * e),
						i = 10 * (Math.floor(100 * e) / 10 - Math.floor(100 * e / 10)),
						o = Math.min(10 * n + i, V.length - 1);
					return t >= 0 ? V[o] : +(1 - V[o]).toFixed(4)
				}
				function R(t, e, n) {
					return (t - e) / n
				}
				function O(t) {
					if (0 > t) return null;
					for (var e = 1, n = 2; t >= n; n++) e *= n;
					return e
				}
				function D(t) {
					return 0 > t || t > 1 ? null : B(1, t)
				}
				function B(t, e) {
					function n(t, e, n) {
						return O(e) / (O(t) * O(e - t)) * Math.pow(n, t) * Math.pow(1 - n, e - t)
					}
					if (0 > e || e > 1 || 0 >= t || t % 1 !== 0) return null;
					var i = 0,
						o = 0,
						r = {};
					do r[i] = n(i, t, e), o += r[i], i++;
					while (1 - z > o);
					return r
				}
				function G(t) {
					function e(t, e) {
						return Math.pow(Math.E, -e) * Math.pow(e, t) / O(t)
					}
					if (0 >= t) return null;
					var n = 0,
						i = 0,
						o = {};
					do o[n] = e(n, t), i += o[n], n++;
					while (1 - z > i);
					return o
				}
				function F(t, e, n) {
					for (var i, o, s = r(t), a = 0, l = 1, u = e(s), p = [], h = [], c = 0; c < t.length; c++) void 0 === p[t[c]] && (p[t[c]] = 0), p[t[c]]++;
					for (c = 0; c < p.length; c++) void 0 === p[c] && (p[c] = 0);
					for (o in u) o in p && (h[o] = u[o] * t.length);
					for (o = h.length - 1; o >= 0; o--) h[o] < 3 && (h[o - 1] += h[o], h.pop(), p[o - 1] += p[o], p.pop());
					for (o = 0; o < p.length; o++) a += Math.pow(p[o] - h[o], 2) / h[o];
					return i = p.length - l - 1, H[i][n] < a
				}
				function k(t) {
					function e(t) {
						return function() {
							var e = Array.prototype.slice.apply(arguments);
							return e.unshift(this), q[t].apply(q, e)
						}
					}
					var n = !(!Object.defineProperty || !Object.defineProperties);
					if (!n) throw new Error("without defineProperty, simple-statistics cannot be mixed in");
					var i, o = ["median", "standard_deviation", "sum", "sample_skewness", "mean", "min", "max", "quantile", "geometric_mean", "harmonic_mean"];
					i = t ? t.slice() : Array.prototype;
					for (var r = 0; r < o.length; r++) Object.defineProperty(i, o[r], {
						value: e(o[r]),
						configurable: !0,
						enumerable: !1,
						writable: !0
					});
					return i
				}
				var q = {};
				"undefined" != typeof e ? e.exports = q : this.ss = q;
				var V = [.5, .504, .508, .512, .516, .5199, .5239, .5279, .5319, .5359, .5398, .5438, .5478, .5517, .5557, .5596, .5636, .5675, .5714, .5753, .5793, .5832, .5871, .591, .5948, .5987, .6026, .6064, .6103, .6141, .6179, .6217, .6255, .6293, .6331, .6368, .6406, .6443, .648, .6517, .6554, .6591, .6628, .6664, .67, .6736, .6772, .6808, .6844, .6879, .6915, .695, .6985, .7019, .7054, .7088, .7123, .7157, .719, .7224, .7257, .7291, .7324, .7357, .7389, .7422, .7454, .7486, .7517, .7549, .758, .7611, .7642, .7673, .7704, .7734, .7764, .7794, .7823, .7852, .7881, .791, .7939, .7967, .7995, .8023, .8051, .8078, .8106, .8133, .8159, .8186, .8212, .8238, .8264, .8289, .8315, .834, .8365, .8389, .8413, .8438, .8461, .8485, .8508, .8531, .8554, .8577, .8599, .8621, .8643, .8665, .8686, .8708, .8729, .8749, .877, .879, .881, .883, .8849, .8869, .8888, .8907, .8925, .8944, .8962, .898, .8997, .9015, .9032, .9049, .9066, .9082, .9099, .9115, .9131, .9147, .9162, .9177, .9192, .9207, .9222, .9236, .9251, .9265, .9279, .9292, .9306, .9319, .9332, .9345, .9357, .937, .9382, .9394, .9406, .9418, .9429, .9441, .9452, .9463, .9474, .9484, .9495, .9505, .9515, .9525, .9535, .9545, .9554, .9564, .9573, .9582, .9591, .9599, .9608, .9616, .9625, .9633, .9641, .9649, .9656, .9664, .9671, .9678, .9686, .9693, .9699, .9706, .9713, .9719, .9726, .9732, .9738, .9744, .975, .9756, .9761, .9767, .9772, .9778, .9783, .9788, .9793, .9798, .9803, .9808, .9812, .9817, .9821, .9826, .983, .9834, .9838, .9842, .9846, .985, .9854, .9857, .9861, .9864, .9868, .9871, .9875, .9878, .9881, .9884, .9887, .989, .9893, .9896, .9898, .9901, .9904, .9906, .9909, .9911, .9913, .9916, .9918, .992, .9922, .9925, .9927, .9929, .9931, .9932, .9934, .9936, .9938, .994, .9941, .9943, .9945, .9946, .9948, .9949, .9951, .9952, .9953, .9955, .9956, .9957, .9959, .996, .9961, .9962, .9963, .9964, .9965, .9966, .9967, .9968, .9969, .997, .9971, .9972, .9973, .9974, .9974, .9975, .9976, .9977, .9977, .9978, .9979, .9979, .998, .9981, .9981, .9982, .9982, .9983, .9984, .9984, .9985, .9985, .9986, .9986, .9987, .9987, .9987, .9988, .9988, .9989, .9989, .9989, .999, .999],
					z = 1e-4,
					H = {
						1: {.995: 0,
							.99: 0,
							.975: 0,
							.95: 0,
							.9: .02,
							.5: .45,
							.1: 2.71,
							.05: 3.84,
							.025: 5.02,
							.01: 6.63,
							.005: 7.88
						},
						2: {.995: .01,
							.99: .02,
							.975: .05,
							.95: .1,
							.9: .21,
							.5: 1.39,
							.1: 4.61,
							.05: 5.99,
							.025: 7.38,
							.01: 9.21,
							.005: 10.6
						},
						3: {.995: .07,
							.99: .11,
							.975: .22,
							.95: .35,
							.9: .58,
							.5: 2.37,
							.1: 6.25,
							.05: 7.81,
							.025: 9.35,
							.01: 11.34,
							.005: 12.84
						},
						4: {.995: .21,
							.99: .3,
							.975: .48,
							.95: .71,
							.9: 1.06,
							.5: 3.36,
							.1: 7.78,
							.05: 9.49,
							.025: 11.14,
							.01: 13.28,
							.005: 14.86
						},
						5: {.995: .41,
							.99: .55,
							.975: .83,
							.95: 1.15,
							.9: 1.61,
							.5: 4.35,
							.1: 9.24,
							.05: 11.07,
							.025: 12.83,
							.01: 15.09,
							.005: 16.75
						},
						6: {.995: .68,
							.99: .87,
							.975: 1.24,
							.95: 1.64,
							.9: 2.2,
							.5: 5.35,
							.1: 10.65,
							.05: 12.59,
							.025: 14.45,
							.01: 16.81,
							.005: 18.55
						},
						7: {.995: .99,
							.99: 1.25,
							.975: 1.69,
							.95: 2.17,
							.9: 2.83,
							.5: 6.35,
							.1: 12.02,
							.05: 14.07,
							.025: 16.01,
							.01: 18.48,
							.005: 20.28
						},
						8: {.995: 1.34,
							.99: 1.65,
							.975: 2.18,
							.95: 2.73,
							.9: 3.49,
							.5: 7.34,
							.1: 13.36,
							.05: 15.51,
							.025: 17.53,
							.01: 20.09,
							.005: 21.96
						},
						9: {.995: 1.73,
							.99: 2.09,
							.975: 2.7,
							.95: 3.33,
							.9: 4.17,
							.5: 8.34,
							.1: 14.68,
							.05: 16.92,
							.025: 19.02,
							.01: 21.67,
							.005: 23.59
						},
						10: {.995: 2.16,
							.99: 2.56,
							.975: 3.25,
							.95: 3.94,
							.9: 4.87,
							.5: 9.34,
							.1: 15.99,
							.05: 18.31,
							.025: 20.48,
							.01: 23.21,
							.005: 25.19
						},
						11: {.995: 2.6,
							.99: 3.05,
							.975: 3.82,
							.95: 4.57,
							.9: 5.58,
							.5: 10.34,
							.1: 17.28,
							.05: 19.68,
							.025: 21.92,
							.01: 24.72,
							.005: 26.76
						},
						12: {.995: 3.07,
							.99: 3.57,
							.975: 4.4,
							.95: 5.23,
							.9: 6.3,
							.5: 11.34,
							.1: 18.55,
							.05: 21.03,
							.025: 23.34,
							.01: 26.22,
							.005: 28.3
						},
						13: {.995: 3.57,
							.99: 4.11,
							.975: 5.01,
							.95: 5.89,
							.9: 7.04,
							.5: 12.34,
							.1: 19.81,
							.05: 22.36,
							.025: 24.74,
							.01: 27.69,
							.005: 29.82
						},
						14: {.995: 4.07,
							.99: 4.66,
							.975: 5.63,
							.95: 6.57,
							.9: 7.79,
							.5: 13.34,
							.1: 21.06,
							.05: 23.68,
							.025: 26.12,
							.01: 29.14,
							.005: 31.32
						},
						15: {.995: 4.6,
							.99: 5.23,
							.975: 6.27,
							.95: 7.26,
							.9: 8.55,
							.5: 14.34,
							.1: 22.31,
							.05: 25,
							.025: 27.49,
							.01: 30.58,
							.005: 32.8
						},
						16: {.995: 5.14,
							.99: 5.81,
							.975: 6.91,
							.95: 7.96,
							.9: 9.31,
							.5: 15.34,
							.1: 23.54,
							.05: 26.3,
							.025: 28.85,
							.01: 32,
							.005: 34.27
						},
						17: {.995: 5.7,
							.99: 6.41,
							.975: 7.56,
							.95: 8.67,
							.9: 10.09,
							.5: 16.34,
							.1: 24.77,
							.05: 27.59,
							.025: 30.19,
							.01: 33.41,
							.005: 35.72
						},
						18: {.995: 6.26,
							.99: 7.01,
							.975: 8.23,
							.95: 9.39,
							.9: 10.87,
							.5: 17.34,
							.1: 25.99,
							.05: 28.87,
							.025: 31.53,
							.01: 34.81,
							.005: 37.16
						},
						19: {.995: 6.84,
							.99: 7.63,
							.975: 8.91,
							.95: 10.12,
							.9: 11.65,
							.5: 18.34,
							.1: 27.2,
							.05: 30.14,
							.025: 32.85,
							.01: 36.19,
							.005: 38.58
						},
						20: {.995: 7.43,
							.99: 8.26,
							.975: 9.59,
							.95: 10.85,
							.9: 12.44,
							.5: 19.34,
							.1: 28.41,
							.05: 31.41,
							.025: 34.17,
							.01: 37.57,
							.005: 40
						},
						21: {.995: 8.03,
							.99: 8.9,
							.975: 10.28,
							.95: 11.59,
							.9: 13.24,
							.5: 20.34,
							.1: 29.62,
							.05: 32.67,
							.025: 35.48,
							.01: 38.93,
							.005: 41.4
						},
						22: {.995: 8.64,
							.99: 9.54,
							.975: 10.98,
							.95: 12.34,
							.9: 14.04,
							.5: 21.34,
							.1: 30.81,
							.05: 33.92,
							.025: 36.78,
							.01: 40.29,
							.005: 42.8
						},
						23: {.995: 9.26,
							.99: 10.2,
							.975: 11.69,
							.95: 13.09,
							.9: 14.85,
							.5: 22.34,
							.1: 32.01,
							.05: 35.17,
							.025: 38.08,
							.01: 41.64,
							.005: 44.18
						},
						24: {.995: 9.89,
							.99: 10.86,
							.975: 12.4,
							.95: 13.85,
							.9: 15.66,
							.5: 23.34,
							.1: 33.2,
							.05: 36.42,
							.025: 39.36,
							.01: 42.98,
							.005: 45.56
						},
						25: {.995: 10.52,
							.99: 11.52,
							.975: 13.12,
							.95: 14.61,
							.9: 16.47,
							.5: 24.34,
							.1: 34.28,
							.05: 37.65,
							.025: 40.65,
							.01: 44.31,
							.005: 46.93
						},
						26: {.995: 11.16,
							.99: 12.2,
							.975: 13.84,
							.95: 15.38,
							.9: 17.29,
							.5: 25.34,
							.1: 35.56,
							.05: 38.89,
							.025: 41.92,
							.01: 45.64,
							.005: 48.29
						},
						27: {.995: 11.81,
							.99: 12.88,
							.975: 14.57,
							.95: 16.15,
							.9: 18.11,
							.5: 26.34,
							.1: 36.74,
							.05: 40.11,
							.025: 43.19,
							.01: 46.96,
							.005: 49.65
						},
						28: {.995: 12.46,
							.99: 13.57,
							.975: 15.31,
							.95: 16.93,
							.9: 18.94,
							.5: 27.34,
							.1: 37.92,
							.05: 41.34,
							.025: 44.46,
							.01: 48.28,
							.005: 50.99
						},
						29: {.995: 13.12,
							.99: 14.26,
							.975: 16.05,
							.95: 17.71,
							.9: 19.77,
							.5: 28.34,
							.1: 39.09,
							.05: 42.56,
							.025: 45.72,
							.01: 49.59,
							.005: 52.34
						},
						30: {.995: 13.79,
							.99: 14.95,
							.975: 16.79,
							.95: 18.49,
							.9: 20.6,
							.5: 29.34,
							.1: 40.26,
							.05: 43.77,
							.025: 46.98,
							.01: 50.89,
							.005: 53.67
						},
						40: {.995: 20.71,
							.99: 22.16,
							.975: 24.43,
							.95: 26.51,
							.9: 29.05,
							.5: 39.34,
							.1: 51.81,
							.05: 55.76,
							.025: 59.34,
							.01: 63.69,
							.005: 66.77
						},
						50: {.995: 27.99,
							.99: 29.71,
							.975: 32.36,
							.95: 34.76,
							.9: 37.69,
							.5: 49.33,
							.1: 63.17,
							.05: 67.5,
							.025: 71.42,
							.01: 76.15,
							.005: 79.49
						},
						60: {.995: 35.53,
							.99: 37.48,
							.975: 40.48,
							.95: 43.19,
							.9: 46.46,
							.5: 59.33,
							.1: 74.4,
							.05: 79.08,
							.025: 83.3,
							.01: 88.38,
							.005: 91.95
						},
						70: {.995: 43.28,
							.99: 45.44,
							.975: 48.76,
							.95: 51.74,
							.9: 55.33,
							.5: 69.33,
							.1: 85.53,
							.05: 90.53,
							.025: 95.02,
							.01: 100.42,
							.005: 104.22
						},
						80: {.995: 51.17,
							.99: 53.54,
							.975: 57.15,
							.95: 60.39,
							.9: 64.28,
							.5: 79.33,
							.1: 96.58,
							.05: 101.88,
							.025: 106.63,
							.01: 112.33,
							.005: 116.32
						},
						90: {.995: 59.2,
							.99: 61.75,
							.975: 65.65,
							.95: 69.13,
							.9: 73.29,
							.5: 89.33,
							.1: 107.57,
							.05: 113.14,
							.025: 118.14,
							.01: 124.12,
							.005: 128.3
						},
						100: {.995: 67.33,
							.99: 70.06,
							.975: 74.22,
							.95: 77.93,
							.9: 82.36,
							.5: 99.33,
							.1: 118.5,
							.05: 124.34,
							.025: 129.56,
							.01: 135.81,
							.005: 140.17
						}
					};
				q.linear_regression = t, q.standard_deviation = h, q.r_squared = n, q.median = y, q.mean = r, q.mode = v, q.min = l, q.max = u, q.sum = o, q.quantile = b, q.quantile_sorted = L, q.iqr = w, q.mad = P, q.chunk = E, q.shuffle = C, q.shuffle_in_place = I, q.sample = S, q.sample_covariance = f, q.sample_correlation = m, q.sample_variance = g, q.sample_standard_deviation = d, q.sample_skewness = A, q.geometric_mean = s, q.harmonic_mean = a, q.variance = p, q.t_test = x, q.t_test_two_sample = j, q.jenksMatrices = M, q.jenksBreaks = _, q.jenks = N, q.bayesian = i, q.epsilon = z, q.factorial = O, q.bernoulli_distribution = D, q.binomial_distribution = B, q.poisson_distribution = G, q.chi_squared_goodness_of_fit = F, q.z_score = R, q.cumulative_std_normal_probability = T, q.standard_normal_table = V, q.average = r, q.interquartile_range = w, q.mixin = k, q.median_absolute_deviation = P
			}(this)
		}, {}],
		60: [function(t, e) {
			function n(t) {
				return t * Math.PI / 180
			}
			var i = t("turf-invariant");
			e.exports = function(t, e, o) {
				i.featureOf(t, "Point", "distance"), i.featureOf(e, "Point", "distance");
				var r, s = t.geometry.coordinates,
					a = e.geometry.coordinates,
					l = n(a[1] - s[1]),
					u = n(a[0] - s[0]),
					p = n(s[1]),
					h = n(a[1]),
					c = Math.sin(l / 2) * Math.sin(l / 2) + Math.sin(u / 2) * Math.sin(u / 2) * Math.cos(p) * Math.cos(h),
					g = 2 * Math.atan2(Math.sqrt(c), Math.sqrt(1 - c));
				switch (o) {
				case "miles":
					r = 3960;
					break;
				case "kilometers":
					r = 6373;
					break;
				case "degrees":
					r = 57.2957795;
					break;
				case "radians":
					r = 1;
					break;
				case void 0:
					r = 6373;
					break;
				default:
					throw new Error('unknown option given to "units"')
				}
				var d = r * g;
				return d
			}
		}, {
			"turf-invariant": 61
		}],
		61: [function(t, e) {
			function n(t, e, n) {
				if (!e || !n) throw new Error("type and name required");
				if (!t || t.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type)
			}
			function i(t, e, n) {
				if (!n) throw new Error(".featureOf() requires a name");
				if (!t || "Feature" !== t.type || !t.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
				if (!t.geometry || t.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type)
			}
			function o(t, e, n) {
				if (!n) throw new Error(".collectionOf() requires a name");
				if (!t || "FeatureCollection" !== t.type) throw new Error("Invalid input to " + n + ", FeatureCollection required");
				for (var i = 0; i < t.features.length; i++) {
					var o = t.features[i];
					if (!o || "Feature" !== o.type || !o.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required");
					if (!o.geometry || o.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + o.geometry.type)
				}
			}
			e.exports.geojsonType = n, e.exports.collectionOf = o, e.exports.featureOf = i
		}, {}],
		62: [function(t, e) {
			var n = t("turf-extent"),
				i = t("turf-bbox-polygon");
			e.exports = function(t) {
				var e = n(t),
					o = i(e);
				return o
			}
		}, {
			"turf-bbox-polygon": 12,
			"turf-extent": 70
		}],
		63: [function(t, e) {
			var n = t("jsts");
			e.exports = function(t, e) {
				var i = JSON.parse(JSON.stringify(t)),
					o = JSON.parse(JSON.stringify(e));
				"Feature" !== i.type && (i = {
					type: "Feature",
					properties: {},
					geometry: i
				}), "Feature" !== o.type && (o = {
					type: "Feature",
					properties: {},
					geometry: o
				});
				var r = new n.io.GeoJSONReader,
					s = r.read(JSON.stringify(i.geometry)),
					a = r.read(JSON.stringify(o.geometry)),
					l = s.difference(a),
					u = new n.io.GeoJSONParser;
				return l = u.write(l), i.geometry = l, "GeometryCollection" === i.geometry.type && 0 === i.geometry.geometries.length ? void 0 : {
					type: "Feature",
					properties: i.properties,
					geometry: l
				}
			}
		}, {
			jsts: 64
		}],
		64: [function(t, e, n) {
			arguments[4][17][0].apply(n, arguments)
		}, {
			"./lib/jsts": 65,
			dup: 17,
			"javascript.util": 67
		}],
		65: [function(t, e, n) {
			arguments[4][18][0].apply(n, arguments)
		}, {
			dup: 18
		}],
		66: [function(t, e, n) {
			arguments[4][19][0].apply(n, arguments)
		}, {
			dup: 19
		}],
		67: [function(t, e, n) {
			arguments[4][20][0].apply(n, arguments)
		}, {
			"./dist/javascript.util-node.min.js": 66,
			dup: 20
		}],
		68: [function(t, e) {
			var n = t("turf-featurecollection"),
				i = t("turf-meta").coordEach,
				o = t("turf-point");
			e.exports = function(t) {
				var e = [];
				return i(t, function(t) {
					e.push(o(t))
				}), n(e)
			}
		}, {
			"turf-featurecollection": 72,
			"turf-meta": 69,
			"turf-point": 102
		}],
		69: [function(t, e, n) {
			arguments[4][23][0].apply(n, arguments)
		}, {
			dup: 23
		}],
		70: [function(t, e) {
			var n = t("turf-meta").coordEach;
			e.exports = function(t) {
				var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
				return n(t, function(t) {
					e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1])
				}), e
			}
		}, {
			"turf-meta": 71
		}],
		71: [function(t, e, n) {
			arguments[4][23][0].apply(n, arguments)
		}, {
			dup: 23
		}],
		72: [function(t, e) {
			e.exports = function(t) {
				return {
					type: "FeatureCollection",
					features: t
				}
			}
		}, {}],
		73: [function(t, e) {
			var n = t("turf-featurecollection");
			e.exports = function(t, e, i) {
				for (var o = n([]), r = 0; r < t.features.length; r++) t.features[r].properties[e] === i && o.features.push(t.features[r]);
				return o
			}
		}, {
			"turf-featurecollection": 72
		}],
		74: [function(t, e) {
			function n(t) {
				var e = JSON.parse(JSON.stringify(t));
				switch (e.type) {
				case "FeatureCollection":
					for (var n = 0; n < e.features.length; n++) i(e.features[n].geometry);
					return e;
				case "Feature":
					return i(e.geometry), e;
				default:
					return i(e), e
				}
			}
			function i(t) {
				var e = t.coordinates;
				switch (t.type) {
				case "Point":
					o(e);
					break;
				case "LineString":
				case "MultiPoint":
					r(e);
					break;
				case "Polygon":
				case "MultiLineString":
					s(e);
					break;
				case "MultiPolygon":
					a(e);
					break;
				case "GeometryCollection":
					t.geometries.forEach(i)
				}
			}
			function o(t) {
				t.reverse()
			}
			function r(t) {
				for (var e = 0; e < t.length; e++) t[e].reverse()
			}
			function s(t) {
				for (var e = 0; e < t.length; e++) for (var n = 0; n < t[e].length; n++) t[e][n].reverse()
			}
			function a(t) {
				for (var e = 0; e < t.length; e++) for (var n = 0; n < t[e].length; n++) for (var i = 0; i < t[e][n].length; i++) t[e][n][i].reverse()
			}
			e.exports = n
		}, {}],
		75: [function(t, e) {
			function n(t, e) {
				for (var n = [], i = 0; 6 > i; i++) {
					var r = t[0] + e * a[i],
						s = t[1] + e * l[i];
					n.push([r, s])
				}
				return n.push(n[0]), o([n])
			}
			for (var i = t("turf-point"), o = t("turf-polygon"), r = t("turf-distance"), s = t("turf-featurecollection"), a = [], l = [], u = 0; 6 > u; u++) {
				var p = 2 * Math.PI / 6 * u;
				a.push(Math.cos(p)), l.push(Math.sin(p))
			}
			e.exports = function(t, e, o) {
				var a = e / r(i([t[0], t[1]]), i([t[2], t[1]]), o),
					l = a * (t[2] - t[0]),
					u = e / r(i([t[0], t[1]]), i([t[0], t[3]]), o),
					p = (u * (t[3] - t[1]), l / 2),
					h = 2 * p,
					c = Math.sqrt(3) / 2 * h,
					g = t[2] - t[0],
					d = t[3] - t[1],
					f = .75 * h,
					m = c,
					y = g / (h - p / 2),
					v = Math.ceil(y);
				Math.round(y) === v && v++;
				var x = (v * f - p / 2 - g) / 2 - p / 2,
					j = Math.ceil(d / c),
					E = (d - j * c) / 2,
					I = j * c - d > c / 2;
				I && (E -= c / 4);
				for (var C = s([]), S = 0; v > S; S++) for (var b = 0; j >= b; b++) {
					var L = S % 2 === 1;
					if (!(0 === b && L || 0 === b && I)) {
						var w = S * f + t[0] - x,
							P = b * m + t[1] + E;
						L && (P -= c / 2), C.features.push(n([w, P], p))
					}
				}
				return C
			}
		}, {
			"turf-distance": 60,
			"turf-featurecollection": 72,
			"turf-point": 102,
			"turf-polygon": 103
		}],
		76: [function(t, e) {
			function n(t, e) {
				for (var n = !1, i = 0, o = e.length - 1; i < e.length; o = i++) {
					var r = e[i][0],
						s = e[i][1],
						a = e[o][0],
						l = e[o][1],
						u = s > t[1] != l > t[1] && t[0] < (a - r) * (t[1] - s) / (l - s) + r;
					u && (n = !n)
				}
				return n
			}
			e.exports = function(t, e) {
				var i = e.geometry.coordinates,
					o = [t.geometry.coordinates[0], t.geometry.coordinates[1]];
				"Polygon" === e.geometry.type && (i = [i]);
				for (var r = !1, s = 0; s < i.length && !r;) {
					if (n(o, i[s][0])) {
						for (var a = !1, l = 1; l < i[s].length && !a;) n(o, i[s][l]) && (a = !0), l++;
						a || (r = !0)
					}
					s++
				}
				return r
			}
		}, {}],
		77: [function(t, e) {
			var n = t("jsts");
			t("turf-featurecollection"), e.exports = function(t, e) {
				var i;
				i = "Feature" === t.type ? t.geometry : t, geom2 = "Feature" === e.type ? e.geometry : e;
				var o = new n.io.GeoJSONReader,
					r = o.read(JSON.stringify(i)),
					s = o.read(JSON.stringify(geom2)),
					a = r.intersection(s),
					l = new n.io.GeoJSONParser;
				return a = l.write(a), "GeometryCollection" === a.type && 0 === a.geometries.length ? void 0 : {
					type: "Feature",
					properties: {},
					geometry: a
				}
			}
		}, {
			jsts: 78,
			"turf-featurecollection": 72
		}],
		78: [function(t, e, n) {
			arguments[4][17][0].apply(n, arguments)
		}, {
			"./lib/jsts": 79,
			dup: 17,
			"javascript.util": 81
		}],
		79: [function(t, e, n) {
			arguments[4][18][0].apply(n, arguments)
		}, {
			dup: 18
		}],
		80: [function(t, e, n) {
			arguments[4][19][0].apply(n, arguments)
		}, {
			dup: 19
		}],
		81: [function(t, e, n) {
			arguments[4][20][0].apply(n, arguments)
		}, {
			"./dist/javascript.util-node.min.js": 80,
			dup: 20
		}],
		82: [function(t, e) {
			function n(t, e) {
				var n = t.x - e.x,
					i = t.y - e.y;
				return s > n * n + i * i
			}
			function i(t) {
				for (var e = t.head; e;) {
					var n = e.next;
					e.next = e.prev, e.prev = n, e = n
				}
				var n = t.head;
				t.head = t.tail, t.tail = n
			}
			function o(t) {
				this.level = t, this.s = null, this.count = 0
			}
			function r(t) {
				if (t) this.drawContour = t;
				else {
					var e = this;
					e.contours = {}, this.drawContour = function(t, n, i, r, s, a) {
						var l = e.contours[a];
						l || (l = e.contours[a] = new o(s)), l.addSegment({
							x: t,
							y: n
						}, {
							x: i,
							y: r
						})
					}, this.contourList = function() {
						var t = [],
							n = e.contours;
						for (var i in n) for (var o = n[i].s, r = n[i].level; o;) {
							var s = o.head,
								a = [];
							for (a.level = r, a.k = i; s && s.p;) a.push(s.p), s = s.next;
							t.push(a), o = o.next
						}
						return t.sort(function(t, e) {
							return t.k - e.k
						}), t
					}
				}
				this.h = new Array(5), this.sh = new Array(5), this.xh = new Array(5), this.yh = new Array(5)
			}
			e.exports = r;
			var s = 1e-10;
			o.prototype.remove_seq = function(t) {
				t.prev ? t.prev.next = t.next : this.s = t.next, t.next && (t.next.prev = t.prev), --this.count
			}, o.prototype.addSegment = function(t, e) {
				for (var o = this.s, r = null, s = null, a = !1, l = !1; o && (null == r && (n(t, o.head.p) ? (r = o, a = !0) : n(t, o.tail.p) && (r = o)), null == s && (n(e, o.head.p) ? (s = o, l = !0) : n(e, o.tail.p) && (s = o)), null == s || null == r);) o = o.next;
				var u = (null != r ? 1 : 0) | (null != s ? 2 : 0);
				switch (u) {
				case 0:
					var p = {
						p: t,
						prev: null
					},
						h = {
							p: e,
							next: null
						};
					p.next = h, h.prev = p, r = {
						head: p,
						tail: h,
						next: this.s,
						prev: null,
						closed: !1
					}, this.s && (this.s.prev = r), this.s = r, ++this.count;
					break;
				case 1:
					var c = {
						p: e
					};
					a ? (c.next = r.head, c.prev = null, r.head.prev = c, r.head = c) : (c.next = null, c.prev = r.tail, r.tail.next = c, r.tail = c);
					break;
				case 2:
					var c = {
						p: t
					};
					l ? (c.next = s.head, c.prev = null, s.head.prev = c, s.head = c) : (c.next = null, c.prev = s.tail, s.tail.next = c, s.tail = c);
					break;
				case 3:
					if (r === s) {
						var c = {
							p: r.tail.p,
							next: r.head,
							prev: null
						};
						r.head.prev = c, r.head = c, r.closed = !0;
						break
					}
					switch ((a ? 1 : 0) | (l ? 2 : 0)) {
					case 0:
						i(r);
					case 1:
						s.tail.next = r.head, r.head.prev = s.tail, s.tail = r.tail, this.remove_seq(r);
						break;
					case 3:
						i(r);
					case 2:
						r.tail.next = s.head, s.head.prev = r.tail, r.tail = s.tail, this.remove_seq(s)
					}
				}
			}, r.prototype.contour = function(t, e, n, i, o, r, a, l, u) {
				var p = this.h,
					h = this.sh,
					c = this.xh,
					g = this.yh,
					d = this.drawContour;
				this.contours = {};
				for (var f, m, y, v, x, j, E = function(t, e) {
						return (p[e] * c[t] - p[t] * c[e]) / (p[e] - p[t])
					}, I = function(t, e) {
						return (p[e] * g[t] - p[t] * g[e]) / (p[e] - p[t])
					}, C = 0, S = 0, b = 0, L = 0, w = [0, 1, 1, 0], P = [0, 0, 1, 1], M = [
						[
							[0, 0, 8],
							[0, 2, 5],
							[7, 6, 9]
						],
						[
							[0, 3, 4],
							[1, 3, 1],
							[4, 3, 0]
						],
						[
							[9, 6, 7],
							[5, 2, 0],
							[8, 0, 0]
						]
					], _ = o - 1; _ >= i; _--) for (var N = e; n - 1 >= N; N++) {
					var A, T;
					if (A = Math.min(t[N][_], t[N][_ + 1]), T = Math.min(t[N + 1][_], t[N + 1][_ + 1]), x = Math.min(A, T), A = Math.max(t[N][_], t[N][_ + 1]), T = Math.max(t[N + 1][_], t[N + 1][_ + 1]), j = Math.max(A, T), j >= u[0] && x <= u[l - 1]) for (var R = 0; l > R; R++) if (u[R] >= x && u[R] <= j) {
						for (var O = 4; O >= 0; O--) O > 0 ? (p[O] = t[N + w[O - 1]][_ + P[O - 1]] - u[R], c[O] = r[N + w[O - 1]], g[O] = a[_ + P[O - 1]]) : (p[0] = .25 * (p[1] + p[2] + p[3] + p[4]), c[0] = .5 * (r[N] + r[N + 1]), g[0] = .5 * (a[_] + a[_ + 1])), h[O] = p[O] > s ? 1 : p[O] < -s ? -1 : 0;
						for (O = 1; 4 >= O; O++) if (f = O, m = 0, y = 4 != O ? O + 1 : 1, v = M[h[f] + 1][h[m] + 1][h[y] + 1], 0 != v) {
							switch (v) {
							case 1:
								C = c[f], b = g[f], S = c[m], L = g[m];
								break;
							case 2:
								C = c[m], b = g[m], S = c[y], L = g[y];
								break;
							case 3:
								C = c[y], b = g[y], S = c[f], L = g[f];
								break;
							case 4:
								C = c[f], b = g[f], S = E(m, y), L = I(m, y);
								break;
							case 5:
								C = c[m], b = g[m], S = E(y, f), L = I(y, f);
								break;
							case 6:
								C = c[y], b = g[y], S = E(f, m), L = I(f, m);
								break;
							case 7:
								C = E(f, m), b = I(f, m), S = E(m, y), L = I(m, y);
								break;
							case 8:
								C = E(m, y), b = I(m, y), S = E(y, f), L = I(y, f);
								break;
							case 9:
								C = E(y, f), b = I(y, f), S = E(f, m), L = I(f, m)
							}
							d(C, b, S, L, u[R], R)
						}
					}
				}
			}
		}, {}],
		83: [function(t, e) {
			var n = t("turf-tin"),
				i = t("turf-inside"),
				o = t("turf-grid"),
				r = t("turf-extent"),
				s = t("turf-planepoint"),
				a = t("turf-featurecollection"),
				l = t("turf-linestring"),
				u = t("turf-square"),
				p = t("./conrec");
			e.exports = function(t, e, h, c) {
				for (var g = n(t, e), d = r(t), f = u(d), m = o(f, h), y = [], v = 0; v < m.features.length; v++) for (var x = m.features[v], j = 0; j < g.features.length; j++) {
					var E = g.features[j];
					i(x, E) && (x.properties = {}, x.properties[e] = s(x, E))
				}
				for (var I = Math.sqrt(m.features.length), C = 0; I > C; C++) {
					var S = m.features.slice(C * I, (C + 1) * I),
						b = [];
					S.forEach(function(t) {
						b.push(t.properties ? t.properties[e] : 0)
					}), y.push(b)
				}
				for (var L = (f[2] - f[0]) / I, w = [], P = [], C = 0; I > C; C++) w.push(C * L + f[0]), P.push(C * L + f[1]);
				var M = new p;
				M.contour(y, 0, h, 0, h, w, P, c.length, c);
				var _ = M.contourList(),
					N = a([]);
				return _.forEach(function(t) {
					if (t.length > 2) {
						var n = [];
						t.forEach(function(t) {
							n.push([t.x, t.y])
						});
						var i = l(n);
						i.properties = {}, i.properties[e] = t.level, N.features.push(i)
					}
				}), N
			}
		}, {
			"./conrec": 82,
			"turf-extent": 70,
			"turf-featurecollection": 72,
			"turf-grid": 84,
			"turf-inside": 76,
			"turf-linestring": 90,
			"turf-planepoint": 98,
			"turf-square": 115,
			"turf-tin": 118
		}],
		84: [function(t, e) {
			var n = t("turf-point");
			e.exports = function(t, e) {
				for (var i = t[0], o = t[1], r = t[2], s = (t[3], (r - i) / e), a = {
					type: "FeatureCollection",
					features: []
				}, l = 0; e >= l; l++) for (var u = 0; e >= u; u++) a.features.push(n([l * s + i, u * s + o]));
				return a
			}
		}, {
			"turf-point": 102
		}],
		85: [function(t, e) {
			var n = t("simple-statistics");
			e.exports = function(t, e, i) {
				var o = [],
					r = [];
				return t.features.forEach(function(t) {
					void 0 !== t.properties[e] && o.push(t.properties[e])
				}), r = n.jenks(o, i)
			}
		}, {
			"simple-statistics": 86
		}],
		86: [function(t, e, n) {
			arguments[4][59][0].apply(n, arguments)
		}, {
			dup: 59
		}],
		87: [function(t, e) {
			function n(t, e, n, i, o, r, s, a) {
				var l, u, p, h, c, g = {
					x: null,
					y: null,
					onLine1: !1,
					onLine2: !1
				};
				return l = (a - r) * (n - t) - (s - o) * (i - e), 0 == l ? null != g.x && null != g.y && g : (u = e - r, p = t - o, h = (s - o) * u - (a - r) * p, c = (n - t) * u - (i - e) * p, u = h / l, p = c / l, g.x = t + u * (n - t), g.y = e + u * (i - e), u > 0 && 1 > u && (g.onLine1 = !0), p > 0 && 1 > p && (g.onLine2 = !0), !(!g.onLine1 || !g.onLine2) && [g.x, g.y])
			}
			var i = (t("turf-polygon"), t("turf-point")),
				o = t("turf-featurecollection");
			e.exports = function(t) {
				var e, r = {
					intersections: o([]),
					fixed: null
				};
				return e = "Feature" === t.type ? t.geometry : t, e.coordinates.forEach(function(t) {
					e.coordinates.forEach(function(e) {
						for (var o = 0; o < t.length - 1; o++) for (var s = 0; s < e.length - 1; s++) {
							var a = n(t[o][0], t[o][1], t[o + 1][0], t[o + 1][1], e[s][0], e[s][1], e[s + 1][0], e[s + 1][1]);
							a && r.intersections.features.push(i([a[0], a[1]]))
						}
					})
				}), r
			}
		}, {
			"turf-featurecollection": 72,
			"turf-point": 102,
			"turf-polygon": 103
		}],
		88: [function(t, e) {
			var n = t("turf-distance"),
				i = t("turf-point");
			e.exports = function(t, e) {
				var o;
				if ("Feature" === t.type) o = t.geometry.coordinates;
				else {
					if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry");
					o = t.geometry.coordinates
				}
				for (var r = 0, s = 0; s < o.length - 1; s++) r += n(i(o[s]), i(o[s + 1]), e);
				return r
			}
		}, {
			"turf-distance": 60,
			"turf-point": 102
		}],
		89: [function(t, e) {
			function n(t, e) {
				for (var n = "miles", s = r([1 / 0, 1 / 0], {
					dist: 1 / 0
				}), u = 0; u < e.length - 1; u++) {
					var p = r(e[u]),
						h = r(e[u + 1]);
					p.properties.dist = o(t, p, n), h.properties.dist = o(t, h, n);
					var c = a(p, h),
						g = l(t, 1e3, c + 90, n),
						d = i(t.geometry.coordinates[0], t.geometry.coordinates[1], g.geometry.coordinates[0], g.geometry.coordinates[1], p.geometry.coordinates[0], p.geometry.coordinates[1], h.geometry.coordinates[0], h.geometry.coordinates[1]);
					d || (g = l(t, 1e3, c - 90, n), d = i(t.geometry.coordinates[0], t.geometry.coordinates[1], g.geometry.coordinates[0], g.geometry.coordinates[1], p.geometry.coordinates[0], p.geometry.coordinates[1], h.geometry.coordinates[0], h.geometry.coordinates[1])), g.properties.dist = 1 / 0;
					var f;
					if (d) {
						var f = r(d);
						f.properties.dist = o(t, f, n)
					}
					p.properties.dist < s.properties.dist && (s = p, s.properties.index = u), h.properties.dist < s.properties.dist && (s = h, s.properties.index = u), f && f.properties.dist < s.properties.dist && (s = f, s.properties.index = u)
				}
				return s
			}
			function i(t, e, n, i, o, r, s, a) {
				var l, u, p, h, c, g = {
					x: null,
					y: null,
					onLine1: !1,
					onLine2: !1
				};
				return l = (a - r) * (n - t) - (s - o) * (i - e), 0 == l ? null != g.x && null != g.y && g : (u = e - r, p = t - o, h = (s - o) * u - (a - r) * p, c = (n - t) * u - (i - e) * p, u = h / l, p = c / l, g.x = t + u * (n - t), g.y = e + u * (i - e), u > 0 && 1 > u && (g.onLine1 = !0), p > 0 && 1 > p && (g.onLine2 = !0), !(!g.onLine1 || !g.onLine2) && [g.x, g.y])
			}
			var o = t("turf-distance"),
				r = t("turf-point"),
				s = t("turf-linestring"),
				a = t("turf-bearing"),
				l = t("turf-destination");
			e.exports = function(t, e, i) {
				var o;
				if ("Feature" === i.type) o = i.geometry.coordinates;
				else {
					if ("LineString" !== i.type) throw new Error("input must be a LineString Feature or Geometry");
					o = i.geometry.coordinates
				}
				var r, a = n(t, o),
					l = n(e, o);
				r = a.properties.index <= l.properties.index ? [a, l] : [l, a];
				for (var u = s([r[0].geometry.coordinates], {}), p = r[0].properties.index + 1; p < r[1].properties.index + 1; p++) u.geometry.coordinates.push(o[p]);
				return u.geometry.coordinates.push(r[1].geometry.coordinates), u
			}
		}, {
			"turf-bearing": 13,
			"turf-destination": 57,
			"turf-distance": 60,
			"turf-linestring": 90,
			"turf-point": 102
		}],
		90: [function(t, e) {
			e.exports = function(t, e) {
				if (!t) throw new Error("No coordinates passed");
				return {
					type: "Feature",
					geometry: {
						type: "LineString",
						coordinates: t
					},
					properties: e || {}
				}
			}
		}, {}],
		91: [function(t, e) {
			function n(t) {
				for (var e, n = 0; n < t.length; n++)(t[n] > e || void 0 === e) && (e = t[n]);
				return e
			}
			var i = t("turf-inside");
			e.exports = function(t, e, o, r) {
				return t.features.forEach(function(t) {
					t.properties || (t.properties = {});
					var s = [];
					e.features.forEach(function(e) {
						i(e, t) && s.push(e.properties[o])
					}), t.properties[r] = n(s)
				}), t
			}
		}, {
			"turf-inside": 76
		}],
		92: [function(t, e) {
			function n(t) {
				if (0 === t.length) return null;
				var e = t.slice().sort(function(t, e) {
					return t - e
				});
				if (e.length % 2 === 1) return e[(e.length - 1) / 2];
				var n = e[e.length / 2 - 1],
					i = e[e.length / 2];
				return (n + i) / 2
			}
			var i = t("turf-inside");
			e.exports = function(t, e, o, r) {
				return t.features.forEach(function(t) {
					t.properties || (t.properties = {});
					var s = [];
					e.features.forEach(function(e) {
						i(e, t) && s.push(e.properties[o])
					}), t.properties[r] = n(s)
				}), t
			}
		}, {
			"turf-inside": 76
		}],
		93: [function(t, e) {
			var n = t("clone"),
				i = t("turf-union");
			e.exports = function(t) {
				for (var e = n(t.features[0]), o = t.features, r = 0, s = o.length; s > r; r++) {
					var a = o[r];
					a.geometry && (e = i(e, a))
				}
				return e
			}
		}, {
			clone: 94,
			"turf-union": 120
		}],
		94: [function(t, e) {
			(function(t) {
				"use strict";

				function n(t) {
					return Object.prototype.toString.call(t)
				}
				function i(e, n, i, r) {
					function s(e, i) {
						if (null === e) return null;
						if (0 == i) return e;
						var p, h;
						if ("object" != typeof e) return e;
						if (o.isArray(e)) p = [];
						else if (o.isRegExp(e)) p = new RegExp(e.source, o.getRegExpFlags(e)), e.lastIndex && (p.lastIndex = e.lastIndex);
						else if (o.isDate(e)) p = new Date(e.getTime());
						else {
							if (u && t.isBuffer(e)) return p = new t(e.length), e.copy(p), p;
							"undefined" == typeof r ? (h = Object.getPrototypeOf(e), p = Object.create(h)) : (p = Object.create(r), h = r)
						}
						if (n) {
							var c = a.indexOf(e);
							if (-1 != c) return l[c];
							a.push(e), l.push(p)
						}
						for (var g in e) {
							var d;
							h && (d = Object.getOwnPropertyDescriptor(h, g)), d && null == d.set || (p[g] = s(e[g], i - 1))
						}
						return p
					}
					var a = [],
						l = [],
						u = "undefined" != typeof t;
					return "undefined" == typeof n && (n = !0), "undefined" == typeof i && (i = 1 / 0), s(e, i)
				}
				var o = {
					isArray: function(t) {
						return Array.isArray(t) || "object" == typeof t && "[object Array]" === n(t)
					},
					isDate: function(t) {
						return "object" == typeof t && "[object Date]" === n(t)
					},
					isRegExp: function(t) {
						return "object" == typeof t && "[object RegExp]" === n(t)
					},
					getRegExpFlags: function(t) {
						var e = "";
						return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), e
					}
				};
				"object" == typeof e && (e.exports = i), i.clonePrototype = function(t) {
					if (null === t) return null;
					var e = function() {};
					return e.prototype = t, new e
				}
			}).call(this, t("buffer").Buffer)
		}, {
			buffer: 2
		}],
		95: [function(t, e) {
			var n = t("turf-point");
			e.exports = function(t, e) {
				if (null === t || null === e) throw new Error("Less than two points passed.");
				var i = t.geometry.coordinates[0],
					o = e.geometry.coordinates[0],
					r = t.geometry.coordinates[1],
					s = e.geometry.coordinates[1],
					a = i + o,
					l = a / 2,
					u = r + s,
					p = u / 2;
				return n([l, p])
			}
		}, {
			"turf-point": 102
		}],
		96: [function(t, e) {
			function n(t) {
				for (var e, n = 0; n < t.length; n++)(t[n] < e || void 0 === e) && (e = t[n]);
				return e
			}
			var i = t("turf-inside");
			e.exports = function(t, e, o, r) {
				return t.features.forEach(function(t) {
					t.properties || (t.properties = {});
					var s = [];
					e.features.forEach(function(e) {
						i(e, t) && s.push(e.properties[o])
					}), t.properties[r] = n(s)
				}), t
			}
		}, {
			"turf-inside": 76
		}],
		97: [function(t, e) {
			var n = t("turf-distance");
			e.exports = function(t, e) {
				var i;
				return e.features.forEach(function(e) {
					if (i) {
						var o = n(t, e, "miles");
						o < i.properties.distance && (i = e, i.properties.distance = o)
					} else {
						i = e;
						var o = n(t, e, "miles");
						i.properties.distance = o
					}
				}), delete i.properties.distance, i
			}
		}, {
			"turf-distance": 60
		}],
		98: [function(t, e) {
			e.exports = function(t, e) {
				var n = t.geometry.coordinates[0],
					i = t.geometry.coordinates[1],
					o = e.geometry.coordinates[0][0][0],
					r = e.geometry.coordinates[0][0][1],
					s = e.properties.a,
					a = e.geometry.coordinates[0][1][0],
					l = e.geometry.coordinates[0][1][1],
					u = e.properties.b,
					p = e.geometry.coordinates[0][2][0],
					h = e.geometry.coordinates[0][2][1],
					c = e.properties.c,
					g = (c * (n - o) * (i - l) + s * (n - a) * (i - h) + u * (n - p) * (i - r) - u * (n - o) * (i - h) - c * (n - a) * (i - r) - s * (n - p) * (i - l)) / ((n - o) * (i - l) + (n - a) * (i - h) + (n - p) * (i - r) - (n - o) * (i - h) - (n - a) * (i - r) - (n - p) * (i - l));
				return g
			}
		}, {}],
		99: [function(t, e) {
			var n = t("turf-point"),
				i = t("turf-featurecollection"),
				o = t("turf-distance");
			e.exports = function(t, e, r) {
				for (var s = i([]), a = e / o(n([t[0], t[1]]), n([t[2], t[1]]), r), l = a * (t[2] - t[0]), u = e / o(n([t[0], t[1]]), n([t[0], t[3]]), r), p = u * (t[3] - t[1]), h = t[0]; h <= t[2];) {
					for (var c = t[1]; c <= t[3];) s.features.push(n([h, c])), c += p;
					h += l
				}
				return s
			}
		}, {
			"turf-distance": 60,
			"turf-featurecollection": 72,
			"turf-point": 102
		}],
		100: [function(t, e) {
			function n(t, e) {
				for (var n = "miles", l = r([1 / 0, 1 / 0], {
					dist: 1 / 0
				}), u = 0; u < e.length - 1; u++) {
					var p = r(e[u]),
						h = r(e[u + 1]);
					p.properties.dist = o(t, p, n), h.properties.dist = o(t, h, n);
					var c = s(p, h),
						g = a(t, 1e3, c + 90, n),
						d = i(t.geometry.coordinates[0], t.geometry.coordinates[1], g.geometry.coordinates[0], g.geometry.coordinates[1], p.geometry.coordinates[0], p.geometry.coordinates[1], h.geometry.coordinates[0], h.geometry.coordinates[1]);
					d || (g = a(t, 1e3, c - 90, n), d = i(t.geometry.coordinates[0], t.geometry.coordinates[1], g.geometry.coordinates[0], g.geometry.coordinates[1], p.geometry.coordinates[0], p.geometry.coordinates[1], h.geometry.coordinates[0], h.geometry.coordinates[1])), g.properties.dist = 1 / 0;
					var f;
					if (d) {
						var f = r(d);
						f.properties.dist = o(t, f, n)
					}
					p.properties.dist < l.properties.dist && (l = p, l.properties.index = u), h.properties.dist < l.properties.dist && (l = h, l.properties.index = u), f && f.properties.dist < l.properties.dist && (l = f, l.properties.index = u)
				}
				return l
			}
			function i(t, e, n, i, o, r, s, a) {
				var l, u, p, h, c, g = {
					x: null,
					y: null,
					onLine1: !1,
					onLine2: !1
				};
				return l = (a - r) * (n - t) - (s - o) * (i - e), 0 == l ? null != g.x && null != g.y && g : (u = e - r, p = t - o, h = (s - o) * u - (a - r) * p, c = (n - t) * u - (i - e) * p, u = h / l, p = c / l, g.x = t + u * (n - t), g.y = e + u * (i - e), u > 0 && 1 > u && (g.onLine1 = !0), p > 0 && 1 > p && (g.onLine2 = !0), !(!g.onLine1 || !g.onLine2) && [g.x, g.y])
			}
			var o = t("turf-distance"),
				r = t("turf-point"),
				s = (t("turf-linestring"), t("turf-bearing")),
				a = t("turf-destination");
			e.exports = function(t, e) {
				var i;
				if ("Feature" === t.type) i = t.geometry.coordinates;
				else {
					if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry");
					i = t.geometry.coordinates
				}
				return n(e, i)
			}
		}, {
			"turf-bearing": 13,
			"turf-destination": 57,
			"turf-distance": 60,
			"turf-linestring": 90,
			"turf-point": 102
		}],
		101: [function(t, e) {
			function n(t, e, n, i, o, r) {
				var s = Math.sqrt((o - n) * (o - n) + (r - i) * (r - i)),
					a = Math.sqrt((t - n) * (t - n) + (e - i) * (e - i)),
					l = Math.sqrt((o - t) * (o - t) + (r - e) * (r - e));
				return s === a + l || void 0
			}
			var i = t("turf-featurecollection"),
				o = t("turf-center"),
				r = t("turf-distance"),
				s = t("turf-inside"),
				a = t("turf-explode");
			e.exports = function(t) {
				"FeatureCollection" != t.type && ("Feature" != t.type && (t = {
					type: "Feature",
					geometry: t,
					properties: {}
				}), t = i([t]));
				for (var e = o(t), l = !1, u = 0; !l && u < t.features.length;) {
					var p = t.features[u].geometry;
					if ("Point" === p.type) e.geometry.coordinates[0] === p.coordinates[0] && e.geometry.coordinates[1] === p.coordinates[1] && (l = !0);
					else if ("MultiPoint" === p.type) for (var h = !1, c = 0; !h && c < p.coordinates.length;) e.geometry.coordinates[0] === p.coordinates[c][0] && e.geometry.coordinates[1] === p.coordinates[c][1] && (l = !0, h = !0), c++;
					else if ("LineString" === p.type) for (var g = !1, c = 0; !g && c < p.coordinates.length - 1;) {
						var d = e.geometry.coordinates[0],
							f = e.geometry.coordinates[1],
							m = p.coordinates[c][0],
							y = p.coordinates[c][1],
							v = p.coordinates[c + 1][0],
							x = p.coordinates[c + 1][1];
						n(d, f, m, y, v, x) && (g = !0, l = !0), c++
					} else if ("MultiLineString" === p.type) for (var j = !1, E = 0; !j && E < p.coordinates.length;) {
						for (var g = !1, c = 0, I = p.coordinates[E]; !g && c < I.length - 1;) {
							var d = e.geometry.coordinates[0],
								f = e.geometry.coordinates[1],
								m = I[c][0],
								y = I[c][1],
								v = I[c + 1][0],
								x = I[c + 1][1];
							n(d, f, m, y, v, x) && (g = !0, l = !0), c++
						}
						E++
					} else if ("Polygon" === p.type || "MultiPolygon" === p.type) {
						var C = {
							type: "Feature",
							geometry: p,
							properties: {}
						};
						s(e, C) && (l = !0)
					}
					u++
				}
				if (l) return e;
				for (var S = i([]), u = 0; u < t.features.length; u++) S.features = S.features.concat(a(t.features[u]).features);
				for (var b, L = 1 / 0, u = 0; u < S.features.length; u++) {
					var w = r(e, S.features[u], "miles");
					L > w && (L = w, b = S.features[u])
				}
				return b
			}
		}, {
			"turf-center": 21,
			"turf-distance": 60,
			"turf-explode": 68,
			"turf-featurecollection": 72,
			"turf-inside": 76
		}],
		102: [function(t, e) {
			var n = Array.isArray ||
			function(t) {
				return "[object Array]" === Object.prototype.toString.call(t)
			};
			e.exports = function(t, e) {
				if (!n(t)) throw new Error("Coordinates must be an array");
				if (t.length < 2) throw new Error("Coordinates must be at least 2 numbers long");
				return {
					type: "Feature",
					geometry: {
						type: "Point",
						coordinates: t
					},
					properties: e || {}
				}
			}
		}, {}],
		103: [function(t, e) {
			e.exports = function(t, e) {
				if (null === t) throw new Error("No coordinates passed");
				for (var n = 0; n < t.length; n++) for (var i = t[n], o = 0; o < i[i.length - 1].length; o++) {
					if (i.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
					if (i[i.length - 1][o] !== i[0][o]) throw new Error("First and last Position are not equivalent.")
				}
				var r = {
					type: "Feature",
					geometry: {
						type: "Polygon",
						coordinates: t
					},
					properties: e
				};
				return r.properties || (r.properties = {}), r
			}
		}, {}],
		104: [function(t, e) {
			var n = t("simple-statistics");
			e.exports = function(t, e, i) {
				var o = [],
					r = [];
				return t.features.forEach(function(t) {
					o.push(t.properties[e])
				}), i.forEach(function(t) {
					r.push(n.quantile(o, .01 * t))
				}), r
			}
		}, {
			"simple-statistics": 105
		}],
		105: [function(t, e, n) {
			arguments[4][59][0].apply(n, arguments)
		}, {
			dup: 59
		}],
		106: [function(t, e) {
			var n = t("geojson-random");
			e.exports = function(t, e, i) {
				switch (i = i || {}, e = e || 1, t) {
				case "point":
				case "points":
				case void 0:
					return n.point(e, i.bbox);
				case "polygon":
				case "polygons":
					return n.polygon(e, i.num_vertices, i.max_radial_length, i.bbox);
				default:
					throw new Error("Unknown type given: valid options are points and polygons")
				}
			}
		}, {
			"geojson-random": 107
		}],
		107: [function(t, e) {
			function n(t) {
				return t ? u(t) : [s(), a()]
			}
			function o(t) {
				return function(e) {
					return [e[0] + t[0], e[1] + t[1]]
				}
			}
			function r() {
				return Math.random() - .5
			}
			function s() {
				return 360 * r()
			}
			function a() {
				return 180 * r()
			}
			function l(t) {
				return {
					type: "Point",
					coordinates: t || [s(), a()]
				}
			}
			function u(t) {
				return [Math.random() * (t[2] - t[0]) + t[0], Math.random() * (t[3] - t[1]) + t[1]]
			}
			function p(t) {
				return {
					type: "Polygon",
					coordinates: t
				}
			}
			function h(t) {
				return {
					type: "Feature",
					geometry: t,
					properties: {}
				}
			}
			function c(t) {
				return {
					type: "FeatureCollection",
					features: t
				}
			}
			e.exports = function() {
				throw new Error("call .point() or .polygon() instead")
			}, e.exports.position = n, e.exports.point = function(t, e) {
				var o = [];
				for (i = 0; i < t; i++) o.push(h(e ? l(n(e)) : l()));
				return c(o)
			}, e.exports.polygon = function(t, e, r, s) {
				function a(t, e, n) {
					n[e] = e > 0 ? t + n[e - 1] : t
				}
				function l(t) {
					t = 2 * t * Math.PI / d[d.length - 1];
					var e = Math.random();
					g.push([e * r * Math.sin(t), e * r * Math.cos(t)])
				}
				"number" != typeof e && (e = 10), "number" != typeof r && (r = 10);
				var u = [];
				for (i = 0; i < t; i++) {
					var g = [],
						d = Array.apply(null, new Array(e + 1)).map(Math.random);
					d.forEach(a), d.forEach(l), g[g.length - 1] = g[0], g = g.map(o(n(s))), u.push(h(p([g])))
				}
				return c(u)
			}
		}, {}],
		108: [function(t, e) {
			var n = t("turf-featurecollection");
			t("./index.js"), e.exports = function(t, e, i, o) {
				var r = n([]);
				return t.features.forEach(function(t) {
					for (var n = 0; n < o.length; n++) t.properties[e] >= o[n][0] && t.properties[e] <= o[n][1] && (t.properties[i] = o[n][2]);
					r.features.push(t)
				}), r
			}
		}, {
			"./index.js": 108,
			"turf-featurecollection": 72
		}],
		109: [function(t, e) {
			var n = t("turf-featurecollection");
			e.exports = function(t, e, i) {
				for (var o = n([]), r = 0; r < t.features.length; r++) t.features[r].properties[e] != i && o.features.push(t.features[r]);
				return o
			}
		}, {
			"turf-featurecollection": 72
		}],
		110: [function(t, e) {
			function n(t, e) {
				for (var n, i, o = t.slice(0), r = t.length, s = r - e; r-- > s;) i = Math.floor((r + 1) * Math.random()), n = o[i], o[i] = o[r], o[r] = n;
				return o.slice(s)
			}
			var i = t("turf-featurecollection");
			e.exports = function(t, e) {
				var o = i(n(t.features, e));
				return o
			}
		}, {
			"turf-featurecollection": 72
		}],
		111: [function(t, e) {
			function n(t, e) {
				return {
					type: "Feature",
					geometry: t,
					properties: e
				}
			}
			var i = t("simplify-js");
			e.exports = function(t, e, o) {
				if ("LineString" === t.geometry.type) {
					var r = {
						type: "LineString",
						coordinates: []
					},
						s = t.geometry.coordinates.map(function(t) {
							return {
								x: t[0],
								y: t[1]
							}
						});
					return r.coordinates = i(s, e, o).map(function(t) {
						return [t.x, t.y]
					}), n(r, t.properties)
				}
				if ("Polygon" === t.geometry.type) {
					var a = {
						type: "Polygon",
						coordinates: []
					};
					return t.geometry.coordinates.forEach(function(t) {
						var n = t.map(function(t) {
							return {
								x: t[0],
								y: t[1]
							}
						}),
							r = i(n, e, o).map(function(t) {
								return [t.x, t.y]
							});
						a.coordinates.push(r)
					}), n(a, t.properties)
				}
			}
		}, {
			"simplify-js": 112
		}],
		112: [function(e, n) {
			!
			function() {
				"use strict";

				function e(t, e) {
					var n = t.x - e.x,
						i = t.y - e.y;
					return n * n + i * i
				}
				function i(t, e, n) {
					var i = e.x,
						o = e.y,
						r = n.x - i,
						s = n.y - o;
					if (0 !== r || 0 !== s) {
						var a = ((t.x - i) * r + (t.y - o) * s) / (r * r + s * s);
						a > 1 ? (i = n.x, o = n.y) : a > 0 && (i += r * a, o += s * a)
					}
					return r = t.x - i, s = t.y - o, r * r + s * s
				}
				function o(t, n) {
					for (var i, o = t[0], r = [o], s = 1, a = t.length; a > s; s++) i = t[s], e(i, o) > n && (r.push(i), o = i);
					return o !== i && r.push(i), r
				}
				function r(t, e) {
					var n, o, r, s, a = t.length,
						l = "undefined" != typeof Uint8Array ? Uint8Array : Array,
						u = new l(a),
						p = 0,
						h = a - 1,
						c = [],
						g = [];
					for (u[p] = u[h] = 1; h;) {
						for (o = 0, n = p + 1; h > n; n++) r = i(t[n], t[p], t[h]), r > o && (s = n, o = r);
						o > e && (u[s] = 1, c.push(p, s, s, h)), h = c.pop(), p = c.pop()
					}
					for (n = 0; a > n; n++) u[n] && g.push(t[n]);
					return g
				}
				function s(t, e, n) {
					var i = void 0 !== e ? e * e : 1;
					return t = n ? t : o(t, i), t = r(t, i)
				}
				"function" == typeof t && t.amd ? t(function() {
					return s
				}) : "undefined" != typeof n ? n.exports = s : "undefined" != typeof self ? self.simplify = s : window.simplify = s
			}()
		}, {}],
		113: [function(t, e) {
			e.exports = function(t, e) {
				var n = t[2] - t[0],
					i = t[3] - t[1],
					o = n * e,
					r = i * e,
					s = o - n,
					a = r - i,
					l = t[0] - s / 2,
					u = t[1] - a / 2,
					p = s / 2 + t[2],
					h = a / 2 + t[3],
					c = [l, u, p, h];
				return c
			}
		}, {}],
		114: [function(t, e) {
			var n = t("turf-featurecollection"),
				i = t("turf-point"),
				o = t("turf-polygon"),
				r = t("turf-distance");
			e.exports = function(t, e, s) {
				for (var a = n([]), l = e / r(i([t[0], t[1]]), i([t[2], t[1]]), s), u = l * (t[2] - t[0]), p = e / r(i([t[0], t[1]]), i([t[0], t[3]]), s), h = p * (t[3] - t[1]), c = t[0]; c <= t[2];) {
					for (var g = t[1]; g <= t[3];) {
						var d = o([
							[
								[c, g],
								[c, g + h],
								[c + u, g + h],
								[c + u, g],
								[c, g]
							]
						]);
						a.features.push(d), g += h
					}
					c += u
				}
				return a
			}
		}, {
			"turf-distance": 60,
			"turf-featurecollection": 72,
			"turf-point": 102,
			"turf-polygon": 103
		}],
		115: [function(t, e) {
			var n = t("turf-midpoint"),
				i = t("turf-point"),
				o = t("turf-distance");
			e.exports = function(t) {
				var e = [0, 0, 0, 0],
					r = i([t[0], t[1]]),
					s = i([t[0], t[3]]),
					a = (i([t[2], t[3]]), i([t[2], t[1]])),
					l = o(r, a, "miles"),
					u = o(r, s, "miles");
				if (l >= u) {
					e[0] = t[0], e[2] = t[2];
					var p = n(r, s);
					return e[1] = p.geometry.coordinates[1] - (t[2] - t[0]) / 2, e[3] = p.geometry.coordinates[1] + (t[2] - t[0]) / 2, e
				}
				e[1] = t[1], e[3] = t[3];
				var h = n(r, a);
				return e[0] = h.geometry.coordinates[0] - (t[3] - t[1]) / 2, e[2] = h.geometry.coordinates[0] + (t[3] - t[1]) / 2, e
			}
		}, {
			"turf-distance": 60,
			"turf-midpoint": 95,
			"turf-point": 102
		}],
		116: [function(t, e) {
			function n(t) {
				for (var e = 0, n = 0; n < t.length; n++) e += t[n];
				return e
			}
			var i = t("turf-inside");
			e.exports = function(t, e, o, r) {
				return t.features.forEach(function(t) {
					t.properties || (t.properties = {});
					var s = [];
					e.features.forEach(function(e) {
						i(e, t) && s.push(e.properties[o])
					}), t.properties[r] = n(s)
				}), t
			}
		}, {
			"turf-inside": 76
		}],
		117: [function(t, e) {
			var n = t("turf-inside");
			e.exports = function(t, e, i, o) {
				return t = JSON.parse(JSON.stringify(t)), e = JSON.parse(JSON.stringify(e)), t.features.forEach(function(t) {
					t.properties || (t.properties = {}), e.features.forEach(function(e) {
						if (void 0 === t.properties[o]) {
							var r = n(t, e);
							r && (t.properties[o] = e.properties[i])
						}
					})
				}), t
			}
		}, {
			"turf-inside": 76
		}],
		118: [function(t, e) {
			function n(t, e, n) {
				this.a = t, this.b = e, this.c = n;
				var i, o, r, s, a = e.x - t.x,
					l = e.y - t.y,
					u = n.x - t.x,
					p = n.y - t.y,
					h = a * (t.x + e.x) + l * (t.y + e.y),
					c = u * (t.x + n.x) + p * (t.y + n.y),
					g = 2 * (a * (n.y - e.y) - l * (n.x - e.x));
				Math.abs(g) < 1e-6 ? (i = Math.min(t.x, e.x, n.x), o = Math.min(t.y, e.y, n.y), r = .5 * (Math.max(t.x, e.x, n.x) - i), s = .5 * (Math.max(t.y, e.y, n.y) - o), this.x = i + r, this.y = o + s, this.r = r * r + s * s) : (this.x = (p * h - l * c) / g, this.y = (a * c - u * h) / g, r = this.x - t.x, s = this.y - t.y, this.r = r * r + s * s)
			}
			function i(t, e) {
				return e.x - t.x
			}
			function o(t) {
				var e, n, i, o, r, s = t.length;
				t: for (; s;) for (n = t[--s], e = t[--s], i = s; i;) if (r = t[--i], o = t[--i], e === o && n === r || e === r && n === o) {
					t.splice(s, 2), t.splice(i, 2), s -= 2;
					continue t
				}
			}
			function r(t) {
				if (t.length < 3) return [];
				t.sort(i);
				for (var e = t.length - 1, r = t[e].x, s = t[0].x, a = t[e].y, l = a; e--;) t[e].y < a && (a = t[e].y), t[e].y > l && (l = t[e].y);
				var u, p, h, c = s - r,
					g = l - a,
					d = c > g ? c : g,
					f = .5 * (s + r),
					m = .5 * (l + a),
					y = [new n({
						x: f - 20 * d,
						y: m - d,
						__sentinel: !0
					}, {
						x: f,
						y: m + 20 * d,
						__sentinel: !0
					}, {
						x: f + 20 * d,
						y: m - d,
						__sentinel: !0
					})],
					v = [],
					x = [];
				for (e = t.length; e--;) {
					for (x.length = 0, u = y.length; u--;) c = t[e].x - y[u].x, c > 0 && c * c > y[u].r ? (v.push(y[u]), y.splice(u, 1)) : (g = t[e].y - y[u].y, c * c + g * g > y[u].r || (x.push(y[u].a, y[u].b, y[u].b, y[u].c, y[u].c, y[u].a), y.splice(u, 1)));
					for (o(x), u = x.length; u;) h = x[--u], p = x[--u], y.push(new n(p, h, t[e]))
				}
				for (Array.prototype.push.apply(v, y), e = v.length; e--;)(v[e].a.__sentinel || v[e].b.__sentinel || v[e].c.__sentinel) && v.splice(e, 1);
				return v
			}
			var s = t("turf-polygon"),
				a = t("turf-featurecollection");
			e.exports = function(t, e) {
				return a(r(t.features.map(function(t) {
					var n = {
						x: t.geometry.coordinates[0],
						y: t.geometry.coordinates[1]
					};
					return e && (n.z = t.properties[e]), n
				})).map(function(t) {
					return s([
						[
							[t.a.x, t.a.y],
							[t.b.x, t.b.y],
							[t.c.x, t.c.y],
							[t.a.x, t.a.y]
						]
					], {
						a: t.a.z,
						b: t.b.z,
						c: t.c.z
					})
				}))
			}
		}, {
			"turf-featurecollection": 72,
			"turf-polygon": 103
		}],
		119: [function(t, e) {
			var n = t("turf-featurecollection"),
				i = t("turf-point"),
				o = t("turf-polygon"),
				r = t("turf-distance");
			e.exports = function(t, e, s) {
				for (var a = n([]), l = e / r(i([t[0], t[1]]), i([t[2], t[1]]), s), u = l * (t[2] - t[0]), p = e / r(i([t[0], t[1]]), i([t[0], t[3]]), s), h = p * (t[3] - t[1]), c = 0, g = t[0]; g <= t[2];) {
					for (var d = 0, f = t[1]; f <= t[3];) {
						if (c % 2 === 0 && d % 2 === 0) {
							var m = o([
								[
									[g, f],
									[g, f + h],
									[g + u, f],
									[g, f]
								]
							]);
							a.features.push(m);
							var y = o([
								[
									[g, f + h],
									[g + u, f + h],
									[g + u, f],
									[g, f + h]
								]
							]);
							a.features.push(y)
						} else if (c % 2 === 0 && d % 2 === 1) {
							var m = o([
								[
									[g, f],
									[g + u, f + h],
									[g + u, f],
									[g, f]
								]
							]);
							a.features.push(m);
							var y = o([
								[
									[g, f],
									[g, f + h],
									[g + u, f + h],
									[g, f]
								]
							]);
							a.features.push(y)
						} else if (d % 2 === 0 && c % 2 === 1) {
							var m = o([
								[
									[g, f],
									[g, f + h],
									[g + u, f + h],
									[g, f]
								]
							]);
							a.features.push(m);
							var y = o([
								[
									[g, f],
									[g + u, f + h],
									[g + u, f],
									[g, f]
								]
							]);
							a.features.push(y)
						} else if (d % 2 === 1 && c % 2 === 1) {
							var m = o([
								[
									[g, f],
									[g, f + h],
									[g + u, f],
									[g, f]
								]
							]);
							a.features.push(m);
							var y = o([
								[
									[g, f + h],
									[g + u, f + h],
									[g + u, f],
									[g, f + h]
								]
							]);
							a.features.push(y)
						}
						f += h, d++
					}
					c++, g += u
				}
				return a
			}
		}, {
			"turf-distance": 60,
			"turf-featurecollection": 72,
			"turf-point": 102,
			"turf-polygon": 103
		}],
		120: [function(t, e) {
			var n = t("jsts");
			e.exports = function(t, e) {
				var i = new n.io.GeoJSONReader,
					o = i.read(JSON.stringify(t.geometry)),
					r = i.read(JSON.stringify(e.geometry)),
					s = o.union(r),
					a = new n.io.GeoJSONParser;
				return s = a.write(s), {
					type: "Feature",
					geometry: s,
					properties: t.properties
				}
			}
		}, {
			jsts: 121
		}],
		121: [function(t, e, n) {
			arguments[4][17][0].apply(n, arguments)
		}, {
			"./lib/jsts": 122,
			dup: 17,
			"javascript.util": 124
		}],
		122: [function(t, e, n) {
			arguments[4][18][0].apply(n, arguments)
		}, {
			dup: 18
		}],
		123: [function(t, e, n) {
			arguments[4][19][0].apply(n, arguments)
		}, {
			dup: 19
		}],
		124: [function(t, e, n) {
			arguments[4][20][0].apply(n, arguments)
		}, {
			"./dist/javascript.util-node.min.js": 123,
			dup: 20
		}],
		125: [function(t, e) {
			var n = t("simple-statistics"),
				i = t("turf-inside");
			e.exports = function(t, e, o, r) {
				return t.features.forEach(function(t) {
					t.properties || (t.properties = {});
					var s = [];
					e.features.forEach(function(e) {
						i(e, t) && s.push(e.properties[o])
					}), t.properties[r] = n.variance(s)
				}), t
			}
		}, {
			"simple-statistics": 126,
			"turf-inside": 76
		}],
		126: [function(t, e, n) {
			arguments[4][59][0].apply(n, arguments)
		}, {
			dup: 59
		}],
		127: [function(t, e) {
			var n = t("turf-inside"),
				i = t("turf-featurecollection");
			e.exports = function(t, e) {
				for (var o = i([]), r = 0; r < e.features.length; r++) for (var s = 0; s < t.features.length; s++) {
					var a = n(t.features[s], e.features[r]);
					a && o.features.push(t.features[s])
				}
				return o
			}
		}, {
			"turf-featurecollection": 72,
			"turf-inside": 76
		}]
	}, {}, [1])(1)
}), !
function(t, e) {
	"object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.echarts = e() : t.echarts = e()
}(this, function() {
	return function(t) {
		function e(i) {
			if (n[i]) return n[i].exports;
			var o = n[i] = {
				exports: {},
				id: i,
				loaded: !1
			};
			return t[i].call(o.exports, o, o.exports, e), o.loaded = !0, o.exports
		}
		var n = {};
		return e.m = t, e.c = n, e.p = "", e(0)
	}([function(t, e, n) {
		t.exports = n(2), n(85), n(79), n(90), n(165), n(198), n(178), n(36), n(189), n(184), n(183), n(168), n(190), n(206)
	}, function(t, e, n) {
		function i(t) {
			if ("object" == typeof t && null !== t) {
				var e = t;
				if (t instanceof Array) {
					e = [];
					for (var n = 0, o = t.length; o > n; n++) e[n] = i(t[n])
				} else if (!b(t) && !L(t)) {
					e = {};
					for (var r in t) t.hasOwnProperty(r) && (e[r] = i(t[r]))
				}
				return e
			}
			return t
		}
		function o(t, e, n) {
			if (!S(e) || !S(t)) return n ? i(e) : t;
			for (var r in e) if (e.hasOwnProperty(r)) {
				var s = t[r],
					a = e[r];
				!S(a) || !S(s) || E(a) || E(s) || L(a) || L(s) || b(a) || b(s) ? !n && r in t || (t[r] = i(e[r], !0)) : o(s, a, n)
			}
			return t
		}
		function r(t, e) {
			for (var n = t[0], i = 1, r = t.length; r > i; i++) n = o(n, t[i], e);
			return n
		}
		function s(t, e) {
			for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
			return t
		}
		function a(t, e, n) {
			for (var i in e) e.hasOwnProperty(i) && (n ? null != e[i] : null == t[i]) && (t[i] = e[i]);
			return t
		}
		function l() {
			return document.createElement("canvas")
		}
		function u() {
			return _ || (_ = k.createCanvas().getContext("2d")), _
		}
		function p(t, e) {
			if (t) {
				if (t.indexOf) return t.indexOf(e);
				for (var n = 0, i = t.length; i > n; n++) if (t[n] === e) return n
			}
			return -1
		}
		function h(t, e) {
			function n() {}
			var i = t.prototype;
			n.prototype = e.prototype, t.prototype = new n;
			for (var o in i) t.prototype[o] = i[o];
			t.prototype.constructor = t, t.superClass = e
		}
		function c(t, e, n) {
			t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, a(t, e, n)
		}
		function g(t) {
			return t ? "string" != typeof t && "number" == typeof t.length : void 0
		}
		function d(t, e, n) {
			if (t && e) if (t.forEach && t.forEach === O) t.forEach(e, n);
			else if (t.length === +t.length) for (var i = 0, o = t.length; o > i; i++) e.call(n, t[i], i, t);
			else for (var r in t) t.hasOwnProperty(r) && e.call(n, t[r], r, t)
		}
		function f(t, e, n) {
			if (t && e) {
				if (t.map && t.map === G) return t.map(e, n);
				for (var i = [], o = 0, r = t.length; r > o; o++) i.push(e.call(n, t[o], o, t));
				return i
			}
		}
		function m(t, e, n, i) {
			if (t && e) {
				if (t.reduce && t.reduce === F) return t.reduce(e, n, i);
				for (var o = 0, r = t.length; r > o; o++) n = e.call(i, n, t[o], o, t);
				return n
			}
		}
		function y(t, e, n) {
			if (t && e) {
				if (t.filter && t.filter === D) return t.filter(e, n);
				for (var i = [], o = 0, r = t.length; r > o; o++) e.call(n, t[o], o, t) && i.push(t[o]);
				return i
			}
		}
		function v(t, e, n) {
			if (t && e) for (var i = 0, o = t.length; o > i; i++) if (e.call(n, t[i], i, t)) return t[i]
		}
		function x(t, e) {
			var n = B.call(arguments, 2);
			return function() {
				return t.apply(e, n.concat(B.call(arguments)))
			}
		}
		function j(t) {
			var e = B.call(arguments, 1);
			return function() {
				return t.apply(this, e.concat(B.call(arguments)))
			}
		}
		function E(t) {
			return "[object Array]" === T.call(t)
		}
		function I(t) {
			return "function" == typeof t
		}
		function C(t) {
			return "[object String]" === T.call(t)
		}
		function S(t) {
			var e = typeof t;
			return "function" === e || !! t && "object" == e
		}
		function b(t) {
			return !!A[T.call(t)] || t instanceof N
		}
		function L(t) {
			return t && 1 === t.nodeType && "string" == typeof t.nodeName
		}
		function w(t) {
			for (var e = 0, n = arguments.length; n > e; e++) if (null != arguments[e]) return arguments[e]
		}
		function P() {
			return Function.call.apply(B, arguments)
		}
		function M(t, e) {
			if (!t) throw new Error(e)
		}
		var _, N = n(17),
			A = {
				"[object Function]": 1,
				"[object RegExp]": 1,
				"[object Date]": 1,
				"[object Error]": 1,
				"[object CanvasGradient]": 1
			},
			T = Object.prototype.toString,
			R = Array.prototype,
			O = R.forEach,
			D = R.filter,
			B = R.slice,
			G = R.map,
			F = R.reduce,
			k = {
				inherits: h,
				mixin: c,
				clone: i,
				merge: o,
				mergeAll: r,
				extend: s,
				defaults: a,
				getContext: u,
				createCanvas: l,
				indexOf: p,
				slice: P,
				find: v,
				isArrayLike: g,
				each: d,
				map: f,
				reduce: m,
				filter: y,
				bind: x,
				curry: j,
				isArray: E,
				isString: C,
				isObject: S,
				isFunction: I,
				isBuildInObject: b,
				isDom: L,
				retrieve: w,
				assert: M,
				noop: function() {}
			};
		t.exports = k
	}, function(t, e, n) {
		function i(t) {
			return function(e, n, i) {
				e = e && e.toLowerCase(), M.prototype[t].call(this, e, n, i)
			}
		}
		function o() {
			M.call(this)
		}
		function r(t, e, n) {
			n = n || {}, "string" == typeof e && (e = z[e]), e && _(q, function(t) {
				t(e)
			}), this.id, this.group, this._dom = t, this._zr = b.init(t, {
				renderer: n.renderer || "canvas",
				devicePixelRatio: n.devicePixelRatio
			}), this._theme = L.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._api = new y(this), this._coordSysMgr = new v, M.call(this), this._messageCenter = new o, this._initEvents(), this.resize = L.bind(this.resize, this)
		}
		function s(t, e) {
			var n = this._model;
			n && n.eachComponent({
				mainType: "series",
				query: e
			}, function(i, o) {
				var r = this._chartsMap[i.__viewId];
				r && r.__alive && r[t](i, n, this._api, e)
			}, this)
		}
		function a(t, e, n) {
			var i = this._api;
			_(this._componentsViews, function(o) {
				var r = o.__model;
				o[t](r, e, i, n), d(r, o)
			}, this), e.eachSeries(function(o, r) {
				var s = this._chartsMap[o.__viewId];
				s[t](o, e, i, n), d(o, s)
			}, this)
		}
		function l(t, e) {
			for (var n = "component" === t, i = n ? this._componentsViews : this._chartsViews, o = n ? this._componentsMap : this._chartsMap, r = this._zr, s = 0; s < i.length; s++) i[s].__alive = !1;
			e[n ? "eachComponent" : "eachSeries"](function(t, s) {
				if (n) {
					if ("series" === t) return
				} else s = t;
				var a = s.id + "_" + s.type,
					l = o[a];
				if (!l) {
					var u = j.parseClassType(s.type),
						p = n ? I.getClass(u.main, u.sub) : C.getClass(u.sub);
					if (!p) return;
					l = new p, l.init(e, this._api), o[a] = l, i.push(l), r.add(l.group)
				}
				s.__viewId = a, l.__alive = !0, l.__id = a, l.__model = s
			}, this);
			for (var s = 0; s < i.length;) {
				var a = i[s];
				a.__alive ? s++ : (r.remove(a.group), a.dispose(e, this._api), i.splice(s, 1), delete o[a.__id])
			}
		}
		function u(t, e) {
			_(A, function(n) {
				_(k[n] || [], function(n) {
					n(t, e)
				})
			})
		}
		function p(t) {
			var e = {};
			t.eachSeries(function(t) {
				var n = t.get("stack"),
					i = t.getData();
				if (n && "list" === i.type) {
					var o = e[n];
					o && (i.stackedOn = o), e[n] = i
				}
			})
		}
		function h(t, e) {
			var n = this._api;
			_(F, function(i) {
				i(t, n, e)
			})
		}
		function c(t, e) {
			_(N, function(n) {
				_(V[n] || [], function(n) {
					n(t, e)
				})
			})
		}
		function g(t, e) {
			var n = this._api;
			_(this._componentsViews, function(i) {
				var o = i.__model;
				i.render(o, t, n, e), d(o, i)
			}, this), _(this._chartsViews, function(t) {
				t.__alive = !1
			}, this), t.eachSeries(function(i, o) {
				var r = this._chartsMap[i.__viewId];
				r.__alive = !0, r.render(i, t, n, e), r.group.silent = !! i.get("silent"), d(i, r)
			}, this), _(this._chartsViews, function(e) {
				e.__alive || e.remove(t, n)
			}, this)
		}
		function d(t, e) {
			var n = t.get("z"),
				i = t.get("zlevel");
			e.group.traverse(function(t) {
				null != n && (t.z = n), null != i && (t.zlevel = i)
			})
		}
		function f(t) {
			function e(t, e) {
				for (var n = 0; n < t.length; n++) {
					var i = t[n];
					i[r] = e
				}
			}
			var n = 0,
				i = 1,
				o = 2,
				r = "__connectUpdateStatus";
			L.each(G, function(s, a) {
				t._messageCenter.on(a, function(s) {
					if (U[t.group] && t[r] !== n) {
						var a = t.makeActionFromEvent(s),
							l = [];
						for (var u in H) {
							var p = H[u];
							p !== t && p.group === t.group && l.push(p)
						}
						e(l, n), _(l, function(t) {
							t[r] !== i && t.dispatchAction(a)
						}), e(l, o)
					}
				})
			})
		}
		var m = n(111),
			y = n(78),
			v = n(23),
			x = n(112),
			j = n(10),
			E = n(13),
			I = n(54),
			C = n(26),
			S = n(3),
			b = n(68),
			L = n(1),
			w = n(22),
			P = n(14),
			M = n(21),
			_ = L.each,
			N = ["echarts", "chart", "component"],
			A = ["transform", "filter", "statistic"];
		o.prototype.on = i("on"), o.prototype.off = i("off"), o.prototype.one = i("one"), L.mixin(o, M);
		var T = r.prototype;
		T.getDom = function() {
			return this._dom
		}, T.getZr = function() {
			return this._zr
		}, T.setOption = function(t, e, n) {
			this._model && !e || (this._model = new m(null, null, this._theme, new x(this._api))), this._model.setOption(t, q), R.prepareAndUpdate.call(this), !n && this._zr.refreshImmediately()
		}, T.setTheme = function() {
			console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
		}, T.getModel = function() {
			return this._model
		}, T.getOption = function() {
			return this._model.getOption()
		}, T.getWidth = function() {
			return this._zr.getWidth()
		}, T.getHeight = function() {
			return this._zr.getHeight()
		}, T.getRenderedCanvas = function(t) {
			if (P.canvasSupported) {
				t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");
				var e = this._zr,
					n = e.storage.getDisplayList();
				return L.each(n, function(t) {
					t.stopAnimation(!0)
				}), e.painter.getRenderedCanvas(t)
			}
		}, T.getDataURL = function(t) {
			t = t || {};
			var e = t.excludeComponents,
				n = this._model,
				i = [],
				o = this;
			_(e, function(t) {
				n.eachComponent({
					mainType: t
				}, function(t) {
					var e = o._componentsMap[t.__viewId];
					e.group.ignore || (i.push(e), e.group.ignore = !0)
				})
			});
			var r = this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
			return _(i, function(t) {
				t.group.ignore = !1
			}), r
		}, T.getConnectedDataURL = function(t) {
			if (P.canvasSupported) {
				var e = this.group,
					n = Math.min,
					i = Math.max,
					o = 1 / 0;
				if (U[e]) {
					var r = o,
						s = o,
						a = -o,
						l = -o,
						u = [],
						p = t && t.pixelRatio || 1;
					for (var h in H) {
						var c = H[h];
						if (c.group === e) {
							var g = c.getRenderedCanvas(L.clone(t)),
								d = c.getDom().getBoundingClientRect();
							r = n(d.left, r), s = n(d.top, s), a = i(d.right, a), l = i(d.bottom, l), u.push({
								dom: g,
								left: d.left,
								top: d.top
							})
						}
					}
					r *= p, s *= p, a *= p, l *= p;
					var f = a - r,
						m = l - s,
						y = L.createCanvas();
					y.width = f, y.height = m;
					var v = b.init(y);
					return _(u, function(t) {
						var e = new S.Image({
							style: {
								x: t.left * p - r,
								y: t.top * p - s,
								image: t.dom
							}
						});
						v.add(e)
					}), v.refreshImmediately(), y.toDataURL("image/" + (t && t.type || "png"))
				}
				return this.getDataURL(t)
			}
		};
		var R = {
			update: function(t) {
				var e = this._model,
					n = this._api,
					i = this._coordSysMgr;
				if (e) {
					e.restoreData(), i.create(this._model, this._api), u.call(this, e, n), p.call(this, e), i.update(e, n), h.call(this, e, t), c.call(this, e, t), g.call(this, e, t);
					var o = e.get("backgroundColor") || "transparent",
						r = this._zr.painter;
					if (r.isSingleCanvas && r.isSingleCanvas()) this._zr.configLayer(0, {
						clearColor: o
					});
					else {
						if (!P.canvasSupported) {
							var s = w.parse(o);
							o = w.stringify(s, "rgb"), 0 === s[3] && (o = "transparent")
						}
						o = o, this._dom.style.backgroundColor = o
					}
				}
			},
			updateView: function(t) {
				var e = this._model;
				e && (h.call(this, e, t), c.call(this, e, t), a.call(this, "updateView", e, t))
			},
			updateVisual: function(t) {
				var e = this._model;
				e && (c.call(this, e, t), a.call(this, "updateVisual", e, t))
			},
			updateLayout: function(t) {
				var e = this._model;
				e && (h.call(this, e, t), a.call(this, "updateLayout", e, t))
			},
			highlight: function(t) {
				s.call(this, "highlight", t)
			},
			downplay: function(t) {
				s.call(this, "downplay", t)
			},
			prepareAndUpdate: function(t) {
				var e = this._model;
				l.call(this, "component", e), l.call(this, "chart", e), R.update.call(this, t)
			}
		};
		T.resize = function() {
			this._zr.resize();
			var t = this._model && this._model.resetOption("media");
			R[t ? "prepareAndUpdate" : "update"].call(this), this._loadingFX && this._loadingFX.resize()
		};
		var O = n(110);
		T.showLoading = function(t, e) {
			L.isObject(t) && (e = t, t = "default"), this.hideLoading();
			var n = O(this._api, e),
				i = this._zr;
			this._loadingFX = n, i.add(n)
		}, T.hideLoading = function() {
			this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null
		}, T.makeActionFromEvent = function(t) {
			var e = L.extend({}, t);
			return e.type = G[t.type], e
		}, T.dispatchAction = function(t, e) {
			var n = B[t.type];
			if (n) {
				var i = n.actionInfo,
					o = i.update || "update",
					r = [t],
					s = !1;
				t.batch && (s = !0, r = L.map(t.batch, function(e) {
					return e = L.defaults(L.extend({}, e), t), e.batch = null, e
				}));
				for (var a, l = [], u = "highlight" === t.type || "downplay" === t.type, p = 0; p < r.length; p++) {
					var h = r[p];
					a = n.action(h, this._model), a = a || L.extend({}, h), a.type = i.event || a.type, l.push(a), u && R[o].call(this, h)
				}
				"none" !== o && !u && R[o].call(this, t), e || (a = s ? {
					type: i.event || t.type,
					batch: l
				} : l[0], this._messageCenter.trigger(a.type, a))
			}
		}, T.on = i("on"), T.off = i("off"), T.one = i("one");
		var D = ["click", "dblclick", "mouseover", "mouseout", "mousedown", "mouseup", "globalout"];
		T._initEvents = function() {
			_(D, function(t) {
				this._zr.on(t, function(e) {
					var n = this.getModel(),
						i = e.target;
					if (i && null != i.dataIndex) {
						var o = i.dataModel || n.getSeriesByIndex(i.seriesIndex),
							r = o && o.getDataParams(i.dataIndex, i.dataType) || {};
						r.event = e, r.type = t, this.trigger(t, r)
					} else i && i.eventData && this.trigger(t, i.eventData)
				}, this)
			}, this), _(G, function(t, e) {
				this._messageCenter.on(e, function(t) {
					this.trigger(e, t)
				}, this)
			}, this)
		}, T.isDisposed = function() {
			return this._disposed
		}, T.clear = function() {
			this.setOption({}, !0)
		}, T.dispose = function() {
			this._disposed = !0;
			var t = this._api,
				e = this._model;
			_(this._componentsViews, function(n) {
				n.dispose(e, t)
			}), _(this._chartsViews, function(n) {
				n.dispose(e, t)
			}), this._zr.dispose(), delete H[this.id]
		}, L.mixin(r, M);
		var B = [],
			G = {},
			F = [],
			k = {},
			q = [],
			V = {},
			z = {},
			H = {},
			U = {},
			W = new Date - 0,
			Y = new Date - 0,
			X = "_echarts_instance_",
			Q = {
				version: "3.1.10",
				dependencies: {
					zrender: "3.1.0"
				}
			};
		Q.init = function(t, e, n) {
			if (b.version.replace(".", "") - 0 < Q.dependencies.zrender.replace(".", "") - 0) throw new Error("ZRender " + b.version + " is too old for ECharts " + Q.version + ". Current version need ZRender " + Q.dependencies.zrender + "+");
			if (!t) throw new Error("Initialize failed: invalid dom.");
			var i = new r(t, e, n);
			return i.id = "ec_" + W++, H[i.id] = i, t.setAttribute && t.setAttribute(X, i.id), f(i), i
		}, Q.connect = function(t) {
			if (L.isArray(t)) {
				var e = t;
				t = null, L.each(e, function(e) {
					null != e.group && (t = e.group)
				}), t = t || "g_" + Y++, L.each(e, function(e) {
					e.group = t
				})
			}
			return U[t] = !0, t
		}, Q.disConnect = function(t) {
			U[t] = !1
		}, Q.dispose = function(t) {
			L.isDom(t) ? t = Q.getInstanceByDom(t) : "string" == typeof t && (t = H[t]), t instanceof r && !t.isDisposed() && t.dispose()
		}, Q.getInstanceByDom = function(t) {
			var e = t.getAttribute(X);
			return H[e]
		}, Q.getInstanceById = function(t) {
			return H[t]
		}, Q.registerTheme = function(t, e) {
			z[t] = e
		}, Q.registerPreprocessor = function(t) {
			q.push(t)
		}, Q.registerProcessor = function(t, e) {
			if (L.indexOf(A, t) < 0) throw new Error("stage should be one of " + A);
			var n = k[t] || (k[t] = []);
			n.push(e)
		}, Q.registerAction = function(t, e, n) {
			"function" == typeof e && (n = e, e = "");
			var i = L.isObject(t) ? t.type : [t, t = {
				event: e
			}][0];
			t.event = (t.event || i).toLowerCase(), e = t.event, B[i] || (B[i] = {
				action: n,
				actionInfo: t
			}), G[e] = i
		}, Q.registerCoordinateSystem = function(t, e) {
			v.register(t, e)
		}, Q.registerLayout = function(t) {
			L.indexOf(F, t) < 0 && F.push(t)
		}, Q.registerVisualCoding = function(t, e) {
			if (L.indexOf(N, t) < 0) throw new Error("stage should be one of " + N);
			var n = V[t] || (V[t] = []);
			n.push(e)
		}, Q.extendChartView = function(t) {
			return C.extend(t)
		}, Q.extendComponentModel = function(t) {
			return j.extend(t)
		}, Q.extendSeriesModel = function(t) {
			return E.extend(t)
		}, Q.extendComponentView = function(t) {
			return I.extend(t)
		}, Q.setCanvasCreator = function(t) {
			L.createCanvas = t
		}, Q.registerVisualCoding("echarts", L.curry(n(74), "", "itemStyle")), Q.registerPreprocessor(n(119)), Q.registerAction({
			type: "highlight",
			event: "highlight",
			update: "highlight"
		}, L.noop), Q.registerAction({
			type: "downplay",
			event: "downplay",
			update: "downplay"
		}, L.noop), Q.graphic = n(3), Q.number = n(4), Q.format = n(9), Q.matrix = n(19), Q.vector = n(5), Q.util = {}, _(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend"], function(t) {
			Q.util[t] = L[t]
		}), t.exports = Q
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			return null != t && "none" != t
		}
		function o(t) {
			return t instanceof C ? t : j.lift(t, -.1)
		}
		function r(t) {
			if (t.__hoverStlDirty) {
				var e = t.style.stroke,
					n = t.style.fill,
					r = t.__hoverStl;
				r.fill = r.fill || (i(n) ? o(n) : null), r.stroke = r.stroke || (i(e) ? o(e) : null);
				var s = {};
				for (var a in r) r.hasOwnProperty(a) && (s[a] = t.style[a]);
				t.__normalStl = s, t.__hoverStlDirty = !1
			}
		}
		function s(t) {
			t.__isHover || (r(t), t.setStyle(t.__hoverStl), t.z2 += 1, t.__isHover = !0)
		}
		function a(t) {
			if (t.__isHover) {
				var e = t.__normalStl;
				e && t.setStyle(e), t.z2 -= 1, t.__isHover = !1
			}
		}
		function l(t) {
			"group" === t.type ? t.traverse(function(t) {
				"group" !== t.type && s(t)
			}) : s(t)
		}
		function u(t) {
			"group" === t.type ? t.traverse(function(t) {
				"group" !== t.type && a(t)
			}) : a(t)
		}
		function p(t, e) {
			t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0, t.__isHover && r(t)
		}
		function h() {
			!this.__isEmphasis && l(this)
		}
		function c() {
			!this.__isEmphasis && u(this)
		}
		function g() {
			this.__isEmphasis = !0, l(this)
		}
		function d() {
			this.__isEmphasis = !1, u(this)
		}
		function f(t, e, n, i, o, r) {
			"function" == typeof o && (r = o, o = null);
			var s = t ? "Update" : "",
				a = i && i.getShallow("animationDuration" + s),
				l = i && i.getShallow("animationEasing" + s),
				u = i && i.getShallow("animationDelay" + s);
			"function" == typeof u && (u = u(o)), i && i.getShallow("animation") ? e.animateTo(n, a, u || 0, l, r) : (e.attr(n), r && r())
		}
		var m = n(1),
			y = n(156),
			v = Math.round,
			x = n(6),
			j = n(22),
			E = n(19),
			I = n(5),
			C = n(17),
			S = {};
		S.Group = n(27), S.Image = n(46), S.Text = n(66), S.Circle = n(147), S.Sector = n(153), S.Ring = n(152), S.Polygon = n(149), S.Polyline = n(150), S.Rect = n(151), S.Line = n(148), S.BezierCurve = n(146), S.Arc = n(145), S.CompoundPath = n(140), S.LinearGradient = n(76), S.RadialGradient = n(141), S.BoundingRect = n(8), S.extendShape = function(t) {
			return x.extend(t)
		}, S.extendPath = function(t, e) {
			return y.extendFromString(t, e)
		}, S.makePath = function(t, e, n, i) {
			var o = y.createFromString(t, e),
				r = o.getBoundingRect();
			if (n) {
				var s = r.width / r.height;
				if ("center" === i) {
					var a, l = n.height * s;
					l <= n.width ? a = n.height : (l = n.width, a = l / s);
					var u = n.x + n.width / 2,
						p = n.y + n.height / 2;
					n.x = u - l / 2, n.y = p - a / 2, n.width = l, n.height = a
				}
				this.resizePath(o, n)
			}
			return o
		}, S.mergePath = y.mergePath, S.resizePath = function(t, e) {
			if (t.applyTransform) {
				var n = t.getBoundingRect(),
					i = n.calculateTransform(e);
				t.applyTransform(i)
			}
		}, S.subPixelOptimizeLine = function(t) {
			var e = S.subPixelOptimize,
				n = t.shape,
				i = t.style.lineWidth;
			return v(2 * n.x1) === v(2 * n.x2) && (n.x1 = n.x2 = e(n.x1, i, !0)), v(2 * n.y1) === v(2 * n.y2) && (n.y1 = n.y2 = e(n.y1, i, !0)), t
		}, S.subPixelOptimizeRect = function(t) {
			var e = S.subPixelOptimize,
				n = t.shape,
				i = t.style.lineWidth,
				o = n.x,
				r = n.y,
				s = n.width,
				a = n.height;
			return n.x = e(n.x, i, !0), n.y = e(n.y, i, !0), n.width = Math.max(e(o + s, i, !1) - n.x, 0 === s ? 0 : 1), n.height = Math.max(e(r + a, i, !1) - n.y, 0 === a ? 0 : 1), t
		}, S.subPixelOptimize = function(t, e, n) {
			var i = v(2 * t);
			return (i + v(e)) % 2 === 0 ? i / 2 : (i + (n ? 1 : -1)) / 2
		}, S.setHoverStyle = function(t, e) {
			"group" === t.type ? t.traverse(function(t) {
				"group" !== t.type && p(t, e)
			}) : p(t, e), t.on("mouseover", h).on("mouseout", c), t.on("emphasis", g).on("normal", d)
		}, S.setText = function(t, e, n) {
			var i = e.getShallow("position") || "inside",
				o = i.indexOf("inside") >= 0 ? "white" : n,
				r = e.getModel("textStyle");
			m.extend(t, {
				textDistance: e.getShallow("distance") || 5,
				textFont: r.getFont(),
				textPosition: i,
				textFill: r.getTextColor() || o
			})
		}, S.updateProps = m.curry(f, !0), S.initProps = m.curry(f, !1), S.getTransform = function(t, e) {
			for (var n = E.identity([]); t && t !== e;) E.mul(n, t.getLocalTransform(), n), t = t.parent;
			return n
		}, S.applyTransform = function(t, e, n) {
			return n && (e = E.invert([], e)), I.applyTransform([], t, e)
		}, S.transformDirection = function(t, e, n) {
			var i = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
				o = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
				r = ["left" === t ? -i : "right" === t ? i : 0, "top" === t ? -o : "bottom" === t ? o : 0];
			return r = S.applyTransform(r, e, n), Math.abs(r[0]) > Math.abs(r[1]) ? r[0] > 0 ? "right" : "left" : r[1] > 0 ? "bottom" : "top"
		}, t.exports = S
	}, function(t, e) {
		function n(t) {
			return t.replace(/^\s+/, "").replace(/\s+$/, "")
		}
		var i = {},
			o = 1e-4;
		i.linearMap = function(t, e, n, i) {
			var o = e[1] - e[0],
				r = n[1] - n[0];
			if (0 === o) return 0 === r ? n[0] : (n[0] + n[1]) / 2;
			if (i) if (o > 0) {
				if (t <= e[0]) return n[0];
				if (t >= e[1]) return n[1]
			} else {
				if (t >= e[0]) return n[0];
				if (t <= e[1]) return n[1]
			} else {
				if (t === e[0]) return n[0];
				if (t === e[1]) return n[1]
			}
			return (t - e[0]) / o * r + n[0]
		}, i.parsePercent = function(t, e) {
			switch (t) {
			case "center":
			case "middle":
				t = "50%";
				break;
			case "left":
			case "top":
				t = "0%";
				break;
			case "right":
			case "bottom":
				t = "100%"
			}
			return "string" == typeof t ? n(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? NaN : +t
		}, i.round = function(t) {
			return +(+t).toFixed(10)
		}, i.asc = function(t) {
			return t.sort(function(t, e) {
				return t - e
			}), t
		}, i.getPrecision = function(t) {
			if (isNaN(t)) return 0;
			for (var e = 1, n = 0; Math.round(t * e) / e !== t;) e *= 10, n++;
			return n
		}, i.getPixelPrecision = function(t, e) {
			var n = Math.log,
				i = Math.LN10,
				o = Math.floor(n(t[1] - t[0]) / i),
				r = Math.round(n(Math.abs(e[1] - e[0])) / i);
			return Math.max(-o + r, 0)
		}, i.MAX_SAFE_INTEGER = 9007199254740991, i.remRadian = function(t) {
			var e = 2 * Math.PI;
			return (t % e + e) % e
		}, i.isRadianAroundZero = function(t) {
			return t > -o && o > t
		}, i.parseDate = function(t) {
			return t instanceof Date ? t : new Date("string" == typeof t ? t.replace(/-/g, "/") : Math.round(t))
		}, i.quantity = function(t) {
			return Math.pow(10, Math.floor(Math.log(t) / Math.LN10))
		}, i.nice = function(t, e) {
			var n, o = i.quantity(t),
				r = t / o;
			return n = e ? 1.5 > r ? 1 : 2.5 > r ? 2 : 4 > r ? 3 : 7 > r ? 5 : 10 : 1 > r ? 1 : 2 > r ? 2 : 3 > r ? 3 : 5 > r ? 5 : 10, n * o
		}, t.exports = i
	}, function(t, e) {
		var n = "undefined" == typeof Float32Array ? Array : Float32Array,
			i = {
				create: function(t, e) {
					var i = new n(2);
					return i[0] = t || 0, i[1] = e || 0, i
				},
				copy: function(t, e) {
					return t[0] = e[0], t[1] = e[1], t
				},
				clone: function(t) {
					var e = new n(2);
					return e[0] = t[0], e[1] = t[1], e
				},
				set: function(t, e, n) {
					return t[0] = e, t[1] = n, t
				},
				add: function(t, e, n) {
					return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t
				},
				scaleAndAdd: function(t, e, n, i) {
					return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t
				},
				sub: function(t, e, n) {
					return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t
				},
				len: function(t) {
					return Math.sqrt(this.lenSquare(t))
				},
				lenSquare: function(t) {
					return t[0] * t[0] + t[1] * t[1]
				},
				mul: function(t, e, n) {
					return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t
				},
				div: function(t, e, n) {
					return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t
				},
				dot: function(t, e) {
					return t[0] * e[0] + t[1] * e[1]
				},
				scale: function(t, e, n) {
					return t[0] = e[0] * n, t[1] = e[1] * n, t
				},
				normalize: function(t, e) {
					var n = i.len(e);
					return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / n, t[1] = e[1] / n), t
				},
				distance: function(t, e) {
					return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
				},
				distanceSquare: function(t, e) {
					return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
				},
				negate: function(t, e) {
					return t[0] = -e[0], t[1] = -e[1], t
				},
				lerp: function(t, e, n, i) {
					return t[0] = e[0] + i * (n[0] - e[0]), t[1] = e[1] + i * (n[1] - e[1]), t
				},
				applyTransform: function(t, e, n) {
					var i = e[0],
						o = e[1];
					return t[0] = n[0] * i + n[2] * o + n[4], t[1] = n[1] * i + n[3] * o + n[5], t
				},
				min: function(t, e, n) {
					return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t
				},
				max: function(t, e, n) {
					return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t
				}
			};
		i.length = i.len, i.lengthSquare = i.lenSquare, i.dist = i.distance, i.distSquare = i.distanceSquare, t.exports = i
	}, function(t, e, n) {
		function i(t) {
			var e = t.fill;
			return null != e && "none" !== e
		}
		function o(t) {
			var e = t.stroke;
			return null != e && "none" !== e && t.lineWidth > 0
		}
		function r(t) {
			s.call(this, t), this.path = new l
		}
		var s = n(37),
			a = n(1),
			l = n(28),
			u = n(136),
			p = (n(17), Math.abs);
		r.prototype = {
			constructor: r,
			type: "path",
			__dirtyPath: !0,
			strokeContainThreshold: 5,
			brush: function(t) {
				t.save();
				var e = this.style,
					n = this.path,
					r = o(e),
					s = i(e),
					a = s && !! e.fill.colorStops,
					l = r && !! e.stroke.colorStops;
				if (e.bind(t, this), this.setTransform(t), this.__dirtyPath) {
					var u = this.getBoundingRect();
					a && (this._fillGradient = e.getGradient(t, e.fill, u)), l && (this._strokeGradient = e.getGradient(t, e.stroke, u))
				}
				a && (t.fillStyle = this._fillGradient), l && (t.strokeStyle = this._strokeGradient);
				var p = e.lineDash,
					h = e.lineDashOffset,
					c = !! t.setLineDash,
					g = this.getGlobalScale();
				n.setScale(g[0], g[1]), this.__dirtyPath || p && !c && r ? (n = this.path.beginPath(t), p && !c && (n.setLineDash(p), n.setLineDashOffset(h)), this.buildPath(n, this.shape), this.__dirtyPath = !1) : (t.beginPath(), this.path.rebuildPath(t)), s && n.fill(t), p && c && (t.setLineDash(p), t.lineDashOffset = h), r && n.stroke(t), null != e.text && this.drawRectText(t, this.getBoundingRect()), t.restore()
			},
			buildPath: function(t, e) {},
			getBoundingRect: function() {
				var t = this._rect,
					e = this.style,
					n = !t;
				if (n) {
					var r = this.path;
					this.__dirtyPath && (r.beginPath(), this.buildPath(r, this.shape)), t = r.getBoundingRect()
				}
				if (this._rect = t, o(e)) {
					var s = this._rectWithStroke || (this._rectWithStroke = t.clone());
					if (this.__dirty || n) {
						s.copy(t);
						var a = e.lineWidth,
							l = e.strokeNoScale ? this.getLineScale() : 1;
						i(e) || (a = Math.max(a, this.strokeContainThreshold)), l > 1e-10 && (s.width += a / l, s.height += a / l, s.x -= a / l / 2, s.y -= a / l / 2)
					}
					return s
				}
				return t
			},
			contain: function(t, e) {
				var n = this.transformCoordToLocal(t, e),
					r = this.getBoundingRect(),
					s = this.style;
				if (t = n[0], e = n[1], r.contain(t, e)) {
					var a = this.path.data;
					if (o(s)) {
						var l = s.lineWidth,
							p = s.strokeNoScale ? this.getLineScale() : 1;
						if (p > 1e-10 && (i(s) || (l = Math.max(l, this.strokeContainThreshold)), u.containStroke(a, l / p, t, e))) return !0
					}
					if (i(s)) return u.contain(a, t, e)
				}
				return !1
			},
			dirty: function(t) {
				0 === arguments.length && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty()
			},
			animateShape: function(t) {
				return this.animate("shape", t)
			},
			attrKV: function(t, e) {
				"shape" === t ? this.setShape(e) : s.prototype.attrKV.call(this, t, e)
			},
			setShape: function(t, e) {
				var n = this.shape;
				if (n) {
					if (a.isObject(t)) for (var i in t) n[i] = t[i];
					else n[t] = e;
					this.dirty(!0)
				}
				return this
			},
			getLineScale: function() {
				var t = this.transform;
				return t && p(t[0] - 1) > 1e-10 && p(t[3] - 1) > 1e-10 ? Math.sqrt(p(t[0] * t[3] - t[2] * t[1])) : 1
			}
		}, r.extend = function(t) {
			var e = function(e) {
					r.call(this, e), t.style && this.style.extendFrom(t.style, !1);
					var n = t.shape;
					if (n) {
						this.shape = this.shape || {};
						var i = this.shape;
						for (var o in n)!i.hasOwnProperty(o) && n.hasOwnProperty(o) && (i[o] = n[o])
					}
					t.init && t.init.call(this, e)
				};
			a.inherits(e, r);
			for (var n in t)"style" !== n && "shape" !== n && (e.prototype[n] = t[n]);
			return e
		}, a.inherits(r, s), t.exports = r
	}, function(t, e, n) {
		var i = n(9),
			o = n(4),
			r = n(1),
			s = ["x", "y", "z", "radius", "angle"],
			a = {};
		a.createNameEach = function(t, e) {
			t = t.slice();
			var n = r.map(t, a.capitalFirst);
			e = (e || []).slice();
			var i = r.map(e, a.capitalFirst);
			return function(o, s) {
				r.each(t, function(t, r) {
					for (var a = {
						name: t,
						capital: n[r]
					}, l = 0; l < e.length; l++) a[e[l]] = t + i[l];
					o.call(s, a)
				})
			}
		}, a.capitalFirst = function(t) {
			return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
		}, a.eachAxisDim = a.createNameEach(s, ["axisIndex", "axis", "index"]), a.normalizeToArray = function(t) {
			return r.isArray(t) ? t : null == t ? [] : [t]
		}, a.createLinkedNodesFinder = function(t, e, n) {
			function i(t, e) {
				return r.indexOf(e.nodes, t) >= 0
			}
			function o(t, i) {
				var o = !1;
				return e(function(e) {
					r.each(n(t, e) || [], function(t) {
						i.records[e.name][t] && (o = !0)
					})
				}), o
			}
			function s(t, i) {
				i.nodes.push(t), e(function(e) {
					r.each(n(t, e) || [], function(t) {
						i.records[e.name][t] = !0
					})
				})
			}
			return function(n) {
				function r(t) {
					!i(t, a) && o(t, a) && (s(t, a), l = !0)
				}
				var a = {
					nodes: [],
					records: {}
				};
				if (e(function(t) {
					a.records[t.name] = {}
				}), !n) return a;
				s(n, a);
				var l;
				do l = !1, t(r);
				while (l);
				return a
			}
		}, a.defaultEmphasis = function(t, e) {
			if (t) {
				var n = t.emphasis = t.emphasis || {},
					i = t.normal = t.normal || {};
				r.each(e, function(t) {
					var e = r.retrieve(n[t], i[t]);
					null != e && (n[t] = e)
				})
			}
		}, a.LABEL_OPTIONS = ["position", "show", "textStyle", "distance", "formatter"], a.getDataItemValue = function(t) {
			return t && (null == t.value ? t : t.value)
		}, a.converDataValue = function(t, e) {
			var n = e && e.type;
			return "ordinal" === n ? t : ("time" !== n || isFinite(t) || null == t || "-" === t || (t = +o.parseDate(t)), null == t || "" === t ? NaN : +t)
		}, a.dataFormatMixin = {
			getDataParams: function(t, e) {
				var n = this.getData(e),
					i = this.seriesIndex,
					o = this.name,
					r = this.getRawValue(t, e),
					s = n.getRawIndex(t),
					a = n.getName(t, !0),
					l = n.getRawDataItem(t);
				return {
					componentType: this.mainType,
					componentSubType: this.subType,
					seriesType: "series" === this.mainType ? this.subType : null,
					seriesIndex: i,
					seriesName: o,
					name: a,
					dataIndex: s,
					data: l,
					dataType: e,
					value: r,
					color: n.getItemVisual(t, "color"),
					$vars: ["seriesName", "name", "value"]
				}
			},
			getFormattedLabel: function(t, e, n, o) {
				e = e || "normal";
				var s = this.getData(n),
					a = s.getItemModel(t),
					l = this.getDataParams(t, n);
				null != o && r.isArray(l.value) && (l.value = l.value[o]);
				var u = a.get(["label", e, "formatter"]);
				return "function" == typeof u ? (l.status = e, u(l)) : "string" == typeof u ? i.formatTpl(u, l) : void 0
			},
			getRawValue: function(t, e) {
				var n = this.getData(e),
					i = n.getRawDataItem(t);
				return null != i ? r.isObject(i) && !r.isArray(i) ? i.value : i : void 0
			},
			formatTooltip: r.noop
		}, a.mappingToExists = function(t, e) {
			e = (e || []).slice();
			var n = r.map(t || [], function(t, e) {
				return {
					exist: t
				}
			});
			return r.each(e, function(t, i) {
				if (r.isObject(t)) for (var o = 0; o < n.length; o++) {
					var s = n[o].exist;
					if (!n[o].option && (null != t.id && s.id === t.id + "" || null != t.name && !a.isIdInner(t) && !a.isIdInner(s) && s.name === t.name + "")) {
						n[o].option = t, e[i] = null;
						break
					}
				}
			}), r.each(e, function(t, e) {
				if (r.isObject(t)) {
					for (var i = 0; i < n.length; i++) {
						var o = n[i].exist;
						if (!n[i].option && !a.isIdInner(o) && null == t.id) {
							n[i].option = t;
							break
						}
					}
					i >= n.length && n.push({
						option: t
					})
				}
			}), n
		}, a.isIdInner = function(t) {
			return r.isObject(t) && t.id && 0 === (t.id + "").indexOf("\0_ec_\0")
		}, t.exports = a
	}, function(t, e, n) {
		"use strict";

		function i(t, e, n, i) {
			this.x = t, this.y = e, this.width = n, this.height = i
		}
		var o = n(5),
			r = n(19),
			s = o.applyTransform,
			a = Math.min,
			l = Math.abs,
			u = Math.max;
		i.prototype = {
			constructor: i,
			union: function(t) {
				var e = a(t.x, this.x),
					n = a(t.y, this.y);
				this.width = u(t.x + t.width, this.x + this.width) - e, this.height = u(t.y + t.height, this.y + this.height) - n, this.x = e, this.y = n
			},
			applyTransform: function() {
				var t = [],
					e = [];
				return function(n) {
					n && (t[0] = this.x, t[1] = this.y, e[0] = this.x + this.width, e[1] = this.y + this.height, s(t, t, n), s(e, e, n), this.x = a(t[0], e[0]), this.y = a(t[1], e[1]), this.width = l(e[0] - t[0]), this.height = l(e[1] - t[1]))
				}
			}(),
			calculateTransform: function(t) {
				var e = this,
					n = t.width / e.width,
					i = t.height / e.height,
					o = r.create();
				return r.translate(o, o, [-e.x, -e.y]), r.scale(o, o, [n, i]), r.translate(o, o, [t.x, t.y]), o
			},
			intersect: function(t) {
				var e = this,
					n = e.x,
					i = e.x + e.width,
					o = e.y,
					r = e.y + e.height,
					s = t.x,
					a = t.x + t.width,
					l = t.y,
					u = t.y + t.height;
				return !(s > i || n > a || l > r || o > u)
			},
			contain: function(t, e) {
				var n = this;
				return t >= n.x && t <= n.x + n.width && e >= n.y && e <= n.y + n.height
			},
			clone: function() {
				return new i(this.x, this.y, this.width, this.height)
			},
			copy: function(t) {
				this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height
			}
		}, t.exports = i
	}, function(t, e, n) {
		function i(t) {
			return isNaN(t) ? "-" : (t = (t + "").split("."), t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : ""))
		}
		function o(t) {
			return t.toLowerCase().replace(/-(.)/g, function(t, e) {
				return e.toUpperCase()
			})
		}
		function r(t) {
			var e = t.length;
			return "number" == typeof t ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
		}
		function s(t) {
			return String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;")
		}
		function a(t, e) {
			return "{" + t + (null == e ? "" : e) + "}"
		}
		function l(t, e) {
			h.isArray(e) || (e = [e]);
			var n = e.length;
			if (!n) return "";
			for (var i = e[0].$vars, o = 0; o < i.length; o++) {
				var r = g[o];
				t = t.replace(a(r), a(r, 0))
			}
			for (var s = 0; n > s; s++) for (var l = 0; l < i.length; l++) t = t.replace(a(g[l], s), e[s][i[l]]);
			return t
		}
		function u(t, e) {
			"week" !== t && "month" !== t && "quarter" !== t && "half-year" !== t && "year" !== t || (t = "MM-dd\nyyyy");
			var n = c.parseDate(e),
				i = n.getFullYear(),
				o = n.getMonth() + 1,
				r = n.getDate(),
				s = n.getHours(),
				a = n.getMinutes(),
				l = n.getSeconds();
			return t = t.replace("MM", p(o)).toLowerCase().replace("yyyy", i).replace("yy", i % 100).replace("dd", p(r)).replace("d", r).replace("hh", p(s)).replace("h", s).replace("mm", p(a)).replace("m", a).replace("ss", p(l)).replace("s", l)
		}
		function p(t) {
			return 10 > t ? "0" + t : t
		}
		var h = n(1),
			c = n(4),
			g = ["a", "b", "c", "d", "e", "f", "g"];
		t.exports = {
			normalizeCssArray: r,
			addCommas: i,
			toCamelCase: o,
			encodeHTML: s,
			formatTpl: l,
			formatTime: u
		}
	}, function(t, e, n) {
		function i(t) {
			var e = [];
			return r.each(p.getClassesByMainType(t), function(t) {
				s.apply(e, t.prototype.dependencies || [])
			}), r.map(e, function(t) {
				return l.parseClassType(t).main
			})
		}
		var o = n(12),
			r = n(1),
			s = Array.prototype.push,
			a = n(42),
			l = n(20),
			u = n(11),
			p = o.extend({
				type: "component",
				id: "",
				name: "",
				mainType: "",
				subType: "",
				componentIndex: 0,
				defaultOption: null,
				ecModel: null,
				dependentModels: [],
				uid: null,
				layoutMode: null,
				init: function(t, e, n, i) {
					this.mergeDefaultAndTheme(this.option, this.ecModel)
				},
				mergeDefaultAndTheme: function(t, e) {
					var n = this.layoutMode,
						i = n ? u.getLayoutParams(t) : {},
						o = e.getTheme();
					r.merge(t, o.get(this.mainType)), r.merge(t, this.getDefaultOption()), n && u.mergeLayoutParam(t, i, n)
				},
				mergeOption: function(t) {
					r.merge(this.option, t, !0);
					var e = this.layoutMode;
					e && u.mergeLayoutParam(this.option, t, e)
				},
				optionUpdated: function(t) {},
				getDefaultOption: function() {
					if (!this.hasOwnProperty("__defaultOption")) {
						for (var t = [], e = this.constructor; e;) {
							var n = e.prototype.defaultOption;
							n && t.push(n), e = e.superClass
						}
						for (var i = {}, o = t.length - 1; o >= 0; o--) i = r.merge(i, t[o], !0);
						this.__defaultOption = i
					}
					return this.__defaultOption
				}
			});
		l.enableClassExtend(p, function(t, e, n, i) {
			r.extend(this, i), this.uid = a.getUID("componentModel")
		}), l.enableClassManagement(p, {
			registerWhenExtend: !0
		}), a.enableSubTypeDefaulter(p), a.enableTopologicalTravel(p, i), r.mixin(p, n(115)), t.exports = p
	}, function(t, e, n) {
		"use strict";

		function i(t, e, n, i, o) {
			var r = 0,
				s = 0;
			null == i && (i = 1 / 0), null == o && (o = 1 / 0);
			var a = 0;
			e.eachChild(function(l, u) {
				var p, h, c = l.position,
					g = l.getBoundingRect(),
					d = e.childAt(u + 1),
					f = d && d.getBoundingRect();
				if ("horizontal" === t) {
					var m = g.width + (f ? -f.x + g.x : 0);
					p = r + m, p > i || l.newline ? (r = 0, p = m, s += a + n, a = g.height) : a = Math.max(a, g.height)
				} else {
					var y = g.height + (f ? -f.y + g.y : 0);
					h = s + y, h > o || l.newline ? (r += a + n, s = 0, h = y, a = g.width) : a = Math.max(a, g.width)
				}
				l.newline || (c[0] = r, c[1] = s, "horizontal" === t ? r = p + n : s = h + n)
			})
		}
		var o = n(1),
			r = n(8),
			s = n(4),
			a = n(9),
			l = s.parsePercent,
			u = o.each,
			p = {},
			h = ["left", "right", "top", "bottom", "width", "height"];
		p.box = i, p.vbox = o.curry(i, "vertical"), p.hbox = o.curry(i, "horizontal"), p.getAvailableSize = function(t, e, n) {
			var i = e.width,
				o = e.height,
				r = l(t.x, i),
				s = l(t.y, o),
				u = l(t.x2, i),
				p = l(t.y2, o);
			return (isNaN(r) || isNaN(parseFloat(t.x))) && (r = 0), (isNaN(u) || isNaN(parseFloat(t.x2))) && (u = i), (isNaN(s) || isNaN(parseFloat(t.y))) && (s = 0), (isNaN(p) || isNaN(parseFloat(t.y2))) && (p = o), n = a.normalizeCssArray(n || 0), {
				width: Math.max(u - r - n[1] - n[3], 0),
				height: Math.max(p - s - n[0] - n[2], 0)
			}
		}, p.getLayoutRect = function(t, e, n) {
			n = a.normalizeCssArray(n || 0);
			var i = e.width,
				o = e.height,
				s = l(t.left, i),
				u = l(t.top, o),
				p = l(t.right, i),
				h = l(t.bottom, o),
				c = l(t.width, i),
				g = l(t.height, o),
				d = n[2] + n[0],
				f = n[1] + n[3],
				m = t.aspect;
			switch (isNaN(c) && (c = i - p - f - s), isNaN(g) && (g = o - h - d - u), isNaN(c) && isNaN(g) && (m > i / o ? c = .8 * i : g = .8 * o), null != m && (isNaN(c) && (c = m * g), isNaN(g) && (g = c / m)), isNaN(s) && (s = i - p - c - f), isNaN(u) && (u = o - h - g - d), t.left || t.right) {
			case "center":
				s = i / 2 - c / 2 - n[3];
				break;
			case "right":
				s = i - c - f
			}
			switch (t.top || t.bottom) {
			case "middle":
			case "center":
				u = o / 2 - g / 2 - n[0];
				break;
			case "bottom":
				u = o - g - d
			}
			s = s || 0, u = u || 0, isNaN(c) && (c = i - s - (p || 0)), isNaN(g) && (g = o - u - (h || 0));
			var y = new r(s + n[3], u + n[0], c, g);
			return y.margin = n, y
		}, p.positionGroup = function(t, e, n, i) {
			var r = t.getBoundingRect();
			e = o.extend(o.clone(e), {
				width: r.width,
				height: r.height
			}), e = p.getLayoutRect(e, n, i), t.position = [e.x - r.x, e.y - r.y]
		}, p.mergeLayoutParam = function(t, e, n) {
			function i(i) {
				var o = {},
					a = 0,
					l = {},
					p = 0,
					h = n.ignoreSize ? 1 : 2;
				if (u(i, function(e) {
					l[e] = t[e]
				}), u(i, function(t) {
					r(e, t) && (o[t] = l[t] = e[t]), s(o, t) && a++, s(l, t) && p++
				}), p !== h && a) {
					if (a >= h) return o;
					for (var c = 0; c < i.length; c++) {
						var g = i[c];
						if (!r(o, g) && r(t, g)) {
							o[g] = t[g];
							break
						}
					}
					return o
				}
				return l
			}
			function r(t, e) {
				return t.hasOwnProperty(e)
			}
			function s(t, e) {
				return null != t[e] && "auto" !== t[e]
			}
			function a(t, e, n) {
				u(t, function(t) {
					e[t] = n[t]
				})
			}!o.isObject(n) && (n = {});
			var l = ["width", "left", "right"],
				p = ["height", "top", "bottom"],
				h = i(l),
				c = i(p);
			a(l, t, h), a(p, t, c)
		}, p.getLayoutParams = function(t) {
			return p.copyLayoutParams({}, t)
		}, p.copyLayoutParams = function(t, e) {
			return e && t && u(h, function(n) {
				e.hasOwnProperty(n) && (t[n] = e[n])
			}), t
		}, t.exports = p
	}, function(t, e, n) {
		function i(t, e, n, i) {
			this.parentModel = e, this.ecModel = n, this.option = t, this.init && (arguments.length <= 4 ? this.init(t, e, n, i) : this.init.apply(this, arguments))
		}
		var o = n(1),
			r = n(20);
		i.prototype = {
			constructor: i,
			init: null,
			mergeOption: function(t) {
				o.merge(this.option, t, !0)
			},
			get: function(t, e) {
				if (!t) return this.option;
				"string" == typeof t && (t = t.split("."));
				for (var n = this.option, i = this.parentModel, o = 0; o < t.length && (!t[o] || (n = n && "object" == typeof n ? n[t[o]] : null, null != n)); o++);
				return null == n && i && !e && (n = i.get(t)), n
			},
			getShallow: function(t, e) {
				var n = this.option,
					i = n && n[t],
					o = this.parentModel;
				return null == i && o && !e && (i = o.getShallow(t)), i
			},
			getModel: function(t, e) {
				var n = this.get(t, !0),
					o = this.parentModel,
					r = new i(n, e || o && o.getModel(t), this.ecModel);
				return r
			},
			isEmpty: function() {
				return null == this.option
			},
			restoreData: function() {},
			clone: function() {
				var t = this.constructor;
				return new t(o.clone(this.option))
			},
			setReadOnly: function(t) {
				r.setReadOnly(this, t)
			}
		}, r.enableClassExtend(i);
		var s = o.mixin;
		s(i, n(117)), s(i, n(114)), s(i, n(118)), s(i, n(116)), t.exports = i
	}, function(t, e, n) {
		"use strict";
		var i = n(1),
			o = n(9),
			r = n(7),
			s = n(10),
			a = o.encodeHTML,
			l = o.addCommas,
			u = s.extend({
				type: "series.__base__",
				seriesIndex: 0,
				coordinateSystem: null,
				defaultOption: null,
				legendDataProvider: null,
				init: function(t, e, n, i) {
					this.seriesIndex = this.componentIndex, this.mergeDefaultAndTheme(t, n), this._dataBeforeProcessed = this.getInitialData(t, n), this._data = this._dataBeforeProcessed.cloneShallow()
				},
				mergeDefaultAndTheme: function(t, e) {
					i.merge(t, e.getTheme().get(this.subType)), i.merge(t, this.getDefaultOption()), r.defaultEmphasis(t.label, r.LABEL_OPTIONS), this.fillDataTextStyle(t.data)
				},
				mergeOption: function(t, e) {
					t = i.merge(this.option, t, !0), this.fillDataTextStyle(t.data);
					var n = this.getInitialData(t, e);
					n && (this._data = n, this._dataBeforeProcessed = n.cloneShallow())
				},
				fillDataTextStyle: function(t) {
					if (t) for (var e = 0; e < t.length; e++) t[e] && t[e].label && r.defaultEmphasis(t[e].label, r.LABEL_OPTIONS)
				},
				getInitialData: function() {},
				getData: function(t) {
					return null == t ? this._data : this._data.getLinkedData(t)
				},
				setData: function(t) {
					this._data = t
				},
				getRawData: function() {
					return this._dataBeforeProcessed
				},
				coordDimToDataDim: function(t) {
					return [t]
				},
				dataDimToCoordDim: function(t) {
					return t
				},
				getBaseAxis: function() {
					var t = this.coordinateSystem;
					return t && t.getBaseAxis && t.getBaseAxis()
				},
				formatTooltip: function(t, e, n) {
					var o = this._data,
						r = this.getRawValue(t),
						s = i.isArray(r) ? i.map(r, l).join(", ") : l(r),
						u = o.getName(t),
						p = o.getItemVisual(t, "color"),
						h = '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + p + '"></span>',
						c = this.name;
					return "\0-" === c && (c = ""), e ? h + a(this.name) + " : " + s : (c && a(c) + "<br />") + h + (u ? a(u) + " : " + s : s)
				},
				restoreData: function() {
					this._data = this._dataBeforeProcessed.cloneShallow()
				},
				getAxisTooltipDataIndex: null
			});
		i.mixin(u, r.dataFormatMixin), t.exports = u
	}, function(t, e) {
		function n(t) {
			var e = {},
				n = {},
				i = t.match(/Web[kK]it[\/]{0,1}([\d.]+)/),
				o = t.match(/(Android);?[\s\/]+([\d.]+)?/),
				r = t.match(/(iPad).*OS\s([\d_]+)/),
				s = t.match(/(iPod)(.*OS\s([\d_]+))?/),
				a = !r && t.match(/(iPhone\sOS)\s([\d_]+)/),
				l = t.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),
				u = l && t.match(/TouchPad/),
				p = t.match(/Kindle\/([\d.]+)/),
				h = t.match(/Silk\/([\d._]+)/),
				c = t.match(/(BlackBerry).*Version\/([\d.]+)/),
				g = t.match(/(BB10).*Version\/([\d.]+)/),
				d = t.match(/(RIM\sTablet\sOS)\s([\d.]+)/),
				f = t.match(/PlayBook/),
				m = t.match(/Chrome\/([\d.]+)/) || t.match(/CriOS\/([\d.]+)/),
				y = t.match(/Firefox\/([\d.]+)/),
				v = i && t.match(/Mobile\//) && !m,
				x = t.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !m,
				j = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/),
				E = t.match(/Edge\/([\d.]+)/);
			return (n.webkit = !! i) && (n.version = i[1]), o && (e.android = !0, e.version = o[2]), a && !s && (e.ios = e.iphone = !0, e.version = a[2].replace(/_/g, ".")), r && (e.ios = e.ipad = !0, e.version = r[2].replace(/_/g, ".")), s && (e.ios = e.ipod = !0, e.version = s[3] ? s[3].replace(/_/g, ".") : null), l && (e.webos = !0, e.version = l[2]), u && (e.touchpad = !0), c && (e.blackberry = !0, e.version = c[2]), g && (e.bb10 = !0, e.version = g[2]), d && (e.rimtabletos = !0, e.version = d[2]), f && (n.playbook = !0), p && (e.kindle = !0, e.version = p[1]), h && (n.silk = !0, n.version = h[1]), !h && e.android && t.match(/Kindle Fire/) && (n.silk = !0), m && (n.chrome = !0, n.version = m[1]), y && (n.firefox = !0, n.version = y[1]), j && (n.ie = !0, n.version = j[1]), v && (t.match(/Safari/) || e.ios) && (n.safari = !0), x && (n.webview = !0), j && (n.ie = !0, n.version = j[1]), E && (n.edge = !0, n.version = E[1]), e.tablet = !! (r || f || o && !t.match(/Mobile/) || y && t.match(/Tablet/) || j && !t.match(/Phone/) && t.match(/Touch/)), e.phone = !(e.tablet || e.ipod || !(o || a || l || c || g || m && t.match(/Android/) || m && t.match(/CriOS\/([\d.]+)/) || y && t.match(/Mobile/) || j && t.match(/Touch/))), {
				browser: n,
				os: e,
				node: !1,
				canvasSupported: !! document.createElement("canvas").getContext,
				touchEventsSupported: "ontouchstart" in window && !n.ie && !n.edge,
				pointerEventsSupported: "onpointerdown" in window && (n.edge || n.ie && n.version >= 10)
			}
		}
		var i = {};
		i = "undefined" == typeof navigator ? {
			browser: {},
			os: {},
			node: !0,
			canvasSupported: !0
		} : n(navigator.userAgent), t.exports = i
	}, function(t, e, n) {
		(function(e) {
			function i(t) {
				return c.isArray(t) || (t = [t]), t
			}
			function o(t, e) {
				var n = t.dimensions,
					i = new y(c.map(n, t.getDimensionInfo, t), t.hostModel);
				m(i, t);
				for (var o = i._storage = {}, r = t._storage, s = 0; s < n.length; s++) {
					var a = n[s],
						l = r[a];
					c.indexOf(e, a) >= 0 ? o[a] = new l.constructor(r[a].length) : o[a] = r[a]
				}
				return i
			}
			var r = "undefined",
				s = "undefined" == typeof window ? e : window,
				a = typeof s.Float64Array === r ? Array : s.Float64Array,
				l = typeof s.Int32Array === r ? Array : s.Int32Array,
				u = {
					"float": a,
					"int": l,
					ordinal: Array,
					number: Array,
					time: Array
				},
				p = n(12),
				h = n(48),
				c = n(1),
				g = n(7),
				d = c.isObject,
				f = ["stackedOn", "_nameList", "_idList", "_rawData"],
				m = function(t, e) {
					c.each(f.concat(e.__wrappedMethods || []), function(n) {
						e.hasOwnProperty(n) && (t[n] = e[n])
					}), t.__wrappedMethods = e.__wrappedMethods
				},
				y = function(t, e) {
					t = t || ["x", "y"];
					for (var n = {}, i = [], o = 0; o < t.length; o++) {
						var r, s = {};
						"string" == typeof t[o] ? (r = t[o], s = {
							name: r,
							stackable: !1,
							type: "number"
						}) : (s = t[o], r = s.name, s.type = s.type || "number"), i.push(r), n[r] = s
					}
					this.dimensions = i, this._dimensionInfos = n, this.hostModel = e, this.dataType, this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent
				},
				v = y.prototype;
			v.type = "list", v.getDimension = function(t) {
				return isNaN(t) || (t = this.dimensions[t] || t), t
			}, v.getDimensionInfo = function(t) {
				return c.clone(this._dimensionInfos[this.getDimension(t)])
			}, v.initData = function(t, e, n) {
				if (t = t || [], !c.isArray(t)) throw new Error("Invalid data.");
				this._rawData = t;
				var i = this._storage = {},
					o = this.indices = [],
					r = this.dimensions,
					s = t.length,
					a = this._dimensionInfos,
					l = [],
					p = {};
				e = e || [];
				for (var h = 0; h < r.length; h++) {
					var d = a[r[h]],
						f = u[d.type];
					i[r[h]] = new f(s)
				}
				n = n ||
				function(t, e, n, i) {
					var o = g.getDataItemValue(t);
					return g.converDataValue(c.isArray(o) ? o[i] : o, a[e])
				};
				for (var m = 0; m < t.length; m++) {
					for (var y = t[m], v = 0; v < r.length; v++) {
						var x = r[v],
							j = i[x];
						j[m] = n(y, x, m, v)
					}
					o.push(m)
				}
				for (var h = 0; h < t.length; h++) {
					var E = "";
					e[h] || (e[h] = t[h].name, E = t[h].id);
					var I = e[h] || "";
					!E && I && (p[I] = p[I] || 0, E = I, p[I] > 0 && (E += "__ec__" + p[I]), p[I]++), E && (l[h] = E)
				}
				this._nameList = e, this._idList = l
			}, v.count = function() {
				return this.indices.length
			}, v.get = function(t, e, n) {
				var i = this._storage,
					o = this.indices[e];
				if (null == o) return NaN;
				var r = i[t] && i[t][o];
				if (n) {
					var s = this._dimensionInfos[t];
					if (s && s.stackable) for (var a = this.stackedOn; a;) {
						var l = a.get(t, e);
						(r >= 0 && l > 0 || 0 >= r && 0 > l) && (r += l), a = a.stackedOn
					}
				}
				return r
			}, v.getValues = function(t, e, n) {
				var i = [];
				c.isArray(t) || (n = e, e = t, t = this.dimensions);
				for (var o = 0, r = t.length; r > o; o++) i.push(this.get(t[o], e, n));
				return i
			}, v.hasValue = function(t) {
				for (var e = this.dimensions, n = this._dimensionInfos, i = 0, o = e.length; o > i; i++) if ("ordinal" !== n[e[i]].type && isNaN(this.get(e[i], t))) return !1;
				return !0
			}, v.getDataExtent = function(t, e) {
				var n = this._storage[t],
					i = this.getDimensionInfo(t);
				e = i && i.stackable && e;
				var o, r = (this._extent || (this._extent = {}))[t + !! e];
				if (r) return r;
				if (n) {
					for (var s = 1 / 0, a = -(1 / 0), l = 0, u = this.count(); u > l; l++) o = this.get(t, l, e), s > o && (s = o), o > a && (a = o);
					return this._extent[t + e] = [s, a]
				}
				return [1 / 0, -(1 / 0)]
			}, v.getSum = function(t, e) {
				var n = this._storage[t],
					i = 0;
				if (n) for (var o = 0, r = this.count(); r > o; o++) {
					var s = this.get(t, o, e);
					isNaN(s) || (i += s)
				}
				return i
			}, v.indexOf = function(t, e) {
				var n = this._storage,
					i = n[t],
					o = this.indices;
				if (i) for (var r = 0, s = o.length; s > r; r++) {
					var a = o[r];
					if (i[a] === e) return r
				}
				return -1
			}, v.indexOfName = function(t) {
				for (var e = this.indices, n = this._nameList, i = 0, o = e.length; o > i; i++) {
					var r = e[i];
					if (n[r] === t) return i
				}
				return -1
			}, v.indexOfNearest = function(t, e, n) {
				var i = this._storage,
					o = i[t];
				if (o) {
					for (var r = Number.MAX_VALUE, s = -1, a = 0, l = this.count(); l > a; a++) {
						var u = e - this.get(t, a, n),
							p = Math.abs(u);
						(r > p || p === r && u > 0) && (r = p, s = a)
					}
					return s
				}
				return -1
			}, v.getRawIndex = function(t) {
				var e = this.indices[t];
				return null == e ? -1 : e
			}, v.getRawDataItem = function(t) {
				return this._rawData[this.getRawIndex(t)]
			}, v.getName = function(t) {
				return this._nameList[this.indices[t]] || ""
			}, v.getId = function(t) {
				return this._idList[this.indices[t]] || this.getRawIndex(t) + ""
			}, v.each = function(t, e, n, o) {
				"function" == typeof t && (o = n, n = e, e = t, t = []), t = c.map(i(t), this.getDimension, this);
				var r = [],
					s = t.length,
					a = this.indices;
				o = o || this;
				for (var l = 0; l < a.length; l++) if (0 === s) e.call(o, l);
				else if (1 === s) e.call(o, this.get(t[0], l, n), l);
				else {
					for (var u = 0; s > u; u++) r[u] = this.get(t[u], l, n);
					r[u] = l, e.apply(o, r)
				}
			}, v.filterSelf = function(t, e, n, o) {
				"function" == typeof t && (o = n, n = e, e = t, t = []), t = c.map(i(t), this.getDimension, this);
				var r = [],
					s = [],
					a = t.length,
					l = this.indices;
				o = o || this;
				for (var u = 0; u < l.length; u++) {
					var p;
					if (1 === a) p = e.call(o, this.get(t[0], u, n), u);
					else {
						for (var h = 0; a > h; h++) s[h] = this.get(t[h], u, n);
						s[h] = u, p = e.apply(o, s)
					}
					p && r.push(l[u])
				}
				return this.indices = r, this._extent = {}, this
			}, v.mapArray = function(t, e, n, i) {
				"function" == typeof t && (i = n, n = e, e = t, t = []);
				var o = [];
				return this.each(t, function() {
					o.push(e && e.apply(this, arguments))
				}, n, i), o
			}, v.map = function(t, e, n, r) {
				t = c.map(i(t), this.getDimension, this);
				var s = o(this, t),
					a = s.indices = this.indices,
					l = s._storage,
					u = [];
				return this.each(t, function() {
					var n = arguments[arguments.length - 1],
						i = e && e.apply(this, arguments);
					if (null != i) {
						"number" == typeof i && (u[0] = i, i = u);
						for (var o = 0; o < i.length; o++) {
							var r = t[o],
								s = l[r],
								p = a[n];
							s && (s[p] = i[o])
						}
					}
				}, n, r), s
			}, v.downSample = function(t, e, n, i) {
				for (var r = o(this, [t]), s = this._storage, a = r._storage, l = this.indices, u = r.indices = [], p = [], h = [], c = Math.floor(1 / e), g = a[t], d = this.count(), f = 0; f < s[t].length; f++) a[t][f] = s[t][f];
				for (var f = 0; d > f; f += c) {
					c > d - f && (c = d - f, p.length = c);
					for (var m = 0; c > m; m++) {
						var y = l[f + m];
						p[m] = g[y], h[m] = y
					}
					var v = n(p),
						y = h[i(p, v) || 0];
					g[y] = v, u.push(y)
				}
				return r
			}, v.getItemModel = function(t) {
				var e = this.hostModel;
				return t = this.indices[t], new p(this._rawData[t], e, e && e.ecModel)
			}, v.diff = function(t) {
				var e = this._idList,
					n = t && t._idList;
				return new h(t ? t.indices : [], this.indices, function(t) {
					return n[t] || t + ""
				}, function(t) {
					return e[t] || t + ""
				})
			}, v.getVisual = function(t) {
				var e = this._visual;
				return e && e[t]
			}, v.setVisual = function(t, e) {
				if (d(t)) for (var n in t) t.hasOwnProperty(n) && this.setVisual(n, t[n]);
				else this._visual = this._visual || {}, this._visual[t] = e
			}, v.setLayout = function(t, e) {
				if (d(t)) for (var n in t) t.hasOwnProperty(n) && this.setLayout(n, t[n]);
				else this._layout[t] = e
			}, v.getLayout = function(t) {
				return this._layout[t]
			}, v.getItemLayout = function(t) {
				return this._itemLayouts[t]
			}, v.setItemLayout = function(t, e, n) {
				this._itemLayouts[t] = n ? c.extend(this._itemLayouts[t] || {}, e) : e
			}, v.clearItemLayouts = function() {
				this._itemLayouts.length = 0
			}, v.getItemVisual = function(t, e, n) {
				var i = this._itemVisuals[t],
					o = i && i[e];
				return null != o || n ? o : this.getVisual(e)
			}, v.setItemVisual = function(t, e, n) {
				var i = this._itemVisuals[t] || {};
				if (this._itemVisuals[t] = i, d(e)) for (var o in e) e.hasOwnProperty(o) && (i[o] = e[o]);
				else i[e] = n
			};
			var x = function(t) {
					t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType
				};
			v.setItemGraphicEl = function(t, e) {
				var n = this.hostModel;
				e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = n && n.seriesIndex, "group" === e.type && e.traverse(x, e)), this._graphicEls[t] = e
			}, v.getItemGraphicEl = function(t) {
				return this._graphicEls[t]
			}, v.eachItemGraphicEl = function(t, e) {
				c.each(this._graphicEls, function(n, i) {
					n && t && t.call(e, n, i)
				})
			}, v.cloneShallow = function() {
				var t = c.map(this.dimensions, this.getDimensionInfo, this),
					e = new y(t, this.hostModel);
				return e._storage = this._storage, m(e, this), e.indices = this.indices.slice(), e
			}, v.wrapMethod = function(t, e) {
				var n = this[t];
				"function" == typeof n && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
					var t = n.apply(this, arguments);
					return e.apply(this, [t].concat(c.slice(arguments)))
				})
			}, v.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], v.CHANGABLE_METHODS = ["filterSelf"], t.exports = y
		}).call(e, function() {
			return this
		}())
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			return t > -I && I > t
		}
		function o(t) {
			return t > I || -I > t
		}
		function r(t, e, n, i, o) {
			var r = 1 - o;
			return r * r * (r * t + 3 * o * e) + o * o * (o * i + 3 * r * n)
		}
		function s(t, e, n, i, o) {
			var r = 1 - o;
			return 3 * (((e - t) * r + 2 * (n - e) * o) * r + (i - n) * o * o)
		}
		function a(t, e, n, o, r, s) {
			var a = o + 3 * (e - n) - t,
				l = 3 * (n - 2 * e + t),
				u = 3 * (e - t),
				p = t - r,
				h = l * l - 3 * a * u,
				c = l * u - 9 * a * p,
				g = u * u - 3 * l * p,
				d = 0;
			if (i(h) && i(c)) if (i(l)) s[0] = 0;
			else {
				var f = -u / l;
				f >= 0 && 1 >= f && (s[d++] = f)
			} else {
				var m = c * c - 4 * h * g;
				if (i(m)) {
					var y = c / h,
						f = -l / a + y,
						v = -y / 2;
					f >= 0 && 1 >= f && (s[d++] = f), v >= 0 && 1 >= v && (s[d++] = v)
				} else if (m > 0) {
					var x = E(m),
						I = h * l + 1.5 * a * (-c + x),
						C = h * l + 1.5 * a * (-c - x);
					I = 0 > I ? -j(-I, b) : j(I, b), C = 0 > C ? -j(-C, b) : j(C, b);
					var f = (-l - (I + C)) / (3 * a);
					f >= 0 && 1 >= f && (s[d++] = f)
				} else {
					var L = (2 * h * l - 3 * a * c) / (2 * E(h * h * h)),
						w = Math.acos(L) / 3,
						P = E(h),
						M = Math.cos(w),
						f = (-l - 2 * P * M) / (3 * a),
						v = (-l + P * (M + S * Math.sin(w))) / (3 * a),
						_ = (-l + P * (M - S * Math.sin(w))) / (3 * a);
					f >= 0 && 1 >= f && (s[d++] = f), v >= 0 && 1 >= v && (s[d++] = v), _ >= 0 && 1 >= _ && (s[d++] = _)
				}
			}
			return d
		}
		function l(t, e, n, r, s) {
			var a = 6 * n - 12 * e + 6 * t,
				l = 9 * e + 3 * r - 3 * t - 9 * n,
				u = 3 * e - 3 * t,
				p = 0;
			if (i(l)) {
				if (o(a)) {
					var h = -u / a;
					h >= 0 && 1 >= h && (s[p++] = h)
				}
			} else {
				var c = a * a - 4 * l * u;
				if (i(c)) s[0] = -a / (2 * l);
				else if (c > 0) {
					var g = E(c),
						h = (-a + g) / (2 * l),
						d = (-a - g) / (2 * l);
					h >= 0 && 1 >= h && (s[p++] = h), d >= 0 && 1 >= d && (s[p++] = d)
				}
			}
			return p
		}
		function u(t, e, n, i, o, r) {
			var s = (e - t) * o + t,
				a = (n - e) * o + e,
				l = (i - n) * o + n,
				u = (a - s) * o + s,
				p = (l - a) * o + a,
				h = (p - u) * o + u;
			r[0] = t, r[1] = s, r[2] = u, r[3] = h, r[4] = h, r[5] = p, r[6] = l, r[7] = i
		}
		function p(t, e, n, i, o, s, a, l, u, p, h) {
			var c, g, d, f, m, y = .005,
				v = 1 / 0;
			L[0] = u, L[1] = p;
			for (var j = 0; 1 > j; j += .05) w[0] = r(t, n, o, a, j), w[1] = r(e, i, s, l, j), f = x(L, w), v > f && (c = j, v = f);
			v = 1 / 0;
			for (var I = 0; 32 > I && !(C > y); I++) g = c - y, d = c + y, w[0] = r(t, n, o, a, g), w[1] = r(e, i, s, l, g), f = x(w, L), g >= 0 && v > f ? (c = g, v = f) : (P[0] = r(t, n, o, a, d), P[1] = r(e, i, s, l, d), m = x(P, L), 1 >= d && v > m ? (c = d, v = m) : y *= .5);
			return h && (h[0] = r(t, n, o, a, c), h[1] = r(e, i, s, l, c)), E(v)
		}
		function h(t, e, n, i) {
			var o = 1 - i;
			return o * (o * t + 2 * i * e) + i * i * n
		}
		function c(t, e, n, i) {
			return 2 * ((1 - i) * (e - t) + i * (n - e))
		}
		function g(t, e, n, r, s) {
			var a = t - 2 * e + n,
				l = 2 * (e - t),
				u = t - r,
				p = 0;
			if (i(a)) {
				if (o(l)) {
					var h = -u / l;
					h >= 0 && 1 >= h && (s[p++] = h)
				}
			} else {
				var c = l * l - 4 * a * u;
				if (i(c)) {
					var h = -l / (2 * a);
					h >= 0 && 1 >= h && (s[p++] = h)
				} else if (c > 0) {
					var g = E(c),
						h = (-l + g) / (2 * a),
						d = (-l - g) / (2 * a);
					h >= 0 && 1 >= h && (s[p++] = h), d >= 0 && 1 >= d && (s[p++] = d)
				}
			}
			return p
		}
		function d(t, e, n) {
			var i = t + n - 2 * e;
			return 0 === i ? .5 : (t - e) / i
		}
		function f(t, e, n, i, o) {
			var r = (e - t) * i + t,
				s = (n - e) * i + e,
				a = (s - r) * i + r;
			o[0] = t, o[1] = r, o[2] = a, o[3] = a, o[4] = s, o[5] = n
		}
		function m(t, e, n, i, o, r, s, a, l) {
			var u, p = .005,
				c = 1 / 0;
			L[0] = s, L[1] = a;
			for (var g = 0; 1 > g; g += .05) {
				w[0] = h(t, n, o, g), w[1] = h(e, i, r, g);
				var d = x(L, w);
				c > d && (u = g, c = d)
			}
			c = 1 / 0;
			for (var f = 0; 32 > f && !(C > p); f++) {
				var m = u - p,
					y = u + p;
				w[0] = h(t, n, o, m), w[1] = h(e, i, r, m);
				var d = x(w, L);
				if (m >= 0 && c > d) u = m, c = d;
				else {
					P[0] = h(t, n, o, y), P[1] = h(e, i, r, y);
					var v = x(P, L);
					1 >= y && c > v ? (u = y, c = v) : p *= .5
				}
			}
			return l && (l[0] = h(t, n, o, u), l[1] = h(e, i, r, u)), E(c)
		}
		var y = n(5),
			v = y.create,
			x = y.distSquare,
			j = Math.pow,
			E = Math.sqrt,
			I = 1e-8,
			C = 1e-4,
			S = E(3),
			b = 1 / 3,
			L = v(),
			w = v(),
			P = v();
		t.exports = {
			cubicAt: r,
			cubicDerivativeAt: s,
			cubicRootAt: a,
			cubicExtrema: l,
			cubicSubdivide: u,
			cubicProjectPoint: p,
			quadraticAt: h,
			quadraticDerivativeAt: c,
			quadraticRootAt: g,
			quadraticExtremum: d,
			quadraticSubdivide: f,
			quadraticProjectPoint: m
		}
	}, function(t, e) {
		var n = function(t) {
				this.colorStops = t || []
			};
		n.prototype = {
			constructor: n,
			addColorStop: function(t, e) {
				this.colorStops.push({
					offset: t,
					color: e
				})
			}
		}, t.exports = n
	}, function(t, e, n) {
		function i(t, e) {
			var n = t + ":" + e;
			if (u[n]) return u[n];
			for (var i = (t + "").split("\n"), o = 0, r = 0, s = i.length; s > r; r++) o = Math.max(d.measureText(i[r], e).width, o);
			return p > h && (p = 0, u = {}), p++, u[n] = o, o
		}
		function o(t, e, n, o) {
			var r = ((t || "") + "").split("\n").length,
				s = i(t, e),
				a = i("国", e),
				l = r * a,
				u = new g(0, 0, s, l);
			switch (u.lineHeight = a, o) {
			case "bottom":
			case "alphabetic":
				u.y -= a;
				break;
			case "middle":
				u.y -= a / 2
			}
			switch (n) {
			case "end":
			case "right":
				u.x -= u.width;
				break;
			case "center":
				u.x -= u.width / 2
			}
			return u
		}
		function r(t, e, n, i) {
			var o = e.x,
				r = e.y,
				s = e.height,
				a = e.width,
				l = n.height,
				u = s / 2 - l / 2,
				p = "left";
			switch (t) {
			case "left":
				o -= i, r += u, p = "right";
				break;
			case "right":
				o += i + a, r += u, p = "left";
				break;
			case "top":
				o += a / 2, r -= i + l, p = "center";
				break;
			case "bottom":
				o += a / 2, r += s + i, p = "center";
				break;
			case "inside":
				o += a / 2, r += u, p = "center";
				break;
			case "insideLeft":
				o += i, r += u, p = "left";
				break;
			case "insideRight":
				o += a - i, r += u, p = "right";
				break;
			case "insideTop":
				o += a / 2, r += i, p = "center";
				break;
			case "insideBottom":
				o += a / 2, r += s - l - i, p = "center";
				break;
			case "insideTopLeft":
				o += i, r += i, p = "left";
				break;
			case "insideTopRight":
				o += a - i, r += i, p = "right";
				break;
			case "insideBottomLeft":
				o += i, r += s - l - i;
				break;
			case "insideBottomRight":
				o += a - i, r += s - l - i, p = "right"
			}
			return {
				x: o,
				y: r,
				textAlign: p,
				textBaseline: "top"
			}
		}
		function s(t, e, n, o) {
			if (!n) return "";
			o = c.defaults({
				ellipsis: "...",
				minCharacters: 3,
				maxIterations: 3,
				cnCharWidth: i("国", e),
				ascCharWidth: i("a", e)
			}, o, !0), n -= i(o.ellipsis);
			for (var r = (t + "").split("\n"), s = 0, l = r.length; l > s; s++) r[s] = a(r[s], e, n, o);
			return r.join("\n")
		}
		function a(t, e, n, o) {
			for (var r = 0;; r++) {
				var s = i(t, e);
				if (n > s || r >= o.maxIterations) {
					t += o.ellipsis;
					break
				}
				var a = 0 === r ? l(t, n, o) : Math.floor(t.length * n / s);
				if (a < o.minCharacters) {
					t = "";
					break
				}
				t = t.substr(0, a)
			}
			return t
		}
		function l(t, e, n) {
			for (var i = 0, o = 0, r = t.length; r > o && e > i; o++) {
				var s = t.charCodeAt(o);
				i += s >= 0 && 127 >= s ? n.ascCharWidth : n.cnCharWidth
			}
			return o
		}
		var u = {},
			p = 0,
			h = 5e3,
			c = n(1),
			g = n(8),
			d = {
				getWidth: i,
				getBoundingRect: o,
				adjustTextPositionOnRect: r,
				ellipsis: s,
				measureText: function(t, e) {
					var n = c.getContext();
					return n.font = e, n.measureText(t)
				}
			};
		t.exports = d
	}, function(t, e) {
		var n = "undefined" == typeof Float32Array ? Array : Float32Array,
			i = {
				create: function() {
					var t = new n(6);
					return i.identity(t), t
				},
				identity: function(t) {
					return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
				},
				copy: function(t, e) {
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
				},
				mul: function(t, e, n) {
					var i = e[0] * n[0] + e[2] * n[1],
						o = e[1] * n[0] + e[3] * n[1],
						r = e[0] * n[2] + e[2] * n[3],
						s = e[1] * n[2] + e[3] * n[3],
						a = e[0] * n[4] + e[2] * n[5] + e[4],
						l = e[1] * n[4] + e[3] * n[5] + e[5];
					return t[0] = i, t[1] = o, t[2] = r, t[3] = s, t[4] = a, t[5] = l, t
				},
				translate: function(t, e, n) {
					return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + n[0], t[5] = e[5] + n[1], t
				},
				rotate: function(t, e, n) {
					var i = e[0],
						o = e[2],
						r = e[4],
						s = e[1],
						a = e[3],
						l = e[5],
						u = Math.sin(n),
						p = Math.cos(n);
					return t[0] = i * p + s * u, t[1] = -i * u + s * p, t[2] = o * p + a * u, t[3] = -o * u + p * a, t[4] = p * r + u * l, t[5] = p * l - u * r, t
				},
				scale: function(t, e, n) {
					var i = n[0],
						o = n[1];
					return t[0] = e[0] * i, t[1] = e[1] * o, t[2] = e[2] * i, t[3] = e[3] * o, t[4] = e[4] * i, t[5] = e[5] * o, t
				},
				invert: function(t, e) {
					var n = e[0],
						i = e[2],
						o = e[4],
						r = e[1],
						s = e[3],
						a = e[5],
						l = n * s - r * i;
					return l ? (l = 1 / l, t[0] = s * l, t[1] = -r * l, t[2] = -i * l, t[3] = n * l, t[4] = (i * a - s * o) * l, t[5] = (r * o - n * a) * l, t) : null
				}
			};
		t.exports = i
	}, function(t, e, n) {
		function i(t, e) {
			var n = r.slice(arguments, 2);
			return this.superClass.prototype[e].apply(t, n)
		}
		function o(t, e, n) {
			return this.superClass.prototype[e].apply(t, n)
		}
		var r = n(1),
			s = {},
			a = ".",
			l = "___EC__COMPONENT__CONTAINER___",
			u = s.parseClassType = function(t) {
				var e = {
					main: "",
					sub: ""
				};
				return t && (t = t.split(a), e.main = t[0] || "", e.sub = t[1] || ""), e
			};
		s.enableClassExtend = function(t, e) {
			t.extend = function(n) {
				var s = function() {
						e && e.apply(this, arguments), t.apply(this, arguments)
					};
				return r.extend(s.prototype, n), s.extend = this.extend, s.superCall = i, s.superApply = o, r.inherits(s, this), s.superClass = this, s
			}
		}, s.enableClassManagement = function(t, e) {
			function n(t) {
				var e = i[t.main];
				return e && e[l] || (e = i[t.main] = {}, e[l] = !0), e
			}
			e = e || {};
			var i = {};
			if (t.registerClass = function(t, e) {
				if (e) if (e = u(e), e.sub) {
					if (e.sub !== l) {
						var o = n(e);
						o[e.sub] = t
					}
				} else {
					if (i[e.main]) throw new Error(e.main + "exists.");
					i[e.main] = t
				}
				return t
			}, t.getClass = function(t, e, n) {
				var o = i[t];
				if (o && o[l] && (o = e ? o[e] : null), n && !o) throw new Error("Component " + t + "." + (e || "") + " not exists. Load it first.");
				return o
			}, t.getClassesByMainType = function(t) {
				t = u(t);
				var e = [],
					n = i[t.main];
				return n && n[l] ? r.each(n, function(t, n) {
					n !== l && e.push(t)
				}) : e.push(n), e
			}, t.hasClass = function(t) {
				return t = u(t), !! i[t.main]
			}, t.getAllClassMainTypes = function() {
				var t = [];
				return r.each(i, function(e, n) {
					t.push(n)
				}), t
			}, t.hasSubTypes = function(t) {
				t = u(t);
				var e = i[t.main];
				return e && e[l]
			}, t.parseClassType = u, e.registerWhenExtend) {
				var o = t.extend;
				o && (t.extend = function(e) {
					var n = o.call(this, e);
					return t.registerClass(n, e.type)
				})
			}
			return t
		}, s.setReadOnly = function(t, e) {}, t.exports = s
	}, function(t, e, n) {
		var i = Array.prototype.slice,
			o = n(1),
			r = o.indexOf,
			s = function() {
				this._$handlers = {}
			};
		s.prototype = {
			constructor: s,
			one: function(t, e, n) {
				var i = this._$handlers;
				return e && t ? (i[t] || (i[t] = []), r(i[t], t) >= 0 ? this : (i[t].push({
					h: e,
					one: !0,
					ctx: n || this
				}), this)) : this
			},
			on: function(t, e, n) {
				var i = this._$handlers;
				return e && t ? (i[t] || (i[t] = []), i[t].push({
					h: e,
					one: !1,
					ctx: n || this
				}), this) : this
			},
			isSilent: function(t) {
				var e = this._$handlers;
				return e[t] && e[t].length
			},
			off: function(t, e) {
				var n = this._$handlers;
				if (!t) return this._$handlers = {}, this;
				if (e) {
					if (n[t]) {
						for (var i = [], o = 0, r = n[t].length; r > o; o++) n[t][o].h != e && i.push(n[t][o]);
						n[t] = i
					}
					n[t] && 0 === n[t].length && delete n[t]
				} else delete n[t];
				return this
			},
			trigger: function(t) {
				if (this._$handlers[t]) {
					var e = arguments,
						n = e.length;
					n > 3 && (e = i.call(e, 1));
					for (var o = this._$handlers[t], r = o.length, s = 0; r > s;) {
						switch (n) {
						case 1:
							o[s].h.call(o[s].ctx);
							break;
						case 2:
							o[s].h.call(o[s].ctx, e[1]);
							break;
						case 3:
							o[s].h.call(o[s].ctx, e[1], e[2]);
							break;
						default:
							o[s].h.apply(o[s].ctx, e)
						}
						o[s].one ? (o.splice(s, 1), r--) : s++
					}
				}
				return this
			},
			triggerWithContext: function(t) {
				if (this._$handlers[t]) {
					var e = arguments,
						n = e.length;
					n > 4 && (e = i.call(e, 1, e.length - 1));
					for (var o = e[e.length - 1], r = this._$handlers[t], s = r.length, a = 0; s > a;) {
						switch (n) {
						case 1:
							r[a].h.call(o);
							break;
						case 2:
							r[a].h.call(o, e[1]);
							break;
						case 3:
							r[a].h.call(o, e[1], e[2]);
							break;
						default:
							r[a].h.apply(o, e)
						}
						r[a].one ? (r.splice(a, 1), s--) : a++
					}
				}
				return this
			}
		}, t.exports = s
	}, function(t, e) {
		function n(t) {
			return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t
		}
		function i(t) {
			return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t
		}
		function o(t) {
			return 0 > t ? 0 : t > 1 ? 1 : t
		}
		function r(t) {
			return n(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 * 255 : parseInt(t, 10))
		}
		function s(t) {
			return o(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 : parseFloat(t))
		}
		function a(t, e, n) {
			return 0 > n ? n += 1 : n > 1 && (n -= 1), 1 > 6 * n ? t + (e - t) * n * 6 : 1 > 2 * n ? e : 2 > 3 * n ? t + (e - t) * (2 / 3 - n) * 6 : t
		}
		function l(t, e, n) {
			return t + (e - t) * n
		}
		function u(t) {
			if (t) {
				t += "";
				var e = t.replace(/ /g, "").toLowerCase();
				if (e in x) return x[e].slice();
				if ("#" !== e.charAt(0)) {
					var n = e.indexOf("("),
						i = e.indexOf(")");
					if (-1 !== n && i + 1 === e.length) {
						var o = e.substr(0, n),
							a = e.substr(n + 1, i - (n + 1)).split(","),
							l = 1;
						switch (o) {
						case "rgba":
							if (4 !== a.length) return;
							l = s(a.pop());
						case "rgb":
							if (3 !== a.length) return;
							return [r(a[0]), r(a[1]), r(a[2]), l];
						case "hsla":
							if (4 !== a.length) return;
							return a[3] = s(a[3]), p(a);
						case "hsl":
							if (3 !== a.length) return;
							return p(a);
						default:
							return
						}
					}
				} else {
					if (4 === e.length) {
						var u = parseInt(e.substr(1), 16);
						if (!(u >= 0 && 4095 >= u)) return;
						return [(3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1]
					}
					if (7 === e.length) {
						var u = parseInt(e.substr(1), 16);
						if (!(u >= 0 && 16777215 >= u)) return;
						return [(16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1]
					}
				}
			}
		}
		function p(t) {
			var e = (parseFloat(t[0]) % 360 + 360) % 360 / 360,
				i = s(t[1]),
				o = s(t[2]),
				r = .5 >= o ? o * (i + 1) : o + i - o * i,
				l = 2 * o - r,
				u = [n(255 * a(l, r, e + 1 / 3)), n(255 * a(l, r, e)), n(255 * a(l, r, e - 1 / 3))];
			return 4 === t.length && (u[3] = t[3]), u
		}
		function h(t) {
			if (t) {
				var e, n, i = t[0] / 255,
					o = t[1] / 255,
					r = t[2] / 255,
					s = Math.min(i, o, r),
					a = Math.max(i, o, r),
					l = a - s,
					u = (a + s) / 2;
				if (0 === l) e = 0, n = 0;
				else {
					n = .5 > u ? l / (a + s) : l / (2 - a - s);
					var p = ((a - i) / 6 + l / 2) / l,
						h = ((a - o) / 6 + l / 2) / l,
						c = ((a - r) / 6 + l / 2) / l;
					i === a ? e = c - h : o === a ? e = 1 / 3 + p - c : r === a && (e = 2 / 3 + h - p), 0 > e && (e += 1), e > 1 && (e -= 1)
				}
				var g = [360 * e, n, u];
				return null != t[3] && g.push(t[3]), g
			}
		}
		function c(t, e) {
			var n = u(t);
			if (n) {
				for (var i = 0; 3 > i; i++) 0 > e ? n[i] = n[i] * (1 - e) | 0 : n[i] = (255 - n[i]) * e + n[i] | 0;
				return v(n, 4 === n.length ? "rgba" : "rgb")
			}
		}
		function g(t, e) {
			var n = u(t);
			return n ? ((1 << 24) + (n[0] << 16) + (n[1] << 8) + +n[2]).toString(16).slice(1) : void 0
		}
		function d(t, e, i) {
			if (e && e.length && t >= 0 && 1 >= t) {
				i = i || [0, 0, 0, 0];
				var o = t * (e.length - 1),
					r = Math.floor(o),
					s = Math.ceil(o),
					a = e[r],
					u = e[s],
					p = o - r;
				return i[0] = n(l(a[0], u[0], p)), i[1] = n(l(a[1], u[1], p)), i[2] = n(l(a[2], u[2], p)), i[3] = n(l(a[3], u[3], p)), i
			}
		}
		function f(t, e, i) {
			if (e && e.length && t >= 0 && 1 >= t) {
				var r = t * (e.length - 1),
					s = Math.floor(r),
					a = Math.ceil(r),
					p = u(e[s]),
					h = u(e[a]),
					c = r - s,
					g = v([n(l(p[0], h[0], c)), n(l(p[1], h[1], c)), n(l(p[2], h[2], c)), o(l(p[3], h[3], c))], "rgba");
				return i ? {
					color: g,
					leftIndex: s,
					rightIndex: a,
					value: r
				} : g
			}
		}
		function m(t, e, n, o) {
			return t = u(t), t ? (t = h(t), null != e && (t[0] = i(e)), null != n && (t[1] = s(n)), null != o && (t[2] = s(o)), v(p(t), "rgba")) : void 0
		}
		function y(t, e) {
			return t = u(t), t && null != e ? (t[3] = o(e), v(t, "rgba")) : void 0
		}
		function v(t, e) {
			return "rgb" !== e && "hsv" !== e && "hsl" !== e || (t = t.slice(0, 3)), e + "(" + t.join(",") + ")"
		}
		var x = {
			transparent: [0, 0, 0, 0],
			aliceblue: [240, 248, 255, 1],
			antiquewhite: [250, 235, 215, 1],
			aqua: [0, 255, 255, 1],
			aquamarine: [127, 255, 212, 1],
			azure: [240, 255, 255, 1],
			beige: [245, 245, 220, 1],
			bisque: [255, 228, 196, 1],
			black: [0, 0, 0, 1],
			blanchedalmond: [255, 235, 205, 1],
			blue: [0, 0, 255, 1],
			blueviolet: [138, 43, 226, 1],
			brown: [165, 42, 42, 1],
			burlywood: [222, 184, 135, 1],
			cadetblue: [95, 158, 160, 1],
			chartreuse: [127, 255, 0, 1],
			chocolate: [210, 105, 30, 1],
			coral: [255, 127, 80, 1],
			cornflowerblue: [100, 149, 237, 1],
			cornsilk: [255, 248, 220, 1],
			crimson: [220, 20, 60, 1],
			cyan: [0, 255, 255, 1],
			darkblue: [0, 0, 139, 1],
			darkcyan: [0, 139, 139, 1],
			darkgoldenrod: [184, 134, 11, 1],
			darkgray: [169, 169, 169, 1],
			darkgreen: [0, 100, 0, 1],
			darkgrey: [169, 169, 169, 1],
			darkkhaki: [189, 183, 107, 1],
			darkmagenta: [139, 0, 139, 1],
			darkolivegreen: [85, 107, 47, 1],
			darkorange: [255, 140, 0, 1],
			darkorchid: [153, 50, 204, 1],
			darkred: [139, 0, 0, 1],
			darksalmon: [233, 150, 122, 1],
			darkseagreen: [143, 188, 143, 1],
			darkslateblue: [72, 61, 139, 1],
			darkslategray: [47, 79, 79, 1],
			darkslategrey: [47, 79, 79, 1],
			darkturquoise: [0, 206, 209, 1],
			darkviolet: [148, 0, 211, 1],
			deeppink: [255, 20, 147, 1],
			deepskyblue: [0, 191, 255, 1],
			dimgray: [105, 105, 105, 1],
			dimgrey: [105, 105, 105, 1],
			dodgerblue: [30, 144, 255, 1],
			firebrick: [178, 34, 34, 1],
			floralwhite: [255, 250, 240, 1],
			forestgreen: [34, 139, 34, 1],
			fuchsia: [255, 0, 255, 1],
			gainsboro: [220, 220, 220, 1],
			ghostwhite: [248, 248, 255, 1],
			gold: [255, 215, 0, 1],
			goldenrod: [218, 165, 32, 1],
			gray: [128, 128, 128, 1],
			green: [0, 128, 0, 1],
			greenyellow: [173, 255, 47, 1],
			grey: [128, 128, 128, 1],
			honeydew: [240, 255, 240, 1],
			hotpink: [255, 105, 180, 1],
			indianred: [205, 92, 92, 1],
			indigo: [75, 0, 130, 1],
			ivory: [255, 255, 240, 1],
			khaki: [240, 230, 140, 1],
			lavender: [230, 230, 250, 1],
			lavenderblush: [255, 240, 245, 1],
			lawngreen: [124, 252, 0, 1],
			lemonchiffon: [255, 250, 205, 1],
			lightblue: [173, 216, 230, 1],
			lightcoral: [240, 128, 128, 1],
			lightcyan: [224, 255, 255, 1],
			lightgoldenrodyellow: [250, 250, 210, 1],
			lightgray: [211, 211, 211, 1],
			lightgreen: [144, 238, 144, 1],
			lightgrey: [211, 211, 211, 1],
			lightpink: [255, 182, 193, 1],
			lightsalmon: [255, 160, 122, 1],
			lightseagreen: [32, 178, 170, 1],
			lightskyblue: [135, 206, 250, 1],
			lightslategray: [119, 136, 153, 1],
			lightslategrey: [119, 136, 153, 1],
			lightsteelblue: [176, 196, 222, 1],
			lightyellow: [255, 255, 224, 1],
			lime: [0, 255, 0, 1],
			limegreen: [50, 205, 50, 1],
			linen: [250, 240, 230, 1],
			magenta: [255, 0, 255, 1],
			maroon: [128, 0, 0, 1],
			mediumaquamarine: [102, 205, 170, 1],
			mediumblue: [0, 0, 205, 1],
			mediumorchid: [186, 85, 211, 1],
			mediumpurple: [147, 112, 219, 1],
			mediumseagreen: [60, 179, 113, 1],
			mediumslateblue: [123, 104, 238, 1],
			mediumspringgreen: [0, 250, 154, 1],
			mediumturquoise: [72, 209, 204, 1],
			mediumvioletred: [199, 21, 133, 1],
			midnightblue: [25, 25, 112, 1],
			mintcream: [245, 255, 250, 1],
			mistyrose: [255, 228, 225, 1],
			moccasin: [255, 228, 181, 1],
			navajowhite: [255, 222, 173, 1],
			navy: [0, 0, 128, 1],
			oldlace: [253, 245, 230, 1],
			olive: [128, 128, 0, 1],
			olivedrab: [107, 142, 35, 1],
			orange: [255, 165, 0, 1],
			orangered: [255, 69, 0, 1],
			orchid: [218, 112, 214, 1],
			palegoldenrod: [238, 232, 170, 1],
			palegreen: [152, 251, 152, 1],
			paleturquoise: [175, 238, 238, 1],
			palevioletred: [219, 112, 147, 1],
			papayawhip: [255, 239, 213, 1],
			peachpuff: [255, 218, 185, 1],
			peru: [205, 133, 63, 1],
			pink: [255, 192, 203, 1],
			plum: [221, 160, 221, 1],
			powderblue: [176, 224, 230, 1],
			purple: [128, 0, 128, 1],
			red: [255, 0, 0, 1],
			rosybrown: [188, 143, 143, 1],
			royalblue: [65, 105, 225, 1],
			saddlebrown: [139, 69, 19, 1],
			salmon: [250, 128, 114, 1],
			sandybrown: [244, 164, 96, 1],
			seagreen: [46, 139, 87, 1],
			seashell: [255, 245, 238, 1],
			sienna: [160, 82, 45, 1],
			silver: [192, 192, 192, 1],
			skyblue: [135, 206, 235, 1],
			slateblue: [106, 90, 205, 1],
			slategray: [112, 128, 144, 1],
			slategrey: [112, 128, 144, 1],
			snow: [255, 250, 250, 1],
			springgreen: [0, 255, 127, 1],
			steelblue: [70, 130, 180, 1],
			tan: [210, 180, 140, 1],
			teal: [0, 128, 128, 1],
			thistle: [216, 191, 216, 1],
			tomato: [255, 99, 71, 1],
			turquoise: [64, 224, 208, 1],
			violet: [238, 130, 238, 1],
			wheat: [245, 222, 179, 1],
			white: [255, 255, 255, 1],
			whitesmoke: [245, 245, 245, 1],
			yellow: [255, 255, 0, 1],
			yellowgreen: [154, 205, 50, 1]
		};
		t.exports = {
			parse: u,
			lift: c,
			toHex: g,
			fastMapToColor: d,
			mapToColor: f,
			modifyHSL: m,
			modifyAlpha: y,
			stringify: v
		}
	}, function(t, e) {
		"use strict";

		function n() {
			this._coordinateSystems = []
		}
		var i = {};
		n.prototype = {
			constructor: n,
			create: function(t, e) {
				var n = [];
				for (var o in i) {
					var r = i[o].create(t, e);
					r && (n = n.concat(r))
				}
				this._coordinateSystems = n
			},
			update: function(t, e) {
				for (var n = this._coordinateSystems, i = 0; i < n.length; i++) n[i].update && n[i].update(t, e)
			}
		}, n.register = function(t, e) {
			i[t] = e
		}, n.get = function(t) {
			return i[t]
		}, t.exports = n
	}, function(t, e, n) {
		var i = n(123),
			o = n(38);
		n(124), n(122);
		var r = n(32),
			s = n(4),
			a = n(1),
			l = n(18),
			u = {};
		u.getScaleExtent = function(t, e) {
			var n = t.scale,
				i = n.getExtent(),
				o = i[1] - i[0];
			if ("ordinal" === n.type) return isFinite(o) ? i : [0, 0];
			var r = e.getMin ? e.getMin() : e.get("min"),
				l = e.getMax ? e.getMax() : e.get("max"),
				u = e.getNeedCrossZero ? e.getNeedCrossZero() : !e.get("scale"),
				p = e.get("boundaryGap");
			a.isArray(p) || (p = [p || 0, p || 0]), p[0] = s.parsePercent(p[0], 1), p[1] = s.parsePercent(p[1], 1);
			var h = !0,
				c = !0;
			return null == r && (r = i[0] - p[0] * o, h = !1), null == l && (l = i[1] + p[1] * o, c = !1), "dataMin" === r && (r = i[0]), "dataMax" === l && (l = i[1]), u && (r > 0 && l > 0 && !h && (r = 0), 0 > r && 0 > l && !c && (l = 0)), [r, l]
		}, u.niceScaleExtent = function(t, e) {
			var n = t.scale,
				i = u.getScaleExtent(t, e),
				o = null != (e.getMin ? e.getMin() : e.get("min")),
				r = null != (e.getMax ? e.getMax() : e.get("max")),
				s = e.get("splitNumber");
			n.setExtent(i[0], i[1]), n.niceExtent(s, o, r);
			var a = e.get("minInterval");
			if (isFinite(a) && !o && !r && "interval" === n.type) {
				var l = n.getInterval(),
					p = Math.max(Math.abs(l), a) / l;
				i = n.getExtent(), n.setExtent(p * i[0], i[1] * p), n.niceExtent(s)
			}
			var l = e.get("interval");
			null != l && n.setInterval && n.setInterval(l)
		}, u.createScaleByModel = function(t, e) {
			if (e = e || t.get("type")) switch (e) {
			case "category":
				return new i(t.getCategories(), [1 / 0, -(1 / 0)]);
			case "value":
				return new o;
			default:
				return (r.getClass(e) || o).create(t)
			}
		}, u.ifAxisCrossZero = function(t) {
			var e = t.scale.getExtent(),
				n = e[0],
				i = e[1];
			return !(n > 0 && i > 0 || 0 > n && 0 > i)
		}, u.getAxisLabelInterval = function(t, e, n, i) {
			var o, r = 0,
				s = 0,
				a = 1;
			e.length > 40 && (a = Math.round(e.length / 40));
			for (var u = 0; u < t.length; u += a) {
				var p = t[u],
					h = l.getBoundingRect(e[u], n, "center", "top");
				h[i ? "x" : "y"] += p, h[i ? "width" : "height"] *= 1.5, o ? o.intersect(h) ? (s++, r = Math.max(r, s)) : (o.union(h), s = 0) : o = h.clone()
			}
			return 0 === r && a > 1 ? a : r * a
		}, u.getFormattedLabels = function(t, e) {
			var n = t.scale,
				i = n.getTicksLabels(),
				o = n.getTicks();
			return "string" == typeof e ? (e = function(t) {
				return function(e) {
					return t.replace("{value}", e)
				}
			}(e), a.map(i, e)) : "function" == typeof e ? a.map(o, function(i, o) {
				return e("category" === t.type ? n.getLabel(i) : i, o)
			}, this) : i
		}, t.exports = u
	}, function(t, e, n) {
		"use strict";
		var i = n(3),
			o = n(8),
			r = i.extendShape({
				type: "triangle",
				shape: {
					cx: 0,
					cy: 0,
					width: 0,
					height: 0
				},
				buildPath: function(t, e) {
					var n = e.cx,
						i = e.cy,
						o = e.width / 2,
						r = e.height / 2;
					t.moveTo(n, i - r), t.lineTo(n + o, i + r), t.lineTo(n - o, i + r), t.closePath()
				}
			}),
			s = i.extendShape({
				type: "diamond",
				shape: {
					cx: 0,
					cy: 0,
					width: 0,
					height: 0
				},
				buildPath: function(t, e) {
					var n = e.cx,
						i = e.cy,
						o = e.width / 2,
						r = e.height / 2;
					t.moveTo(n, i - r), t.lineTo(n + o, i), t.lineTo(n, i + r), t.lineTo(n - o, i), t.closePath()
				}
			}),
			a = i.extendShape({
				type: "pin",
				shape: {
					x: 0,
					y: 0,
					width: 0,
					height: 0
				},
				buildPath: function(t, e) {
					var n = e.x,
						i = e.y,
						o = e.width / 5 * 3,
						r = Math.max(o, e.height),
						s = o / 2,
						a = s * s / (r - s),
						l = i - r + s + a,
						u = Math.asin(a / s),
						p = Math.cos(u) * s,
						h = Math.sin(u),
						c = Math.cos(u);
					t.arc(n, l, s, Math.PI - u, 2 * Math.PI + u);
					var g = .6 * s,
						d = .7 * s;
					t.bezierCurveTo(n + p - h * g, l + a + c * g, n, i - d, n, i), t.bezierCurveTo(n, i - d, n - p + h * g, l + a + c * g, n - p, l + a), t.closePath()
				}
			}),
			l = i.extendShape({
				type: "arrow",
				shape: {
					x: 0,
					y: 0,
					width: 0,
					height: 0
				},
				buildPath: function(t, e) {
					var n = e.height,
						i = e.width,
						o = e.x,
						r = e.y,
						s = i / 3 * 2;
					t.moveTo(o, r), t.lineTo(o + s, r + n), t.lineTo(o, r + n / 4 * 3), t.lineTo(o - s, r + n), t.lineTo(o, r), t.closePath()
				}
			}),
			u = {
				line: i.Line,
				rect: i.Rect,
				roundRect: i.Rect,
				square: i.Rect,
				circle: i.Circle,
				diamond: s,
				pin: a,
				arrow: l,
				triangle: r
			},
			p = {
				line: function(t, e, n, i, o) {
					o.x1 = t, o.y1 = e + i / 2, o.x2 = t + n, o.y2 = e + i / 2
				},
				rect: function(t, e, n, i, o) {
					o.x = t, o.y = e, o.width = n, o.height = i
				},
				roundRect: function(t, e, n, i, o) {
					o.x = t, o.y = e, o.width = n, o.height = i, o.r = Math.min(n, i) / 4
				},
				square: function(t, e, n, i, o) {
					var r = Math.min(n, i);
					o.x = t, o.y = e, o.width = r, o.height = r
				},
				circle: function(t, e, n, i, o) {
					o.cx = t + n / 2, o.cy = e + i / 2, o.r = Math.min(n, i) / 2
				},
				diamond: function(t, e, n, i, o) {
					o.cx = t + n / 2, o.cy = e + i / 2, o.width = n, o.height = i
				},
				pin: function(t, e, n, i, o) {
					o.x = t + n / 2, o.y = e + i / 2, o.width = n, o.height = i
				},
				arrow: function(t, e, n, i, o) {
					o.x = t + n / 2, o.y = e + i / 2, o.width = n, o.height = i
				},
				triangle: function(t, e, n, i, o) {
					o.cx = t + n / 2, o.cy = e + i / 2, o.width = n, o.height = i
				}
			},
			h = {};
		for (var c in u) h[c] = new u[c];
		var g = i.extendShape({
			type: "symbol",
			shape: {
				symbolType: "",
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			beforeBrush: function() {
				var t = this.style,
					e = this.shape;
				"pin" === e.symbolType && "inside" === t.textPosition && (t.textPosition = ["50%", "40%"], t.textAlign = "center", t.textVerticalAlign = "middle")
			},
			buildPath: function(t, e) {
				var n = e.symbolType,
					i = h[n];
				"none" !== e.symbolType && (i || (n = "rect", i = h[n]), p[n](e.x, e.y, e.width, e.height, i.shape), i.buildPath(t, i.shape))
			}
		}),
			d = function(t) {
				if ("image" !== this.type) {
					var e = this.style,
						n = this.shape;
					n && "line" === n.symbolType ? e.stroke = t : this.__isEmptyBrush ? (e.stroke = t, e.fill = "#fff") : (e.fill && (e.fill = t), e.stroke && (e.stroke = t)), this.dirty()
				}
			},
			f = {
				createSymbol: function(t, e, n, r, s, a) {
					var l = 0 === t.indexOf("empty");
					l && (t = t.substr(5, 1).toLowerCase() + t.substr(6));
					var u;
					return u = 0 === t.indexOf("image://") ? new i.Image({
						style: {
							image: t.slice(8),
							x: e,
							y: n,
							width: r,
							height: s
						}
					}) : 0 === t.indexOf("path://") ? i.makePath(t.slice(7), {}, new o(e, n, r, s)) : new g({
						shape: {
							symbolType: t,
							x: e,
							y: n,
							width: r,
							height: s
						}
					}), u.__isEmptyBrush = l, u.setColor = d, u.setColor(a), u
				}
			};
		t.exports = f
	}, function(t, e, n) {
		function i() {
			this.group = new s, this.uid = a.getUID("viewChart")
		}
		function o(t, e) {
			if (t && (t.trigger(e), "group" === t.type)) for (var n = 0; n < t.childCount(); n++) o(t.childAt(n), e)
		}
		function r(t, e, n) {
			if (null != e.dataIndex) {
				var i = t.getItemGraphicEl(e.dataIndex);
				o(i, n)
			} else if (e.name) {
				var r = t.indexOfName(e.name),
					i = t.getItemGraphicEl(r);
				o(i, n)
			} else t.eachItemGraphicEl(function(t) {
				o(t, n)
			})
		}
		var s = n(27),
			a = n(42),
			l = n(20);
		i.prototype = {
			type: "chart",
			init: function(t, e) {},
			render: function(t, e, n, i) {},
			highlight: function(t, e, n, i) {
				r(t.getData(), i, "emphasis")
			},
			downplay: function(t, e, n, i) {
				r(t.getData(), i, "normal")
			},
			remove: function(t, e) {
				this.group.removeAll()
			},
			dispose: function() {}
		};
		var u = i.prototype;
		u.updateView = u.updateLayout = u.updateVisual = function(t, e, n, i) {
			this.render(t, e, n, i)
		}, l.enableClassExtend(i), l.enableClassManagement(i, {
			registerWhenExtend: !0
		}), t.exports = i
	}, function(t, e, n) {
		var i = n(1),
			o = n(55),
			r = n(8),
			s = function(t) {
				t = t || {}, o.call(this, t);
				for (var e in t) this[e] = t[e];
				this._children = [], this.__storage = null, this.__dirty = !0
			};
		s.prototype = {
			constructor: s,
			type: "group",
			silent: !1,
			children: function() {
				return this._children.slice()
			},
			childAt: function(t) {
				return this._children[t]
			},
			childOfName: function(t) {
				for (var e = this._children, n = 0; n < e.length; n++) if (e[n].name === t) return e[n]
			},
			childCount: function() {
				return this._children.length
			},
			add: function(t) {
				return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this
			},
			addBefore: function(t, e) {
				if (t && t !== this && t.parent !== this && e && e.parent === this) {
					var n = this._children,
						i = n.indexOf(e);
					i >= 0 && (n.splice(i, 0, t), this._doAdd(t))
				}
				return this
			},
			_doAdd: function(t) {
				t.parent && t.parent.remove(t), t.parent = this;
				var e = this.__storage,
					n = this.__zr;
				e && e !== t.__storage && (e.addToMap(t), t instanceof s && t.addChildrenToStorage(e)), n && n.refresh()
			},
			remove: function(t) {
				var e = this.__zr,
					n = this.__storage,
					o = this._children,
					r = i.indexOf(o, t);
				return 0 > r ? this : (o.splice(r, 1), t.parent = null, n && (n.delFromMap(t.id), t instanceof s && t.delChildrenFromStorage(n)), e && e.refresh(), this)
			},
			removeAll: function() {
				var t, e, n = this._children,
					i = this.__storage;
				for (e = 0; e < n.length; e++) t = n[e], i && (i.delFromMap(t.id), t instanceof s && t.delChildrenFromStorage(i)), t.parent = null;
				return n.length = 0, this
			},
			eachChild: function(t, e) {
				for (var n = this._children, i = 0; i < n.length; i++) {
					var o = n[i];
					t.call(e, o, i)
				}
				return this
			},
			traverse: function(t, e) {
				for (var n = 0; n < this._children.length; n++) {
					var i = this._children[n];
					t.call(e, i), "group" === i.type && i.traverse(t, e)
				}
				return this
			},
			addChildrenToStorage: function(t) {
				for (var e = 0; e < this._children.length; e++) {
					var n = this._children[e];
					t.addToMap(n), n instanceof s && n.addChildrenToStorage(t)
				}
			},
			delChildrenFromStorage: function(t) {
				for (var e = 0; e < this._children.length; e++) {
					var n = this._children[e];
					t.delFromMap(n.id), n instanceof s && n.delChildrenFromStorage(t)
				}
			},
			dirty: function() {
				return this.__dirty = !0, this.__zr && this.__zr.refresh(), this
			},
			getBoundingRect: function(t) {
				for (var e = null, n = new r(0, 0, 0, 0), i = t || this._children, o = [], s = 0; s < i.length; s++) {
					var a = i[s];
					if (!a.ignore && !a.invisible) {
						var l = a.getBoundingRect(),
							u = a.getLocalTransform(o);
						u ? (n.copy(l), n.applyTransform(u), e = e || n.clone(), e.union(n)) : (e = e || l.clone(), e.union(l))
					}
				}
				return e || n
			}
		}, i.inherits(s, o), t.exports = s
	}, function(t, e, n) {
		"use strict";
		var i = n(16),
			o = n(5),
			r = n(65),
			s = n(8),
			a = n(33).devicePixelRatio,
			l = {
				M: 1,
				L: 2,
				C: 3,
				Q: 4,
				A: 5,
				Z: 6,
				R: 7
			},
			u = [],
			p = [],
			h = [],
			c = [],
			g = Math.min,
			d = Math.max,
			f = Math.cos,
			m = Math.sin,
			y = Math.sqrt,
			v = Math.abs,
			x = "undefined" != typeof Float32Array,
			j = function() {
				this.data = [], this._len = 0, this._ctx = null, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._ux = 0, this._uy = 0
			};
		j.prototype = {
			constructor: j,
			_lineDash: null,
			_dashOffset: 0,
			_dashIdx: 0,
			_dashSum: 0,
			setScale: function(t, e) {
				this._ux = v(1 / a / t) || 0, this._uy = v(1 / a / e) || 0
			},
			getContext: function() {
				return this._ctx
			},
			beginPath: function(t) {
				return this._ctx = t, t && t.beginPath(), this._len = 0, this._lineDash && (this._lineDash = null, this._dashOffset = 0), this
			},
			moveTo: function(t, e) {
				return this.addData(l.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this
			},
			lineTo: function(t, e) {
				var n = v(t - this._xi) > this._ux || v(e - this._yi) > this._uy || 0 === this._len;
				return this.addData(l.L, t, e), this._ctx && n && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), n && (this._xi = t, this._yi = e), this
			},
			bezierCurveTo: function(t, e, n, i, o, r) {
				return this.addData(l.C, t, e, n, i, o, r), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, n, i, o, r) : this._ctx.bezierCurveTo(t, e, n, i, o, r)), this._xi = o, this._yi = r, this
			},
			quadraticCurveTo: function(t, e, n, i) {
				return this.addData(l.Q, t, e, n, i), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, n, i) : this._ctx.quadraticCurveTo(t, e, n, i)), this._xi = n, this._yi = i, this
			},
			arc: function(t, e, n, i, o, r) {
				return this.addData(l.A, t, e, n, n, i, o - i, 0, r ? 0 : 1), this._ctx && this._ctx.arc(t, e, n, i, o, r), this._xi = f(o) * n + t, this._xi = m(o) * n + t, this
			},
			arcTo: function(t, e, n, i, o) {
				return this._ctx && this._ctx.arcTo(t, e, n, i, o), this
			},
			rect: function(t, e, n, i) {
				return this._ctx && this._ctx.rect(t, e, n, i), this.addData(l.R, t, e, n, i), this
			},
			closePath: function() {
				this.addData(l.Z);
				var t = this._ctx,
					e = this._x0,
					n = this._y0;
				return t && (this._needsDash() && this._dashedLineTo(e, n), t.closePath()), this._xi = e, this._yi = n, this
			},
			fill: function(t) {
				t && t.fill(), this.toStatic()
			},
			stroke: function(t) {
				t && t.stroke(), this.toStatic()
			},
			setLineDash: function(t) {
				if (t instanceof Array) {
					this._lineDash = t, this._dashIdx = 0;
					for (var e = 0, n = 0; n < t.length; n++) e += t[n];
					this._dashSum = e
				}
				return this
			},
			setLineDashOffset: function(t) {
				return this._dashOffset = t, this
			},
			len: function() {
				return this._len
			},
			setData: function(t) {
				var e = t.length;
				this.data && this.data.length == e || !x || (this.data = new Float32Array(e));
				for (var n = 0; e > n; n++) this.data[n] = t[n];
				this._len = e
			},
			appendPath: function(t) {
				t instanceof Array || (t = [t]);
				for (var e = t.length, n = 0, i = this._len, o = 0; e > o; o++) n += t[o].len();
				x && this.data instanceof Float32Array && (this.data = new Float32Array(i + n));
				for (var o = 0; e > o; o++) for (var r = t[o].data, s = 0; s < r.length; s++) this.data[i++] = r[s];
				this._len = i
			},
			addData: function(t) {
				var e = this.data;
				this._len + arguments.length > e.length && (this._expandData(), e = this.data);
				for (var n = 0; n < arguments.length; n++) e[this._len++] = arguments[n];
				this._prevCmd = t
			},
			_expandData: function() {
				if (!(this.data instanceof Array)) {
					for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
					this.data = t
				}
			},
			_needsDash: function() {
				return this._lineDash
			},
			_dashedLineTo: function(t, e) {
				var n, i, o = this._dashSum,
					r = this._dashOffset,
					s = this._lineDash,
					a = this._ctx,
					l = this._xi,
					u = this._yi,
					p = t - l,
					h = e - u,
					c = y(p * p + h * h),
					f = l,
					m = u,
					v = s.length;
				for (p /= c, h /= c, 0 > r && (r = o + r), r %= o, f -= r * p, m -= r * h; p >= 0 && t >= f || 0 > p && f > t;) i = this._dashIdx, n = s[i], f += p * n, m += h * n, this._dashIdx = (i + 1) % v, p > 0 && l > f || 0 > p && f > l || a[i % 2 ? "moveTo" : "lineTo"](p >= 0 ? g(f, t) : d(f, t), h >= 0 ? g(m, e) : d(m, e));
				p = f - t, h = m - e, this._dashOffset = -y(p * p + h * h)
			},
			_dashedBezierTo: function(t, e, n, o, r, s) {
				var a, l, u, p, h, c = this._dashSum,
					g = this._dashOffset,
					d = this._lineDash,
					f = this._ctx,
					m = this._xi,
					v = this._yi,
					x = i.cubicAt,
					j = 0,
					E = this._dashIdx,
					I = d.length,
					C = 0;
				for (0 > g && (g = c + g), g %= c, a = 0; 1 > a; a += .1) l = x(m, t, n, r, a + .1) - x(m, t, n, r, a), u = x(v, e, o, s, a + .1) - x(v, e, o, s, a), j += y(l * l + u * u);
				for (; I > E && (C += d[E], !(C > g)); E++);
				for (a = (C - g) / j; 1 >= a;) p = x(m, t, n, r, a), h = x(v, e, o, s, a), E % 2 ? f.moveTo(p, h) : f.lineTo(p, h), a += d[E] / j, E = (E + 1) % I;
				E % 2 !== 0 && f.lineTo(r, s), l = r - p, u = s - h, this._dashOffset = -y(l * l + u * u)
			},
			_dashedQuadraticTo: function(t, e, n, i) {
				var o = n,
					r = i;
				n = (n + 2 * t) / 3, i = (i + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, n, i, o, r)
			},
			toStatic: function() {
				var t = this.data;
				t instanceof Array && (t.length = this._len, x && (this.data = new Float32Array(t)))
			},
			getBoundingRect: function() {
				u[0] = u[1] = h[0] = h[1] = Number.MAX_VALUE, p[0] = p[1] = c[0] = c[1] = -Number.MAX_VALUE;
				for (var t = this.data, e = 0, n = 0, i = 0, a = 0, g = 0; g < t.length;) {
					var d = t[g++];
					switch (1 == g && (e = t[g], n = t[g + 1], i = e, a = n), d) {
					case l.M:
						i = t[g++], a = t[g++], e = i, n = a, h[0] = i, h[1] = a, c[0] = i, c[1] = a;
						break;
					case l.L:
						r.fromLine(e, n, t[g], t[g + 1], h, c), e = t[g++], n = t[g++];
						break;
					case l.C:
						r.fromCubic(e, n, t[g++], t[g++], t[g++], t[g++], t[g], t[g + 1], h, c), e = t[g++], n = t[g++];
						break;
					case l.Q:
						r.fromQuadratic(e, n, t[g++], t[g++], t[g], t[g + 1], h, c), e = t[g++], n = t[g++];
						break;
					case l.A:
						var y = t[g++],
							v = t[g++],
							x = t[g++],
							j = t[g++],
							E = t[g++],
							I = t[g++] + E,
							C = (t[g++], 1 - t[g++]);
						1 == g && (i = f(E) * x + y, a = m(E) * j + v), r.fromArc(y, v, x, j, E, I, C, h, c), e = f(I) * x + y, n = m(I) * j + v;
						break;
					case l.R:
						i = e = t[g++], a = n = t[g++];
						var S = t[g++],
							b = t[g++];
						r.fromLine(i, a, i + S, a + b, h, c);
						break;
					case l.Z:
						e = i, n = a
					}
					o.min(u, u, h), o.max(p, p, c)
				}
				return 0 === g && (u[0] = u[1] = p[0] = p[1] = 0), new s(u[0], u[1], p[0] - u[0], p[1] - u[1])
			},
			rebuildPath: function(t) {
				for (var e, n, i, o, r, s, a = this.data, u = this._ux, p = this._uy, h = this._len, c = 0; h > c;) {
					var g = a[c++];
					switch (1 == c && (i = a[c], o = a[c + 1], e = i, n = o), g) {
					case l.M:
						e = i = a[c++], n = o = a[c++], t.moveTo(i, o);
						break;
					case l.L:
						r = a[c++], s = a[c++], (v(r - i) > u || v(s - o) > p || c === h - 1) && (t.lineTo(r, s), i = r, o = s);
						break;
					case l.C:
						t.bezierCurveTo(a[c++], a[c++], a[c++], a[c++], a[c++], a[c++]), i = a[c - 2], o = a[c - 1];
						break;
					case l.Q:
						t.quadraticCurveTo(a[c++], a[c++], a[c++], a[c++]), i = a[c - 2], o = a[c - 1];
						break;
					case l.A:
						var d = a[c++],
							y = a[c++],
							x = a[c++],
							j = a[c++],
							E = a[c++],
							I = a[c++],
							C = a[c++],
							S = a[c++],
							b = x > j ? x : j,
							L = x > j ? 1 : x / j,
							w = x > j ? j / x : 1,
							P = Math.abs(x - j) > .001,
							M = E + I;
						P ? (t.translate(d, y), t.rotate(C), t.scale(L, w), t.arc(0, 0, b, E, M, 1 - S), t.scale(1 / L, 1 / w), t.rotate(-C), t.translate(-d, -y)) : t.arc(d, y, b, E, M, 1 - S), 1 == c && (e = f(E) * x + d, n = m(E) * j + y), i = f(M) * x + d, o = m(M) * j + y;
						break;
					case l.R:
						e = i = a[c], n = o = a[c + 1], t.rect(a[c++], a[c++], a[c++], a[c++]);
						break;
					case l.Z:
						t.closePath(), i = e, o = n
					}
				}
			}
		}, j.CMD = l, t.exports = j
	}, function(t, e) {
		"use strict";
		var n = {};
		t.exports = {
			register: function(t, e) {
				n[t] = e
			},
			get: function(t) {
				return n[t]
			}
		}
	}, function(t, e, n) {
		var i = n(1);
		t.exports = function(t) {
			for (var e = 0; e < t.length; e++) t[e][1] || (t[e][1] = t[e][0]);
			return function(e) {
				for (var n = {}, o = 0; o < t.length; o++) {
					var r = t[o][1];
					if (!(e && i.indexOf(e, r) >= 0)) {
						var s = this.getShallow(r);
						null != s && (n[t[o][0]] = s)
					}
				}
				return n
			}
		}
	}, function(t, e, n) {
		function i(t, e, n, i) {
			if (!e) return t;
			var a = r(e[0]),
				l = s.isArray(a) && a.length || 1;
			n = n || [], i = i || "extra";
			for (var u = 0; l > u; u++) if (!t[u]) {
				var p = n[u] || i + (u - n.length);
				t[u] = o(e, u) ? {
					type: "ordinal",
					name: p
				} : p
			}
			return t
		}
		function o(t, e) {
			for (var n = 0, i = t.length; i > n; n++) {
				var o = r(t[n]);
				if (!s.isArray(o)) return !1;
				var o = o[e];
				if (null != o && isFinite(o)) return !1;
				if (s.isString(o) && "-" !== o) return !0
			}
			return !1
		}
		function r(t) {
			return s.isArray(t) ? t : s.isObject(t) ? t.value : t
		}
		var s = n(1);
		t.exports = i
	}, function(t, e, n) {
		function i() {
			this._extent = [1 / 0, -(1 / 0)], this._interval = 0, this.init && this.init.apply(this, arguments)
		}
		var o = n(20),
			r = i.prototype;
		r.parse = function(t) {
			return t
		}, r.contain = function(t) {
			var e = this._extent;
			return t >= e[0] && t <= e[1]
		}, r.normalize = function(t) {
			var e = this._extent;
			return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
		}, r.scale = function(t) {
			var e = this._extent;
			return t * (e[1] - e[0]) + e[0]
		}, r.unionExtent = function(t) {
			var e = this._extent;
			t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
		}, r.getExtent = function() {
			return this._extent.slice()
		}, r.setExtent = function(t, e) {
			var n = this._extent;
			isNaN(t) || (n[0] = t), isNaN(e) || (n[1] = e)
		}, r.getTicksLabels = function() {
			for (var t = [], e = this.getTicks(), n = 0; n < e.length; n++) t.push(this.getLabel(e[n]));
			return t
		}, o.enableClassExtend(i), o.enableClassManagement(i, {
			registerWhenExtend: !0
		}), t.exports = i
	}, function(t, e) {
		var n = 1;
		"undefined" != typeof window && (n = Math.max(window.devicePixelRatio || 1, 1));
		var i = {
			debugMode: 0,
			devicePixelRatio: n
		};
		t.exports = i
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			return t.getBoundingClientRect ? t.getBoundingClientRect() : {
				left: 0,
				top: 0
			}
		}
		function o(t, e) {
			if (e = e || window.event, null != e.zrX) return e;
			var n = e.type,
				o = n && n.indexOf("touch") >= 0;
			if (o) {
				var r = "touchend" != n ? e.targetTouches[0] : e.changedTouches[0];
				if (r) {
					var s = i(t);
					e.zrX = r.clientX - s.left, e.zrY = r.clientY - s.top
				}
			} else {
				var a = i(t);
				e.zrX = e.clientX - a.left, e.zrY = e.clientY - a.top, e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3
			}
			return e
		}
		function r(t, e, n) {
			l ? t.addEventListener(e, n) : t.attachEvent("on" + e, n)
		}
		function s(t, e, n) {
			l ? t.removeEventListener(e, n) : t.detachEvent("on" + e, n)
		}
		var a = n(21),
			l = "undefined" != typeof window && !! window.addEventListener,
			u = l ?
		function(t) {
			t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
		} : function(t) {
			t.returnValue = !1, t.cancelBubble = !0
		};
		t.exports = {
			normalizeEvent: o,
			addEventListener: r,
			removeEventListener: s,
			stop: u,
			Dispatcher: a
		}
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			for (var e = 0; e < t.length && null == t[e];) e++;
			return t[e]
		}
		function o(t) {
			var e = i(t);
			return null != e && !h.isArray(d(e))
		}
		function r(t, e, n) {
			if (t = t || [], !h.isArray(t)) throw new Error("Invalid data.");
			var i = e.get("coordinateSystem"),
				r = m[i],
				s = g.get(i),
				a = r && r(t, e, n),
				c = a && a.dimensions;
			c || (c = s && s.dimensions || ["x", "y"], c = p(c, t, c.concat(["value"])));
			var y, v = a && a.categoryAxisModel,
				x = "ordinal" === c[0].type ? 0 : "ordinal" === c[1].type ? 1 : -1,
				j = new u(c, e),
				E = l(a, t),
				I = v && o(t) ?
			function(t, e, n, i) {
				return i === x ? n : f(d(t), c[i])
			} : function(t, e, n, i) {
				var o = d(t),
					r = f(o && o[i], c[i]);
				return x === i && "string" == typeof r && (y = y || v.getCategories(), r = h.indexOf(y, r), 0 > r && !isNaN(r) && (r = +r)), r
			};
			return j.initData(t, E, I), j
		}
		function s(t) {
			return "category" !== t && "time" !== t
		}
		function a(t) {
			return "category" === t ? "ordinal" : "time" === t ? "time" : "float"
		}
		function l(t, e) {
			var n = [];
			if (t && t.categoryAxisModel) {
				var i = t.categoryAxisModel.getCategories();
				if (i) {
					var o = e.length;
					if (h.isArray(e[0]) && e[0].length > 1) {
						n = [];
						for (var r = 0; o > r; r++) n[r] = i[e[r][t.categoryIndex || 0]]
					} else n = i.slice(0)
				}
			}
			return n
		}
		var u = n(15),
			p = n(31),
			h = n(1),
			c = n(7),
			g = n(23),
			d = c.getDataItemValue,
			f = c.converDataValue,
			m = {
				cartesian2d: function(t, e, n) {
					var i = n.getComponent("xAxis", e.get("xAxisIndex")),
						o = n.getComponent("yAxis", e.get("yAxisIndex"));
					if (!i || !o) throw new Error("Axis option not found");
					var r = i.get("type"),
						l = o.get("type"),
						u = [{
							name: "x",
							type: a(r),
							stackable: s(r)
						}, {
							name: "y",
							type: a(l),
							stackable: s(l)
						}],
						h = "category" === r;
					return p(u, t, ["x", "y", "z"]), {
						dimensions: u,
						categoryIndex: h ? 0 : 1,
						categoryAxisModel: h ? i : "category" === l ? o : null
					}
				},
				polar: function(t, e, n) {
					var i = e.get("polarIndex") || 0,
						o = function(t) {
							return t.get("polarIndex") === i
						},
						r = n.findComponents({
							mainType: "angleAxis",
							filter: o
						})[0],
						l = n.findComponents({
							mainType: "radiusAxis",
							filter: o
						})[0];
					if (!r || !l) throw new Error("Axis option not found");
					var u = l.get("type"),
						h = r.get("type"),
						c = [{
							name: "radius",
							type: a(u),
							stackable: s(u)
						}, {
							name: "angle",
							type: a(h),
							stackable: s(h)
						}],
						g = "category" === h;
					return p(c, t, ["radius", "angle", "value"]), {
						dimensions: c,
						categoryIndex: g ? 1 : 0,
						categoryAxisModel: g ? r : "category" === u ? l : null
					}
				},
				geo: function(t, e, n) {
					return {
						dimensions: p([{
							name: "lng"
						}, {
							name: "lat"
						}], t, ["lng", "lat", "value"])
					}
				}
			};
		t.exports = r
	}, function(t, e, n) {
		"use strict";
		var i = n(3),
			o = n(1);
		n(52), n(95), n(2).extendComponentView({
			type: "grid",
			render: function(t, e) {
				this.group.removeAll(), t.get("show") && this.group.add(new i.Rect({
					shape: t.coordinateSystem.getRect(),
					style: o.defaults({
						fill: t.get("backgroundColor")
					}, t.getItemStyle()),
					silent: !0
				}))
			}
		})
	}, function(t, e, n) {
		function i(t) {
			t = t || {}, s.call(this, t);
			for (var e in t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
			this.style = new r(t.style), this._rect = null, this.__clipPaths = []
		}
		var o = n(1),
			r = n(142),
			s = n(55),
			a = n(67);
		i.prototype = {
			constructor: i,
			type: "displayable",
			__dirty: !0,
			invisible: !1,
			z: 0,
			z2: 0,
			zlevel: 0,
			draggable: !1,
			dragging: !1,
			silent: !1,
			culling: !1,
			cursor: "pointer",
			rectHover: !1,
			beforeBrush: function(t) {},
			afterBrush: function(t) {},
			brush: function(t) {},
			getBoundingRect: function() {},
			contain: function(t, e) {
				return this.rectContain(t, e)
			},
			traverse: function(t, e) {
				t.call(e, this)
			},
			rectContain: function(t, e) {
				var n = this.transformCoordToLocal(t, e),
					i = this.getBoundingRect();
				return i.contain(n[0], n[1])
			},
			dirty: function() {
				this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh()
			},
			animateStyle: function(t) {
				return this.animate("style", t)
			},
			attrKV: function(t, e) {
				"style" !== t ? s.prototype.attrKV.call(this, t, e) : this.style.set(e)
			},
			setStyle: function(t, e) {
				return this.style.set(t, e), this.dirty(!1), this
			},
			useStyle: function(t) {
				return this.style = new r(t), this.dirty(!1), this
			}
		}, o.inherits(i, s), o.mixin(i, a), t.exports = i
	}, function(t, e, n) {
		var i = n(4),
			o = n(9),
			r = n(32),
			s = Math.floor,
			a = Math.ceil,
			l = r.extend({
				type: "interval",
				_interval: 0,
				setExtent: function(t, e) {
					var n = this._extent;
					isNaN(t) || (n[0] = parseFloat(t)), isNaN(e) || (n[1] = parseFloat(e))
				},
				unionExtent: function(t) {
					var e = this._extent;
					t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), l.prototype.setExtent.call(this, e[0], e[1])
				},
				getInterval: function() {
					return this._interval || this.niceTicks(), this._interval
				},
				setInterval: function(t) {
					this._interval = t, this._niceExtent = this._extent.slice()
				},
				getTicks: function() {
					this._interval || this.niceTicks();
					var t = this._interval,
						e = this._extent,
						n = [],
						o = 1e4;
					if (t) {
						var r = this._niceExtent;
						e[0] < r[0] && n.push(e[0]);
						for (var s = r[0]; s <= r[1];) if (n.push(s), s = i.round(s + t), n.length > o) return [];
						e[1] > r[1] && n.push(e[1])
					}
					return n
				},
				getTicksLabels: function() {
					for (var t = [], e = this.getTicks(), n = 0; n < e.length; n++) t.push(this.getLabel(e[n]));
					return t
				},
				getLabel: function(t) {
					return o.addCommas(t)
				},
				niceTicks: function(t) {
					t = t || 5;
					var e = this._extent,
						n = e[1] - e[0];
					if (isFinite(n)) {
						0 > n && (n = -n, e.reverse());
						var o = i.nice(n / t, !0),
							r = [i.round(a(e[0] / o) * o), i.round(s(e[1] / o) * o)];
						this._interval = o, this._niceExtent = r
					}
				},
				niceExtent: function(t, e, n) {
					var o = this._extent;
					if (o[0] === o[1]) if (0 !== o[0]) {
						var r = o[0] / 2;
						o[0] -= r, o[1] += r
					} else o[1] = 1;
					var l = o[1] - o[0];
					isFinite(l) || (o[0] = 0, o[1] = 1), this.niceTicks(t);
					var u = this._interval;
					e || (o[0] = i.round(s(o[0] / u) * u)), n || (o[1] = i.round(a(o[1] / u) * u))
				}
			});
		l.create = function() {
			return new l
		}, t.exports = l
	}, function(t, e, n) {
		function i(t) {
			this.group = new r.Group, this._symbolCtor = t || s
		}
		function o(t, e, n) {
			var i = t.getItemLayout(e);
			return i && !isNaN(i[0]) && !isNaN(i[1]) && !(n && n(e)) && "none" !== t.getItemVisual(e, "symbol")
		}
		var r = n(3),
			s = n(47),
			a = i.prototype;
		a.updateData = function(t, e) {
			var n = this.group,
				i = t.hostModel,
				s = this._data,
				a = this._symbolCtor;
			t.diff(s).add(function(i) {
				var r = t.getItemLayout(i);
				if (o(t, i, e)) {
					var s = new a(t, i);
					s.attr("position", r), t.setItemGraphicEl(i, s), n.add(s)
				}
			}).update(function(l, u) {
				var p = s.getItemGraphicEl(u),
					h = t.getItemLayout(l);
				return o(t, l, e) ? (p ? (p.updateData(t, l), r.updateProps(p, {
					position: h
				}, i)) : (p = new a(t, l), p.attr("position", h)), n.add(p), void t.setItemGraphicEl(l, p)) : void n.remove(p)
			}).remove(function(t) {
				var e = s.getItemGraphicEl(t);
				e && e.fadeOut(function() {
					n.remove(e)
				})
			}).execute(), this._data = t
		}, a.updateLayout = function() {
			var t = this._data;
			t && t.eachItemGraphicEl(function(e, n) {
				e.attr("position", t.getItemLayout(n))
			})
		}, a.remove = function(t) {
			var e = this.group,
				n = this._data;
			n && (t ? n.eachItemGraphicEl(function(t) {
				t.fadeOut(function() {
					e.remove(t)
				})
			}) : e.removeAll())
		}, t.exports = i
	}, function(t, e, n) {
		function i(t) {
			var e = {};
			return p(["start", "end", "startValue", "endValue"], function(n) {
				e[n] = t[n]
			}), e
		}
		function o(t, e, n, i) {
			null != n[e] && null == n[t] && (i[t] = null)
		}
		var r = n(1),
			s = n(14),
			a = n(2),
			l = n(7),
			u = n(169),
			p = r.each,
			h = l.eachAxisDim,
			c = a.extendComponentModel({
				type: "dataZoom",
				dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "series"],
				defaultOption: {
					zlevel: 0,
					z: 4,
					orient: null,
					xAxisIndex: null,
					yAxisIndex: null,
					angleAxisIndex: null,
					radiusAxisIndex: null,
					filterMode: "filter",
					throttle: 100,
					start: 0,
					end: 100,
					startValue: null,
					endValue: null
				},
				init: function(t, e, n) {
					this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel;
					var o = i(t);
					this.mergeDefaultAndTheme(t, n), this.doInit(o)
				},
				mergeOption: function(t) {
					var e = i(t);
					r.merge(this.option, t, !0), this.doInit(e)
				},
				doInit: function(t) {
					var e = this.option;
					s.canvasSupported || (e.realtime = !1), o("start", "startValue", t, e), o("end", "endValue", t, e), this.textStyleModel = this.getModel("textStyle"), this._resetTarget(), this._giveAxisProxies()
				},
				_giveAxisProxies: function() {
					var t = this._axisProxies;
					this.eachTargetAxis(function(e, n, i, o) {
						var r = this.dependentModels[e.axis][n],
							s = r.__dzAxisProxy || (r.__dzAxisProxy = new u(e.name, n, this, o));
						t[e.name + "_" + n] = s
					}, this)
				},
				_resetTarget: function() {
					var t = this.option,
						e = this._judgeAutoMode();
					h(function(e) {
						var n = e.axisIndex;
						t[n] = l.normalizeToArray(t[n])
					}, this), "axisIndex" === e ? this._autoSetAxisIndex() : "orient" === e && this._autoSetOrient()
				},
				_judgeAutoMode: function() {
					var t = this.option,
						e = !1;
					h(function(n) {
						null != t[n.axisIndex] && (e = !0)
					}, this);
					var n = t.orient;
					return null == n && e ? "orient" : e ? void 0 : (null == n && (t.orient = "horizontal"), "axisIndex")
				},
				_autoSetAxisIndex: function() {
					var t = !0,
						e = this.get("orient", !0),
						n = this.option;
					if (t) {
						var i = "vertical" === e ? {
							dim: "y",
							axisIndex: "yAxisIndex",
							axis: "yAxis"
						} : {
							dim: "x",
							axisIndex: "xAxisIndex",
							axis: "xAxis"
						};
						this.dependentModels[i.axis].length && (n[i.axisIndex] = [0], t = !1)
					}
					t && h(function(e) {
						if (t) {
							var i = [],
								o = this.dependentModels[e.axis];
							if (o.length && !i.length) for (var r = 0, s = o.length; s > r; r++)"category" === o[r].get("type") && i.push(r);
							n[e.axisIndex] = i, i.length && (t = !1)
						}
					}, this), t && this.ecModel.eachSeries(function(t) {
						this._isSeriesHasAllAxesTypeOf(t, "value") && h(function(e) {
							var i = n[e.axisIndex],
								o = t.get(e.axisIndex);
							r.indexOf(i, o) < 0 && i.push(o)
						})
					}, this)
				},
				_autoSetOrient: function() {
					var t;
					this.eachTargetAxis(function(e) {
						!t && (t = e.name)
					}, this), this.option.orient = "y" === t ? "vertical" : "horizontal"
				},
				_isSeriesHasAllAxesTypeOf: function(t, e) {
					var n = !0;
					return h(function(i) {
						var o = t.get(i.axisIndex),
							r = this.dependentModels[i.axis][o];
						r && r.get("type") === e || (n = !1)
					}, this), n
				},
				getFirstTargetAxisModel: function() {
					var t;
					return h(function(e) {
						if (null == t) {
							var n = this.get(e.axisIndex);
							n.length && (t = this.dependentModels[e.axis][n[0]])
						}
					}, this), t
				},
				eachTargetAxis: function(t, e) {
					var n = this.ecModel;
					h(function(i) {
						p(this.get(i.axisIndex), function(o) {
							t.call(e, i, o, this, n)
						}, this)
					}, this)
				},
				getAxisProxy: function(t, e) {
					return this._axisProxies[t + "_" + e]
				},
				setRawRange: function(t) {
					p(["start", "end", "startValue", "endValue"], function(e) {
						this.option[e] = t[e]
					}, this)
				},
				getPercentRange: function() {
					var t = this.findRepresentativeAxisProxy();
					return t ? t.getDataPercentWindow() : void 0
				},
				getValueRange: function(t, e) {
					if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow();
					var n = this.findRepresentativeAxisProxy();
					return n ? n.getDataValueWindow() : void 0
				},
				findRepresentativeAxisProxy: function() {
					var t = this._axisProxies;
					for (var e in t) if (t.hasOwnProperty(e) && t[e].hostedBy(this)) return t[e];
					for (var e in t) if (t.hasOwnProperty(e) && !t[e].hostedBy(this)) return t[e]
				}
			});
		t.exports = c
	}, function(t, e, n) {
		var i = n(54);
		t.exports = i.extend({
			type: "dataZoom",
			render: function(t, e, n, i) {
				this.dataZoomModel = t, this.ecModel = e, this.api = n
			},
			getTargetInfo: function() {
				function t(t, e, n, i) {
					for (var o, r = 0; r < n.length; r++) if (n[r].model === t) {
						o = n[r];
						break
					}
					o || n.push(o = {
						model: t,
						axisModels: [],
						coordIndex: i
					}), o.axisModels.push(e)
				}
				var e = this.dataZoomModel,
					n = this.ecModel,
					i = [],
					o = [],
					r = [];
				return e.eachTargetAxis(function(e, s) {
					var a = n.getComponent(e.axis, s);
					if (a) {
						r.push(a);
						var l = a.get("gridIndex"),
							u = a.get("polarIndex");
						if (null != l) {
							var p = n.getComponent("grid", l);
							t(p, a, i, l)
						} else if (null != u) {
							var p = n.getComponent("polar", u);
							t(p, a, o, u)
						}
					}
				}, this), {
					cartesians: i,
					polars: o,
					axisModels: r
				}
			}
		})
	}, function(t, e, n) {
		var i = n(1),
			o = n(20),
			r = o.parseClassType,
			s = 0,
			a = {},
			l = "_";
		a.getUID = function(t) {
			return [t || "", s++, Math.random()].join(l)
		}, a.enableSubTypeDefaulter = function(t) {
			var e = {};
			return t.registerSubTypeDefaulter = function(t, n) {
				t = r(t), e[t.main] = n
			}, t.determineSubType = function(n, i) {
				var o = i.type;
				if (!o) {
					var s = r(n).main;
					t.hasSubTypes(n) && e[s] && (o = e[s](i))
				}
				return o
			}, t
		}, a.enableTopologicalTravel = function(t, e) {
			function n(t) {
				var n = {},
					s = [];
				return i.each(t, function(a) {
					var l = o(n, a),
						u = l.originalDeps = e(a),
						p = r(u, t);
					l.entryCount = p.length, 0 === l.entryCount && s.push(a), i.each(p, function(t) {
						i.indexOf(l.predecessor, t) < 0 && l.predecessor.push(t);
						var e = o(n, t);
						i.indexOf(e.successor, t) < 0 && e.successor.push(a)
					})
				}), {
					graph: n,
					noEntryList: s
				}
			}
			function o(t, e) {
				return t[e] || (t[e] = {
					predecessor: [],
					successor: []
				}), t[e]
			}
			function r(t, e) {
				var n = [];
				return i.each(t, function(t) {
					i.indexOf(e, t) >= 0 && n.push(t)
				}), n
			}
			t.topologicalTravel = function(t, e, o, r) {
				function s(t) {
					u[t].entryCount--, 0 === u[t].entryCount && p.push(t)
				}
				function a(t) {
					h[t] = !0, s(t)
				}
				if (t.length) {
					var l = n(e),
						u = l.graph,
						p = l.noEntryList,
						h = {};
					for (i.each(t, function(t) {
						h[t] = !0
					}); p.length;) {
						var c = p.pop(),
							g = u[c],
							d = !! h[c];
						d && (o.call(r, c, g.originalDeps.slice()), delete h[c]), i.each(g.successor, d ? a : s)
					}
					i.each(h, function() {
						throw new Error("Circle dependency may exists")
					})
				}
			}
		}, t.exports = a
	}, function(t, e, n) {
		function i(t, e) {
			var n = t[1] - t[0],
				i = e,
				o = n / i / 2;
			t[0] += o, t[1] -= o
		}
		var o = n(4),
			r = o.linearMap,
			s = n(1),
			a = [0, 1],
			l = function(t, e, n) {
				this.dim = t, this.scale = e, this._extent = n || [0, 0], this.inverse = !1, this.onBand = !1
			};
		l.prototype = {
			constructor: l,
			contain: function(t) {
				var e = this._extent,
					n = Math.min(e[0], e[1]),
					i = Math.max(e[0], e[1]);
				return t >= n && i >= t
			},
			containData: function(t) {
				return this.contain(this.dataToCoord(t))
			},
			getExtent: function() {
				var t = this._extent.slice();
				return t
			},
			getPixelPrecision: function(t) {
				return o.getPixelPrecision(t || this.scale.getExtent(), this._extent)
			},
			setExtent: function(t, e) {
				var n = this._extent;
				n[0] = t, n[1] = e
			},
			dataToCoord: function(t, e) {
				var n = this._extent,
					o = this.scale;
				return t = o.normalize(t), this.onBand && "ordinal" === o.type && (n = n.slice(), i(n, o.count())), r(t, a, n, e)
			},
			coordToData: function(t, e) {
				var n = this._extent,
					o = this.scale;
				this.onBand && "ordinal" === o.type && (n = n.slice(), i(n, o.count()));
				var s = r(t, n, a, e);
				return this.scale.scale(s)
			},
			getTicksCoords: function() {
				if (this.onBand) {
					for (var t = this.getBands(), e = [], n = 0; n < t.length; n++) e.push(t[n][0]);
					return t[n - 1] && e.push(t[n - 1][1]), e
				}
				return s.map(this.scale.getTicks(), this.dataToCoord, this)
			},
			getLabelsCoords: function() {
				if (this.onBand) {
					for (var t, e = this.getBands(), n = [], i = 0; i < e.length; i++) t = e[i], n.push((t[0] + t[1]) / 2);
					return n
				}
				return s.map(this.scale.getTicks(), this.dataToCoord, this)
			},
			getBands: function() {
				for (var t = this.getExtent(), e = [], n = this.scale.count(), i = t[0], o = t[1], r = o - i, s = 0; n > s; s++) e.push([r * s / n + i, r * (s + 1) / n + i]);
				return e
			},
			getBandWidth: function() {
				var t = this._extent,
					e = this.scale.getExtent(),
					n = e[1] - e[0] + (this.onBand ? 1 : 0);
				0 === n && (n = 1);
				var i = Math.abs(t[1] - t[0]);
				return Math.abs(i) / n
			}
		}, t.exports = l
	}, function(t, e) {
		t.exports = function(t, e, n, i, o) {
			i.eachRawSeriesByType(t, function(t) {
				var o = t.getData(),
					r = t.get("symbol") || e,
					s = t.get("symbolSize");
				o.setVisual({
					legendSymbol: n || r,
					symbol: r,
					symbolSize: s
				}), i.isSeriesFiltered(t) || ("function" == typeof s && o.each(function(e) {
					var n = t.getRawValue(e),
						i = t.getDataParams(e);
					o.setItemVisual(e, "symbolSize", s(n, i))
				}), o.each(function(t) {
					var e = o.getItemModel(t),
						n = e.get("symbol", !0),
						i = e.get("symbolSize", !0);
					null != n && o.setItemVisual(t, "symbol", n), null != i && o.setItemVisual(t, "symbolSize", i)
				}))
			})
		}
	}, function(t, e, n) {
		var i = n(33);
		t.exports = function() {
			if (0 !== i.debugMode) if (1 == i.debugMode) for (var t in arguments) throw new Error(arguments[t]);
			else if (i.debugMode > 1) for (var t in arguments) console.log(arguments[t])
		}
	}, function(t, e, n) {
		function i(t) {
			o.call(this, t)
		}
		var o = n(37),
			r = n(8),
			s = n(1),
			a = n(60),
			l = n(139),
			u = new l(50);
		i.prototype = {
			constructor: i,
			type: "image",
			brush: function(t) {
				var e, n = this.style,
					i = n.image;
				if (e = "string" == typeof i ? this._image : i, !e && i) {
					var o = u.get(i);
					if (!o) return e = new Image, e.onload = function() {
						e.onload = null;
						for (var t = 0; t < o.pending.length; t++) o.pending[t].dirty()
					}, o = {
						image: e,
						pending: [this]
					}, e.src = i, u.put(i, o), void(this._image = e);
					if (e = o.image, this._image = e, !e.width || !e.height) return void o.pending.push(this)
				}
				if (e) {
					var r = n.width || e.width,
						s = n.height || e.height,
						l = n.x || 0,
						p = n.y || 0;
					if (!e.width || !e.height) return;
					if (t.save(), n.bind(t), this.setTransform(t), n.r && (t.beginPath(), a.buildPath(t, n), t.clip()), n.sWidth && n.sHeight) {
						var h = n.sx || 0,
							c = n.sy || 0;
						t.drawImage(e, h, c, n.sWidth, n.sHeight, l, p, r, s)
					} else if (n.sx && n.sy) {
						var h = n.sx,
							c = n.sy,
							g = r - h,
							d = s - c;
						t.drawImage(e, h, c, g, d, l, p, r, s)
					} else t.drawImage(e, l, p, r, s);
					null == n.width && (n.width = r), null == n.height && (n.height = s), null != n.text && this.drawRectText(t, this.getBoundingRect()), t.restore()
				}
			},
			getBoundingRect: function() {
				var t = this.style;
				return this._rect || (this._rect = new r(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect
			}
		}, s.inherits(i, o), t.exports = i
	}, function(t, e, n) {
		function i(t) {
			return s.isArray(t) || (t = [+t, +t]), t
		}
		function o(t, e) {
			l.Group.call(this), this.updateData(t, e)
		}
		function r(t, e) {
			this.parent.drift(t, e)
		}
		var s = n(1),
			a = n(25),
			l = n(3),
			u = n(4),
			p = o.prototype;
		p._createSymbol = function(t, e, n) {
			this.removeAll();
			var o = e.hostModel,
				s = e.getItemVisual(n, "color"),
				u = a.createSymbol(t, -.5, -.5, 1, 1, s);
			u.attr({
				z2: 100,
				culling: !0,
				scale: [0, 0]
			}), u.drift = r;
			var p = i(e.getItemVisual(n, "symbolSize"));
			l.initProps(u, {
				scale: p
			}, o, n), this._symbolType = t, this.add(u)
		}, p.stopSymbolAnimation = function(t) {
			this.childAt(0).stopAnimation(t)
		}, p.getScale = function() {
			return this.childAt(0).scale
		}, p.highlight = function() {
			this.childAt(0).trigger("emphasis")
		}, p.downplay = function() {
			this.childAt(0).trigger("normal")
		}, p.setZ = function(t, e) {
			var n = this.childAt(0);
			n.zlevel = t, n.z = e
		}, p.setDraggable = function(t) {
			var e = this.childAt(0);
			e.draggable = t, e.cursor = t ? "move" : "pointer"
		}, p.updateData = function(t, e) {
			var n = t.getItemVisual(e, "symbol") || "circle",
				o = t.hostModel,
				r = i(t.getItemVisual(e, "symbolSize"));
			if (n !== this._symbolType) this._createSymbol(n, t, e);
			else {
				var s = this.childAt(0);
				l.updateProps(s, {
					scale: r
				}, o, e)
			}
			this._updateCommon(t, e, r), this._seriesModel = o
		};
		var h = ["itemStyle", "normal"],
			c = ["itemStyle", "emphasis"],
			g = ["label", "normal"],
			d = ["label", "emphasis"];
		p._updateCommon = function(t, e, n) {
			var o = this.childAt(0),
				r = t.hostModel,
				a = t.getItemModel(e),
				p = a.getModel(h),
				f = t.getItemVisual(e, "color");
			"image" !== o.type && o.useStyle({
				strokeNoScale: !0
			});
			var m = o.style,
				y = a.getModel(c).getItemStyle();
			o.rotation = (a.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0;
			var v = a.getShallow("symbolOffset");
			if (v) {
				var x = o.position;
				x[0] = u.parsePercent(v[0], n[0]), x[1] = u.parsePercent(v[1], n[1])
			}
			o.setColor(f), s.extend(m, p.getItemStyle(["color"]));
			var j = t.getItemVisual(e, "opacity");
			null != j && (m.opacity = j);
			for (var E, I, C = a.getModel(g), S = a.getModel(d), b = t.dimensions.slice(); b.length && (E = b.pop(), I = t.getDimensionInfo(E).type, "ordinal" === I || "time" === I););
			null != E && C.get("show") ? (l.setText(m, C, f), m.text = s.retrieve(r.getFormattedLabel(e, "normal"), t.get(E, e))) : m.text = "", null != E && S.getShallow("show") ? (l.setText(y, S, f), y.text = s.retrieve(r.getFormattedLabel(e, "emphasis"), t.get(E, e))) : y.text = "";
			var L = i(t.getItemVisual(e, "symbolSize"));
			if (o.off("mouseover").off("mouseout").off("emphasis").off("normal"), l.setHoverStyle(o, y), a.getShallow("hoverAnimation")) {
				var w = function() {
						var t = L[1] / L[0];
						this.animateTo({
							scale: [Math.max(1.1 * L[0], L[0] + 3), Math.max(1.1 * L[1], L[1] + 3 * t)]
						}, 400, "elasticOut")
					},
					P = function() {
						this.animateTo({
							scale: L
						}, 400, "elasticOut")
					};
				o.on("mouseover", w).on("mouseout", P).on("emphasis", w).on("normal", P)
			}
		}, p.fadeOut = function(t) {
			var e = this.childAt(0);
			e.off("mouseover").off("mouseout").off("emphasis").off("normal"), e.style.text = "", l.updateProps(e, {
				scale: [0, 0]
			}, this._seriesModel, this.dataIndex, t)
		}, s.inherits(o, l.Group), t.exports = o
	}, function(t, e) {
		"use strict";

		function n(t) {
			return t
		}
		function i(t, e, i, o) {
			this._old = t, this._new = e, this._oldKeyGetter = i || n, this._newKeyGetter = o || n
		}
		function o(t, e, n) {
			for (var i = 0; i < t.length; i++) {
				var o = n(t[i]),
					r = e[o];
				null == r ? e[o] = i : (r.length || (e[o] = r = [r]), r.push(i))
			}
		}
		i.prototype = {
			constructor: i,
			add: function(t) {
				return this._add = t, this
			},
			update: function(t) {
				return this._update = t, this
			},
			remove: function(t) {
				return this._remove = t, this
			},
			execute: function() {
				var t, e = this._old,
					n = this._new,
					i = this._oldKeyGetter,
					r = this._newKeyGetter,
					s = {},
					a = {};
				for (o(e, s, i), o(n, a, r), t = 0; t < e.length; t++) {
					var l = i(e[t]),
						u = a[l];
					if (null != u) {
						var p = u.length;
						p ? (1 === p && (a[l] = null), u = u.unshift()) : a[l] = null, this._update && this._update(u, t)
					} else this._remove && this._remove(t)
				}
				for (var l in a) if (a.hasOwnProperty(l)) {
					var u = a[l];
					if (null == u) continue;
					if (u.length) for (var t = 0, p = u.length; p > t; t++) this._add && this._add(u[t]);
					else this._add && this._add(u)
				}
			}
		}, t.exports = i
	}, function(t, e, n) {
		function i(t) {
			var e = {
				componentType: t.mainType
			};
			return e[t.mainType + "Index"] = t.componentIndex, e
		}
		function o(t, e, n) {
			var i, o, r = p(e - t.rotation);
			return h(r) ? (o = n > 0 ? "top" : "bottom", i = "center") : h(r - c) ? (o = n > 0 ? "bottom" : "top", i = "center") : (o = "middle", i = r > 0 && c > r ? n > 0 ? "right" : "left" : n > 0 ? "left" : "right"), {
				rotation: r,
				textAlign: i,
				verticalAlign: o
			}
		}
		function r(t, e, n) {
			var i, o, r = p(-t.rotation),
				s = n[0] > n[1],
				a = "start" === e && !s || "start" !== e && s;
			return h(r - c / 2) ? (o = a ? "bottom" : "top", i = "center") : h(r - 1.5 * c) ? (o = a ? "top" : "bottom", i = "center") : (o = "middle", i = 1.5 * c > r && r > c / 2 ? a ? "left" : "right" : a ? "right" : "left"), {
				rotation: r,
				textAlign: i,
				verticalAlign: o
			}
		}
		var s = n(1),
			a = n(3),
			l = n(12),
			u = n(4),
			p = u.remRadian,
			h = u.isRadianAroundZero,
			c = Math.PI,
			g = function(t, e) {
				this.opt = e, this.axisModel = t, s.defaults(e, {
					labelOffset: 0,
					nameDirection: 1,
					tickDirection: 1,
					labelDirection: 1,
					silent: !0
				}), this.group = new a.Group({
					position: e.position.slice(),
					rotation: e.rotation
				})
			};
		g.prototype = {
			constructor: g,
			hasBuilder: function(t) {
				return !!d[t]
			},
			add: function(t) {
				d[t].call(this)
			},
			getGroup: function() {
				return this.group
			}
		};
		var d = {
			axisLine: function() {
				var t = this.opt,
					e = this.axisModel;
				if (e.get("axisLine.show")) {
					var n = this.axisModel.axis.getExtent();
					this.group.add(new a.Line({
						shape: {
							x1: n[0],
							y1: 0,
							x2: n[1],
							y2: 0
						},
						style: s.extend({
							lineCap: "round"
						}, e.getModel("axisLine.lineStyle").getLineStyle()),
						strokeContainThreshold: t.strokeContainThreshold,
						silent: !! t.axisLineSilent,
						z2: 1
					}))
				}
			},
			axisTick: function() {
				var t = this.axisModel;
				if (t.get("axisTick.show")) {
					for (var e = t.axis, n = t.getModel("axisTick"), i = this.opt, o = n.getModel("lineStyle"), r = n.get("length"), s = m(n, i.labelInterval), l = e.getTicksCoords(), u = [], p = 0; p < l.length; p++) if (!f(e, p, s)) {
						var h = l[p];
						u.push(new a.Line(a.subPixelOptimizeLine({
							shape: {
								x1: h,
								y1: 0,
								x2: h,
								y2: i.tickDirection * r
							},
							style: {
								lineWidth: o.get("width")
							},
							silent: !0
						})))
					}
					this.group.add(a.mergePath(u, {
						style: o.getLineStyle(),
						z2: 2,
						silent: !0
					}))
				}
			},
			axisLabel: function() {
				function t(t, e) {
					var n = t && t.getBoundingRect().clone(),
						i = e && e.getBoundingRect().clone();
					return n && i ? (n.applyTransform(t.getLocalTransform()), i.applyTransform(e.getLocalTransform()), n.intersect(i)) : void 0
				}
				var e = this.axisModel;
				if (e.get("axisLabel.show")) {
					var n = this.opt,
						r = e.axis,
						s = e.getModel("axisLabel"),
						u = s.getModel("textStyle"),
						p = s.get("margin"),
						h = r.scale.getTicks(),
						g = e.getFormattedLabels(),
						d = n.labelRotation;
					null == d && (d = s.get("rotate") || 0), d = d * c / 180;
					for (var m = o(n, d, n.labelDirection), y = e.get("data"), v = [], x = e.get("silent"), j = 0; j < h.length; j++) if (!f(r, j, n.labelInterval)) {
						var E = u;
						y && y[j] && y[j].textStyle && (E = new l(y[j].textStyle, u, e.ecModel));
						var I = E.getTextColor(),
							C = r.dataToCoord(h[j]),
							S = [C, n.labelOffset + n.labelDirection * p],
							b = r.scale.getLabel(h[j]),
							L = new a.Text({
								style: {
									text: g[j],
									textAlign: E.get("align", !0) || m.textAlign,
									textVerticalAlign: E.get("baseline", !0) || m.verticalAlign,
									textFont: E.getFont(),
									fill: "function" == typeof I ? I(b) : I
								},
								position: S,
								rotation: m.rotation,
								silent: x,
								z2: 10
							});
						L.eventData = i(e), L.eventData.targetType = "axisLabel", L.eventData.value = b, v.push(L), this.group.add(L)
					}
					if ("category" !== r.type) {
						if (e.getMin ? e.getMin() : e.get("min")) {
							var w = v[0],
								P = v[1];
							t(w, P) && (w.ignore = !0)
						}
						if (e.getMax ? e.getMax() : e.get("max")) {
							var M = v[v.length - 1],
								_ = v[v.length - 2];
							t(_, M) && (M.ignore = !0)
						}
					}
				}
			},
			axisName: function() {
				var t = this.opt,
					e = this.axisModel,
					n = this.opt.axisName;
				if (null == n && (n = e.get("name")), n) {
					var s, l = e.get("nameLocation"),
						u = t.nameDirection,
						p = e.getModel("nameTextStyle"),
						h = e.get("nameGap") || 0,
						c = this.axisModel.axis.getExtent(),
						g = c[0] > c[1] ? -1 : 1,
						d = ["start" === l ? c[0] - g * h : "end" === l ? c[1] + g * h : (c[0] + c[1]) / 2, "middle" === l ? t.labelOffset + u * h : 0];
					s = "middle" === l ? o(t, t.rotation, u) : r(t, l, c);
					var f = new a.Text({
						style: {
							text: n,
							textFont: p.getFont(),
							fill: p.getTextColor() || e.get("axisLine.lineStyle.color"),
							textAlign: s.textAlign,
							textVerticalAlign: s.verticalAlign
						},
						position: d,
						rotation: s.rotation,
						silent: e.get("silent"),
						z2: 1
					});
					f.eventData = i(e), f.eventData.targetType = "axisName", f.eventData.name = n, this.group.add(f)
				}
			}
		},
			f = g.ifIgnoreOnTick = function(t, e, n) {
				var i, o = t.scale;
				return "ordinal" === o.type && ("function" == typeof n ? (i = o.getTicks()[e], !n(i, o.getLabel(i))) : e % (n + 1))
			},
			m = g.getInterval = function(t, e) {
				var n = t.get("interval");
				return null != n && "auto" != n || (n = e), n
			};
		t.exports = g
	}, function(t, e, n) {
		function i(t) {
			return s.isObject(t) && null != t.value ? t.value : t
		}
		function o() {
			return "category" === this.get("type") && s.map(this.get("data"), i)
		}
		function r() {
			return a.getFormattedLabels(this.axis, this.get("axisLabel.formatter"))
		}
		var s = n(1),
			a = n(24);
		t.exports = {
			getFormattedLabels: r,
			getCategories: o
		}
	}, function(t, e, n) {
		"use strict";

		function i(t, e) {
			return e.type || (e.data ? "category" : "value")
		}
		var o = n(10),
			r = n(1),
			s = n(62),
			a = o.extend({
				type: "cartesian2dAxis",
				axis: null,
				init: function() {
					a.superApply(this, "init", arguments), this._resetRange()
				},
				mergeOption: function() {
					a.superApply(this, "mergeOption", arguments), this._resetRange()
				},
				restoreData: function() {
					a.superApply(this, "restoreData", arguments), this._resetRange()
				},
				setRange: function(t, e) {
					this.option.rangeStart = t, this.option.rangeEnd = e
				},
				getMin: function() {
					var t = this.option;
					return null != t.rangeStart ? t.rangeStart : t.min
				},
				getMax: function() {
					var t = this.option;
					return null != t.rangeEnd ? t.rangeEnd : t.max
				},
				getNeedCrossZero: function() {
					var t = this.option;
					return null == t.rangeStart && null == t.rangeEnd && !t.scale
				},
				_resetRange: function() {
					this.option.rangeStart = this.option.rangeEnd = null
				}
			});
		r.merge(a.prototype, n(50));
		var l = {
			gridIndex: 0
		};
		s("x", a, i, l), s("y", a, i, l), t.exports = a
	}, function(t, e, n) {
		function i(t, e, n) {
			return n.getComponent("grid", t.get("gridIndex")) === e
		}
		function o(t) {
			var e, n = t.model,
				i = n.getFormattedLabels(),
				o = 1,
				r = i.length;
			r > 40 && (o = Math.ceil(r / 40));
			for (var s = 0; r > s; s += o) if (!t.isLabelIgnored(s)) {
				var a = n.getTextRect(i[s]);
				e ? e.union(a) : e = a
			}
			return e
		}
		function r(t, e, n) {
			this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, n), this._model = t
		}
		function s(t, e) {
			var n = t.getExtent(),
				i = n[0] + n[1];
			t.toGlobalCoord = "x" === t.dim ?
			function(t) {
				return t + e
			} : function(t) {
				return i - t + e
			}, t.toLocalCoord = "x" === t.dim ?
			function(t) {
				return t - e
			} : function(t) {
				return i - t + e
			}
		}
		var a = n(11),
			l = n(24),
			u = n(1),
			p = n(106),
			h = n(104),
			c = u.each,
			g = l.ifAxisCrossZero,
			d = l.niceScaleExtent;
		n(107);
		var f = r.prototype;
		f.type = "grid", f.getRect = function() {
			return this._rect
		}, f.update = function(t, e) {
			function n(t) {
				var e = i[t];
				for (var n in e) {
					var o = e[n];
					if (o && ("category" === o.type || !g(o))) return !0
				}
				return !1
			}
			var i = this._axesMap;
			this._updateScale(t, this._model), c(i.x, function(t) {
				d(t, t.model)
			}), c(i.y, function(t) {
				d(t, t.model)
			}), c(i.x, function(t) {
				n("y") && (t.onZero = !1)
			}), c(i.y, function(t) {
				n("x") && (t.onZero = !1)
			}), this.resize(this._model, e)
		}, f.resize = function(t, e) {
			function n() {
				c(r, function(t) {
					var e = t.isHorizontal(),
						n = e ? [0, i.width] : [0, i.height],
						o = t.inverse ? 1 : 0;
					t.setExtent(n[o], n[1 - o]), s(t, e ? i.x : i.y)
				})
			}
			var i = a.getLayoutRect(t.getBoxLayoutParams(), {
				width: e.getWidth(),
				height: e.getHeight()
			});
			this._rect = i;
			var r = this._axesList;
			n(), t.get("containLabel") && (c(r, function(t) {
				if (!t.model.get("axisLabel.inside")) {
					var e = o(t);
					if (e) {
						var n = t.isHorizontal() ? "height" : "width",
							r = t.model.get("axisLabel.margin");
						i[n] -= e[n] + r, "top" === t.position ? i.y += e.height + r : "left" === t.position && (i.x += e.width + r)
					}
				}
			}), n())
		}, f.getAxis = function(t, e) {
			var n = this._axesMap[t];
			if (null != n) {
				if (null == e) for (var i in n) return n[i];
				return n[e]
			}
		}, f.getCartesian = function(t, e) {
			var n = "x" + t + "y" + e;
			return this._coordsMap[n]
		}, f._initCartesian = function(t, e, n) {
			function o(n) {
				return function(o, u) {
					if (i(o, t, e)) {
						var p = o.get("position");
						"x" === n ? ("top" !== p && "bottom" !== p && (p = "bottom"), r[p] && (p = "top" === p ? "bottom" : "top")) : ("left" !== p && "right" !== p && (p = "left"), r[p] && (p = "left" === p ? "right" : "left")), r[p] = !0;
						var c = new h(n, l.createScaleByModel(o), [0, 0], o.get("type"), p),
							g = "category" === c.type;
						c.onBand = g && o.get("boundaryGap"), c.inverse = o.get("inverse"), c.onZero = o.get("axisLine.onZero"), o.axis = c, c.model = o, c.index = u, this._axesList.push(c), s[n][u] = c, a[n]++
					}
				}
			}
			var r = {
				left: !1,
				right: !1,
				top: !1,
				bottom: !1
			},
				s = {
					x: {},
					y: {}
				},
				a = {
					x: 0,
					y: 0
				};
			return e.eachComponent("xAxis", o("x"), this), e.eachComponent("yAxis", o("y"), this), a.x && a.y ? (this._axesMap = s, void c(s.x, function(t, e) {
				c(s.y, function(n, i) {
					var o = "x" + e + "y" + i,
						r = new p(o);
					r.grid = this, this._coordsMap[o] = r, this._coordsList.push(r), r.addAxis(t), r.addAxis(n)
				}, this)
			}, this)) : (this._axesMap = {}, void(this._axesList = []))
		}, f._updateScale = function(t, e) {
			function n(t, e, n) {
				c(n.coordDimToDataDim(e.dim), function(n) {
					e.scale.unionExtent(t.getDataExtent(n, "ordinal" !== e.scale.type))
				})
			}
			u.each(this._axesList, function(t) {
				t.scale.setExtent(1 / 0, -(1 / 0))
			}), t.eachSeries(function(o) {
				if ("cartesian2d" === o.get("coordinateSystem")) {
					var r = o.get("xAxisIndex"),
						s = o.get("yAxisIndex"),
						a = t.getComponent("xAxis", r),
						l = t.getComponent("yAxis", s);
					if (!i(a, e, t) || !i(l, e, t)) return;
					var u = this.getCartesian(r, s),
						p = o.getData(),
						h = u.getAxis("x"),
						c = u.getAxis("y");
					"list" === p.type && (n(p, h, o), n(p, c, o))
				}
			}, this)
		}, r.create = function(t, e) {
			var n = [];
			return t.eachComponent("grid", function(i, o) {
				var s = new r(i, t, e);
				s.name = "grid_" + o, s.resize(i, e), i.coordinateSystem = s, n.push(s)
			}), t.eachSeries(function(e) {
				if ("cartesian2d" === e.get("coordinateSystem")) {
					var i = e.get("xAxisIndex"),
						o = t.getComponent("xAxis", i),
						r = n[o.get("gridIndex")];
					e.coordinateSystem = r.getCartesian(i, e.get("yAxisIndex"))
				}
			}), n
		}, r.dimensions = p.prototype.dimensions, n(23).register("cartesian2d", r), t.exports = r
	}, function(t, e) {
		t.exports = function(t, e, n) {
			e.eachSeriesByType(t, function(t) {
				var e = t.getData(),
					n = t.coordinateSystem;
				if (n) {
					var i = n.dimensions;
					e.each(i, function(t, i, o) {
						var r;
						r = isNaN(t) || isNaN(i) ? [NaN, NaN] : n.dataToPoint([t, i]), e.setItemLayout(o, r)
					}, !0)
				}
			})
		}
	}, function(t, e, n) {
		var i = n(27),
			o = n(42),
			r = n(20),
			s = function() {
				this.group = new i, this.uid = o.getUID("viewComponent")
			};
		s.prototype = {
			constructor: s,
			init: function(t, e) {},
			render: function(t, e, n, i) {},
			dispose: function() {}
		};
		var a = s.prototype;
		a.updateView = a.updateLayout = a.updateVisual = function(t, e, n, i) {}, r.enableClassExtend(s), r.enableClassManagement(s, {
			registerWhenExtend: !0
		}), t.exports = s
	}, function(t, e, n) {
		"use strict";
		var i = n(58),
			o = n(21),
			r = n(77),
			s = n(154),
			a = n(1),
			l = function(t) {
				r.call(this, t), o.call(this, t), s.call(this, t), this.id = t.id || i()
			};
		l.prototype = {
			type: "element",
			name: "",
			__zr: null,
			ignore: !1,
			clipPath: null,
			drift: function(t, e) {
				switch (this.draggable) {
				case "horizontal":
					e = 0;
					break;
				case "vertical":
					t = 0
				}
				var n = this.transform;
				n || (n = this.transform = [1, 0, 0, 1, 0, 0]), n[4] += t, n[5] += e, this.decomposeTransform(), this.dirty()
			},
			beforeUpdate: function() {},
			afterUpdate: function() {},
			update: function() {
				this.updateTransform()
			},
			traverse: function(t, e) {},
			attrKV: function(t, e) {
				if ("position" === t || "scale" === t || "origin" === t) {
					if (e) {
						var n = this[t];
						n || (n = this[t] = []), n[0] = e[0], n[1] = e[1]
					}
				} else this[t] = e
			},
			hide: function() {
				this.ignore = !0, this.__zr && this.__zr.refresh()
			},
			show: function() {
				this.ignore = !1, this.__zr && this.__zr.refresh()
			},
			attr: function(t, e) {
				if ("string" == typeof t) this.attrKV(t, e);
				else if (a.isObject(t)) for (var n in t) t.hasOwnProperty(n) && this.attrKV(n, t[n]);
				return this.dirty(), this
			},
			setClipPath: function(t) {
				var e = this.__zr;
				e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty()
			},
			removeClipPath: function() {
				var t = this.clipPath;
				t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty())
			},
			addSelfToZr: function(t) {
				this.__zr = t;
				var e = this.animators;
				if (e) for (var n = 0; n < e.length; n++) t.animation.addAnimator(e[n]);
				this.clipPath && this.clipPath.addSelfToZr(t)
			},
			removeSelfFromZr: function(t) {
				this.__zr = null;
				var e = this.animators;
				if (e) for (var n = 0; n < e.length; n++) t.animation.removeAnimator(e[n]);
				this.clipPath && this.clipPath.removeSelfFromZr(t)
			}
		}, a.mixin(l, s), a.mixin(l, r), a.mixin(l, o), t.exports = l
	}, function(t, e, n) {
		function i(t, e) {
			return t[e]
		}
		function o(t, e, n) {
			t[e] = n
		}
		function r(t, e, n) {
			return (e - t) * n + t
		}
		function s(t, e, n) {
			return n > .5 ? e : t
		}
		function a(t, e, n, i, o) {
			var s = t.length;
			if (1 == o) for (var a = 0; s > a; a++) i[a] = r(t[a], e[a], n);
			else for (var l = t[0].length, a = 0; s > a; a++) for (var u = 0; l > u; u++) i[a][u] = r(t[a][u], e[a][u], n)
		}
		function l(t, e, n) {
			var i = t.length,
				o = e.length;
			if (i !== o) {
				var r = i > o;
				if (r) t.length = o;
				else for (var s = i; o > s; s++) t.push(1 === n ? e[s] : x.call(e[s]))
			}
			for (var a = t[0] && t[0].length, s = 0; s < t.length; s++) if (1 === n) isNaN(t[s]) && (t[s] = e[s]);
			else for (var l = 0; a > l; l++) isNaN(t[s][l]) && (t[s][l] = e[s][l])
		}
		function u(t, e, n) {
			if (t === e) return !0;
			var i = t.length;
			if (i !== e.length) return !1;
			if (1 === n) {
				for (var o = 0; i > o; o++) if (t[o] !== e[o]) return !1
			} else for (var r = t[0].length, o = 0; i > o; o++) for (var s = 0; r > s; s++) if (t[o][s] !== e[o][s]) return !1;
			return !0
		}
		function p(t, e, n, i, o, r, s, a, l) {
			var u = t.length;
			if (1 == l) for (var p = 0; u > p; p++) a[p] = h(t[p], e[p], n[p], i[p], o, r, s);
			else for (var c = t[0].length, p = 0; u > p; p++) for (var g = 0; c > g; g++) a[p][g] = h(t[p][g], e[p][g], n[p][g], i[p][g], o, r, s)
		}
		function h(t, e, n, i, o, r, s) {
			var a = .5 * (n - t),
				l = .5 * (i - e);
			return (2 * (e - n) + a + l) * s + (-3 * (e - n) - 2 * a - l) * r + a * o + e
		}
		function c(t) {
			if (v(t)) {
				var e = t.length;
				if (v(t[0])) {
					for (var n = [], i = 0; e > i; i++) n.push(x.call(t[i]));
					return n
				}
				return x.call(t)
			}
			return t
		}
		function g(t) {
			return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")"
		}
		function d(t, e, n, i, o) {
			var c = t._getter,
				d = t._setter,
				y = "spline" === e,
				x = i.length;
			if (x) {
				var j, E = i[0].value,
					I = v(E),
					C = !1,
					S = !1,
					b = I && v(E[0]) ? 2 : 1;
				i.sort(function(t, e) {
					return t.time - e.time
				}), j = i[x - 1].time;
				for (var L = [], w = [], P = i[0].value, M = !0, _ = 0; x > _; _++) {
					L.push(i[_].time / j);
					var N = i[_].value;
					if (I && u(N, P, b) || !I && N === P || (M = !1), P = N, "string" == typeof N) {
						var A = m.parse(N);
						A ? (N = A, C = !0) : S = !0
					}
					w.push(N)
				}
				if (!M) {
					for (var T = w[x - 1], _ = 0; x - 1 > _; _++) I ? l(w[_], T, b) : !isNaN(w[_]) || isNaN(T) || S || C || (w[_] = T);
					I && l(c(t._target, o), T, b);
					var R, O, D, B, G, F, k = 0,
						q = 0;
					if (C) var V = [0, 0, 0, 0];
					var z = function(t, e) {
							var n;
							if (q > e) {
								for (R = Math.min(k + 1, x - 1), n = R; n >= 0 && !(L[n] <= e); n--);
								n = Math.min(n, x - 2)
							} else {
								for (n = k; x > n && !(L[n] > e); n++);
								n = Math.min(n - 1, x - 2)
							}
							k = n, q = e;
							var i = L[n + 1] - L[n];
							if (0 !== i) if (O = (e - L[n]) / i, y) if (B = w[n], D = w[0 === n ? n : n - 1], G = w[n > x - 2 ? x - 1 : n + 1], F = w[n > x - 3 ? x - 1 : n + 2], I) p(D, B, G, F, O, O * O, O * O * O, c(t, o), b);
							else {
								var l;
								if (C) l = p(D, B, G, F, O, O * O, O * O * O, V, 1), l = g(V);
								else {
									if (S) return s(B, G, O);
									l = h(D, B, G, F, O, O * O, O * O * O)
								}
								d(t, o, l)
							} else if (I) a(w[n], w[n + 1], O, c(t, o), b);
							else {
								var l;
								if (C) a(w[n], w[n + 1], O, V, 1), l = g(V);
								else {
									if (S) return s(w[n], w[n + 1], O);
									l = r(w[n], w[n + 1], O)
								}
								d(t, o, l)
							}
						},
						H = new f({
							target: t._target,
							life: j,
							loop: t._loop,
							delay: t._delay,
							onframe: z,
							ondestroy: n
						});
					return e && "spline" !== e && (H.easing = e), H
				}
			}
		}
		var f = n(131),
			m = n(22),
			y = n(1),
			v = y.isArrayLike,
			x = Array.prototype.slice,
			j = function(t, e, n, r) {
				this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = n || i, this._setter = r || o, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []
			};
		j.prototype = {
			when: function(t, e) {
				var n = this._tracks;
				for (var i in e) {
					if (!n[i]) {
						n[i] = [];
						var o = this._getter(this._target, i);
						if (null == o) continue;
						0 !== t && n[i].push({
							time: 0,
							value: c(o)
						})
					}
					n[i].push({
						time: t,
						value: e[i]
					})
				}
				return this
			},
			during: function(t) {
				return this._onframeList.push(t), this
			},
			_doneCallback: function() {
				this._tracks = {}, this._clipList.length = 0;
				for (var t = this._doneList, e = t.length, n = 0; e > n; n++) t[n].call(this)
			},
			start: function(t) {
				var e, n = this,
					i = 0,
					o = function() {
						i--, i || n._doneCallback()
					};
				for (var r in this._tracks) {
					var s = d(this, t, o, this._tracks[r], r);
					s && (this._clipList.push(s), i++, this.animation && this.animation.addClip(s), e = s)
				}
				if (e) {
					var a = e.onframe;
					e.onframe = function(t, e) {
						a(t, e);
						for (var i = 0; i < n._onframeList.length; i++) n._onframeList[i](t, e)
					}
				}
				return i || this._doneCallback(), this
			},
			stop: function(t) {
				for (var e = this._clipList, n = this.animation, i = 0; i < e.length; i++) {
					var o = e[i];
					t && o.onframe(this._target, 1), n && n.removeClip(o)
				}
				e.length = 0
			},
			delay: function(t) {
				return this._delay = t, this
			},
			done: function(t) {
				return t && this._doneList.push(t), this
			},
			getClips: function() {
				return this._clipList
			}
		}, t.exports = j
	}, function(t, e) {
		var n = 2 * Math.PI;
		t.exports = {
			normalizeRadian: function(t) {
				return t %= n, 0 > t && (t += n), t
			}
		}
	}, function(t, e) {
		var n = 2311;
		t.exports = function() {
			return "zr_" + n++
		}
	}, function(t, e, n) {
		var i = n(144),
			o = n(143);
		t.exports = {
			buildPath: function(t, e, n) {
				var r = e.points,
					s = e.smooth;
				if (r && r.length >= 2) {
					if (s && "spline" !== s) {
						var a = o(r, s, n, e.smoothConstraint);
						t.moveTo(r[0][0], r[0][1]);
						for (var l = r.length, u = 0;
						(n ? l : l - 1) > u; u++) {
							var p = a[2 * u],
								h = a[2 * u + 1],
								c = r[(u + 1) % l];
							t.bezierCurveTo(p[0], p[1], h[0], h[1], c[0], c[1])
						}
					} else {
						"spline" === s && (r = i(r, n)), t.moveTo(r[0][0], r[0][1]);
						for (var u = 1, g = r.length; g > u; u++) t.lineTo(r[u][0], r[u][1])
					}
					n && t.closePath()
				}
			}
		}
	}, function(t, e) {
		t.exports = {
			buildPath: function(t, e) {
				var n, i, o, r, s = e.x,
					a = e.y,
					l = e.width,
					u = e.height,
					p = e.r;
				0 > l && (s += l, l = -l), 0 > u && (a += u, u = -u), "number" == typeof p ? n = i = o = r = p : p instanceof Array ? 1 === p.length ? n = i = o = r = p[0] : 2 === p.length ? (n = o = p[0], i = r = p[1]) : 3 === p.length ? (n = p[0], i = r = p[1], o = p[2]) : (n = p[0], i = p[1], o = p[2], r = p[3]) : n = i = o = r = 0;
				var h;
				n + i > l && (h = n + i, n *= l / h, i *= l / h), o + r > l && (h = o + r, o *= l / h, r *= l / h), i + o > u && (h = i + o, i *= u / h, o *= u / h), n + r > u && (h = n + r, n *= u / h, r *= u / h), t.moveTo(s + n, a), t.lineTo(s + l - i, a), 0 !== i && t.quadraticCurveTo(s + l, a, s + l, a + i), t.lineTo(s + l, a + u - o), 0 !== o && t.quadraticCurveTo(s + l, a + u, s + l - o, a + u), t.lineTo(s + r, a + u), 0 !== r && t.quadraticCurveTo(s, a + u, s, a + u - r), t.lineTo(s, a + n), 0 !== n && t.quadraticCurveTo(s, a, s + n, a)
			}
		}
	}, function(t, e, n) {
		var i = n(1);
		t.exports = {
			updateSelectedMap: function(t) {
				this._selectTargetMap = i.reduce(t || [], function(t, e) {
					return t[e.name] = e, t
				}, {})
			},
			select: function(t) {
				var e = this._selectTargetMap,
					n = e[t],
					o = this.get("selectedMode");
				"single" === o && i.each(e, function(t) {
					t.selected = !1
				}), n && (n.selected = !0)
			},
			unSelect: function(t) {
				var e = this._selectTargetMap[t];
				e && (e.selected = !1)
			},
			toggleSelected: function(t) {
				var e = this._selectTargetMap[t];
				return null != e ? (this[e.selected ? "unSelect" : "select"](t), e.selected) : void 0
			},
			isSelected: function(t) {
				var e = this._selectTargetMap[t];
				return e && e.selected
			}
		}
	}, function(t, e, n) {
		var i = n(72),
			o = n(1),
			r = n(10),
			s = n(11),
			a = ["value", "category", "time", "log"];
		t.exports = function(t, e, n, l) {
			o.each(a, function(r) {
				e.extend({
					type: t + "Axis." + r,
					mergeDefaultAndTheme: function(e, i) {
						var a = this.layoutMode,
							l = a ? s.getLayoutParams(e) : {},
							u = i.getTheme();
						o.merge(e, u.get(r + "Axis")), o.merge(e, this.getDefaultOption()), e.type = n(t, e), a && s.mergeLayoutParam(e, l, a)
					},
					defaultOption: o.mergeAll([{},
					i[r + "Axis"], l], !0)
				})
			}), r.registerSubTypeDefaulter(t + "Axis", o.curry(n, t))
		}
	}, function(t, e) {
		t.exports = function(t, e) {
			var n = e.findComponents({
				mainType: "legend"
			});
			n && n.length && e.eachSeriesByType(t, function(t) {
				var e = t.getData();
				e.filterSelf(function(t) {
					for (var i = e.getName(t), o = 0; o < n.length; o++) if (!n[o].isSelected(i)) return !1;
					return !0
				}, this)
			}, this)
		}
	}, function(t, e) {
		t.exports = function(t, e) {
			var n = e.get("color"),
				i = 0;
			e.eachRawSeriesByType(t, function(t) {
				var o = t.get("color", !0),
					r = t.getRawData();
				if (!e.isSeriesFiltered(t)) {
					var s = t.getData();
					s.each(function(t) {
						var e = s.getItemModel(t),
							a = s.getRawIndex(t),
							l = s.getItemVisual(t, "color", !0);
						if (l) r.setItemVisual(a, "color", l);
						else {
							var u = o ? o[a % o.length] : n[(a + i) % n.length],
								p = e.get("itemStyle.normal.color") || u;
							r.setItemVisual(a, "color", p), s.setItemVisual(t, "color", p)
						}
					})
				}
				i += r.count()
			})
		}
	}, function(t, e, n) {
		var i = n(5),
			o = n(16),
			r = {},
			s = Math.min,
			a = Math.max,
			l = Math.sin,
			u = Math.cos,
			p = i.create(),
			h = i.create(),
			c = i.create(),
			g = 2 * Math.PI;
		r.fromPoints = function(t, e, n) {
			if (0 !== t.length) {
				var i, o = t[0],
					r = o[0],
					l = o[0],
					u = o[1],
					p = o[1];
				for (i = 1; i < t.length; i++) o = t[i], r = s(r, o[0]), l = a(l, o[0]), u = s(u, o[1]), p = a(p, o[1]);
				e[0] = r, e[1] = u, n[0] = l, n[1] = p
			}
		}, r.fromLine = function(t, e, n, i, o, r) {
			o[0] = s(t, n), o[1] = s(e, i), r[0] = a(t, n), r[1] = a(e, i)
		};
		var d = [],
			f = [];
		r.fromCubic = function(t, e, n, i, r, l, u, p, h, c) {
			var g, m = o.cubicExtrema,
				y = o.cubicAt,
				v = m(t, n, r, u, d);
			for (h[0] = 1 / 0, h[1] = 1 / 0, c[0] = -(1 / 0), c[1] = -(1 / 0), g = 0; v > g; g++) {
				var x = y(t, n, r, u, d[g]);
				h[0] = s(x, h[0]), c[0] = a(x, c[0])
			}
			for (v = m(e, i, l, p, f), g = 0; v > g; g++) {
				var j = y(e, i, l, p, f[g]);
				h[1] = s(j, h[1]), c[1] = a(j, c[1])
			}
			h[0] = s(t, h[0]), c[0] = a(t, c[0]), h[0] = s(u, h[0]), c[0] = a(u, c[0]), h[1] = s(e, h[1]), c[1] = a(e, c[1]), h[1] = s(p, h[1]), c[1] = a(p, c[1])
		}, r.fromQuadratic = function(t, e, n, i, r, l, u, p) {
			var h = o.quadraticExtremum,
				c = o.quadraticAt,
				g = a(s(h(t, n, r), 1), 0),
				d = a(s(h(e, i, l), 1), 0),
				f = c(t, n, r, g),
				m = c(e, i, l, d);
			u[0] = s(t, r, f), u[1] = s(e, l, m), p[0] = a(t, r, f), p[1] = a(e, l, m)
		}, r.fromArc = function(t, e, n, o, r, s, a, d, f) {
			var m = i.min,
				y = i.max,
				v = Math.abs(r - s);
			if (1e-4 > v % g && v > 1e-4) return d[0] = t - n, d[1] = e - o, f[0] = t + n, void(f[1] = e + o);
			if (p[0] = u(r) * n + t, p[1] = l(r) * o + e, h[0] = u(s) * n + t, h[1] = l(s) * o + e, m(d, p, h), y(f, p, h), r %= g, 0 > r && (r += g), s %= g, 0 > s && (s += g), r > s && !a ? s += g : s > r && a && (r += g), a) {
				var x = s;
				s = r, r = x
			}
			for (var j = 0; s > j; j += Math.PI / 2) j > r && (c[0] = u(j) * n + t, c[1] = l(j) * o + e, m(d, c, d), y(f, c, f))
		}, t.exports = r
	}, function(t, e, n) {
		var i = n(37),
			o = n(1),
			r = n(18),
			s = function(t) {
				i.call(this, t)
			};
		s.prototype = {
			constructor: s,
			type: "text",
			brush: function(t) {
				var e = this.style,
					n = e.x || 0,
					i = e.y || 0,
					o = e.text,
					s = e.fill,
					a = e.stroke;
				if (null != o && (o += ""), o) {
					if (t.save(), this.style.bind(t), this.setTransform(t), s && (t.fillStyle = s), a && (t.strokeStyle = a), t.font = e.textFont || e.font, t.textAlign = e.textAlign, e.textVerticalAlign) {
						var l = r.getBoundingRect(o, t.font, e.textAlign, "top");
						switch (t.textBaseline = "middle", e.textVerticalAlign) {
						case "middle":
							i -= l.height / 2 - l.lineHeight / 2;
							break;
						case "bottom":
							i -= l.height - l.lineHeight / 2;
							break;
						default:
							i += l.lineHeight / 2
						}
					} else t.textBaseline = e.textBaseline;
					for (var u = r.measureText("国", t.font).width, p = o.split("\n"), h = 0; h < p.length; h++) s && t.fillText(p[h], n, i), a && t.strokeText(p[h], n, i), i += u;
					t.restore()
				}
			},
			getBoundingRect: function() {
				if (!this._rect) {
					var t = this.style,
						e = t.textVerticalAlign,
						n = r.getBoundingRect(t.text + "", t.textFont || t.font, t.textAlign, e ? "top" : t.textBaseline);
					switch (e) {
					case "middle":
						n.y -= n.height / 2;
						break;
					case "bottom":
						n.y -= n.height
					}
					n.x += t.x || 0, n.y += t.y || 0, this._rect = n
				}
				return this._rect
			}
		}, o.inherits(s, i), t.exports = s
	}, function(t, e, n) {
		function i(t, e) {
			return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
		}
		function o(t, e) {
			t.transform(e[0], e[1], e[2], e[3], e[4], e[5])
		}
		var r = n(18),
			s = n(8),
			a = new s,
			l = function() {};
		l.prototype = {
			constructor: l,
			drawRectText: function(t, e, n) {
				var s = this.style,
					l = s.text;
				if (null != l && (l += ""), l) {
					var u, p, h = s.textPosition,
						c = s.textDistance,
						g = s.textAlign,
						d = s.textFont || s.font,
						f = s.textBaseline,
						m = s.textVerticalAlign;
					n = n || r.getBoundingRect(l, d, g, f);
					var y = this.transform,
						v = this.invTransform;
					if (y && (a.copy(e), a.applyTransform(y), e = a, o(t, v)), h instanceof Array) {
						if (u = e.x + i(h[0], e.width), p = e.y + i(h[1], e.height), g = g || "left", f = f || "top", m) {
							switch (m) {
							case "middle":
								p -= n.height / 2 - n.lineHeight / 2;
								break;
							case "bottom":
								p -= n.height - n.lineHeight / 2;
								break;
							default:
								p += n.lineHeight / 2
							}
							f = "middle"
						}
					} else {
						var x = r.adjustTextPositionOnRect(h, e, n, c);
						u = x.x, p = x.y, g = g || x.textAlign, f = f || x.textBaseline
					}
					t.textAlign = g, t.textBaseline = f;
					var j = s.textFill,
						E = s.textStroke;
					j && (t.fillStyle = j), E && (t.strokeStyle = E), t.font = d, t.shadowColor = s.textShadowColor, t.shadowBlur = s.textShadowBlur, t.shadowOffsetX = s.textShadowOffsetX, t.shadowOffsetY = s.textShadowOffsetY;
					for (var I = l.split("\n"), C = 0; C < I.length; C++) j && t.fillText(I[C], u, p), E && t.strokeText(I[C], u, p), p += n.lineHeight;
					y && o(t, y)
				}
			}
		}, t.exports = l
	}, function(t, e, n) {
		function i(t) {
			delete h[t]
		}
		var o = n(58),
			r = n(14),
			s = n(126),
			a = n(129),
			l = n(130),
			u = !r.canvasSupported,
			p = {
				canvas: n(128)
			},
			h = {},
			c = {};
		c.version = "3.1.0", c.init = function(t, e) {
			var n = new g(o(), t, e);
			return h[n.id] = n, n
		}, c.dispose = function(t) {
			if (t) t.dispose();
			else {
				for (var e in h) h[e].dispose();
				h = {}
			}
			return c
		}, c.getInstance = function(t) {
			return h[t]
		}, c.registerPainter = function(t, e) {
			p[t] = e
		};
		var g = function(t, e, n) {
				n = n || {}, this.dom = e, this.id = t;
				var i = this,
					o = new a,
					h = n.renderer;
				if (u) {
					if (!p.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");
					h = "vml"
				} else h && p[h] || (h = "canvas");
				var c = new p[h](e, o, n);
				this.storage = o, this.painter = c, r.node || (this.handler = new s(c.getViewportRoot(), o, c)), this.animation = new l({
					stage: {
						update: function() {
							i._needsRefresh && i.refreshImmediately()
						}
					}
				}), this.animation.start(), this._needsRefresh;
				var g = o.delFromMap,
					d = o.addToMap;
				o.delFromMap = function(t) {
					var e = o.get(t);
					g.call(o, t), e && e.removeSelfFromZr(i)
				}, o.addToMap = function(t) {
					d.call(o, t), t.addSelfToZr(i)
				}
			};
		g.prototype = {
			constructor: g,
			getId: function() {
				return this.id
			},
			add: function(t) {
				this.storage.addRoot(t), this._needsRefresh = !0
			},
			remove: function(t) {
				this.storage.delRoot(t), this._needsRefresh = !0
			},
			configLayer: function(t, e) {
				this.painter.configLayer(t, e), this._needsRefresh = !0
			},
			refreshImmediately: function() {
				this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1;
			},
			refresh: function() {
				this._needsRefresh = !0
			},
			resize: function() {
				this.painter.resize(), this.handler && this.handler.resize()
			},
			clearAnimation: function() {
				this.animation.clear()
			},
			getWidth: function() {
				return this.painter.getWidth()
			},
			getHeight: function() {
				return this.painter.getHeight()
			},
			pathToImage: function(t, e, n) {
				var i = o();
				return this.painter.pathToImage(i, t, e, n)
			},
			setDefaultCursorStyle: function(t) {
				this.handler.setDefaultCursorStyle(t)
			},
			on: function(t, e, n) {
				this.handler && this.handler.on(t, e, n)
			},
			off: function(t, e) {
				this.handler && this.handler.off(t, e)
			},
			trigger: function(t, e) {
				this.handler && this.handler.trigger(t, e)
			},
			clear: function() {
				this.storage.delRoot(), this.painter.clear()
			},
			dispose: function() {
				this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler && this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, i(this.id)
			}
		}, t.exports = c
	}, function(t, e, n) {
		var i = n(2),
			o = n(1);
		t.exports = function(t, e) {
			o.each(e, function(e) {
				e.update = "updateView", i.registerAction(e, function(n, i) {
					var o = {};
					return i.eachComponent({
						mainType: "series",
						subType: t,
						query: n
					}, function(t) {
						t[e.method] && t[e.method](n.name);
						var i = t.getData();
						i.each(function(e) {
							var n = i.getName(e);
							o[n] = t.isSelected(n) || !1
						})
					}), {
						name: n.name,
						selected: o
					}
				})
			})
		}
	}, function(t, e, n) {
		function i(t) {
			if (!t.target || !t.target.draggable) {
				var e = t.offsetX,
					n = t.offsetY,
					i = this.rectProvider && this.rectProvider();
				i && i.contain(e, n) && (this._x = e, this._y = n, this._dragging = !0)
			}
		}
		function o(t) {
			if (this._dragging && (c.stop(t.event), "pinch" !== t.gestureEvent)) {
				if (g.isTaken("globalPan", this._zr)) return;
				var e = t.offsetX,
					n = t.offsetY,
					i = e - this._x,
					o = n - this._y;
				this._x = e, this._y = n;
				var r = this.target;
				if (r) {
					var s = r.position;
					s[0] += i, s[1] += o, r.dirty()
				}
				c.stop(t.event), this.trigger("pan", i, o)
			}
		}
		function r(t) {
			this._dragging = !1
		}
		function s(t) {
			var e = t.wheelDelta > 0 ? 1.1 : 1 / 1.1;
			l.call(this, t, e, t.offsetX, t.offsetY)
		}
		function a(t) {
			if (!g.isTaken("globalPan", this._zr)) {
				var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
				l.call(this, t, e, t.pinchX, t.pinchY)
			}
		}
		function l(t, e, n, i) {
			var o = this.rectProvider && this.rectProvider();
			if (o && o.contain(n, i)) {
				c.stop(t.event);
				var r = this.target,
					s = this.zoomLimit;
				if (r) {
					var a = r.position,
						l = r.scale,
						u = this.zoom = this.zoom || 1;
					if (u *= e, s) {
						var p = s.min || 0,
							h = s.max || 1 / 0;
						u = Math.max(Math.min(h, u), p)
					}
					var g = u / this.zoom;
					this.zoom = u, a[0] -= (n - a[0]) * (g - 1), a[1] -= (i - a[1]) * (g - 1), l[0] *= g, l[1] *= g, r.dirty()
				}
				this.trigger("zoom", e, n, i)
			}
		}
		function u(t, e, n) {
			this.target = e, this.rectProvider = n, this.zoomLimit, this.zoom, this._zr = t;
			var l = h.bind,
				u = l(i, this),
				c = l(o, this),
				g = l(r, this),
				d = l(s, this),
				f = l(a, this);
			p.call(this), this.enable = function(e) {
				this.disable(), null == e && (e = !0), e !== !0 && "move" !== e && "pan" !== e || (t.on("mousedown", u), t.on("mousemove", c), t.on("mouseup", g)), e !== !0 && "scale" !== e && "zoom" !== e || (t.on("mousewheel", d), t.on("pinch", f))
			}, this.disable = function() {
				t.off("mousedown", u), t.off("mousemove", c), t.off("mouseup", g), t.off("mousewheel", d), t.off("pinch", f)
			}, this.dispose = this.disable, this.isDragging = function() {
				return this._dragging
			}, this.isPinching = function() {
				return this._pinching
			}
		}
		var p = n(21),
			h = n(1),
			c = n(34),
			g = n(101);
		h.mixin(u, p), t.exports = u
	}, function(t, e) {
		t.exports = function(t, e, n, i, o) {
			function r(t, e, n) {
				var i = e.length ? e.slice() : [e, e];
				return e[0] > e[1] && i.reverse(), 0 > t && i[0] + t < n[0] && (t = n[0] - i[0]), t > 0 && i[1] + t > n[1] && (t = n[1] - i[1]), t
			}
			return t ? ("rigid" === i ? (t = r(t, e, n), e[0] += t, e[1] += t) : (t = r(t, e[o], n), e[o] += t, "push" === i && e[0] > e[1] && (e[1 - o] = e[o])), e) : e
		}
	}, function(t, e, n) {
		var i = n(1),
			o = {
				show: !0,
				zlevel: 0,
				z: 0,
				inverse: !1,
				name: "",
				nameLocation: "end",
				nameTextStyle: {},
				nameGap: 15,
				silent: !0,
				axisLine: {
					show: !0,
					onZero: !0,
					lineStyle: {
						color: "#333",
						width: 1,
						type: "solid"
					}
				},
				axisTick: {
					show: !0,
					inside: !1,
					length: 5,
					lineStyle: {
						color: "#333",
						width: 1
					}
				},
				axisLabel: {
					show: !0,
					inside: !1,
					rotate: 0,
					margin: 8,
					textStyle: {
						color: "#333",
						fontSize: 12
					}
				},
				splitLine: {
					show: !0,
					lineStyle: {
						color: ["#ccc"],
						width: 1,
						type: "solid"
					}
				},
				splitArea: {
					show: !1,
					areaStyle: {
						color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
					}
				}
			},
			r = i.merge({
				boundaryGap: !0,
				axisTick: {
					interval: "auto"
				},
				axisLabel: {
					interval: "auto"
				}
			}, o),
			s = i.defaults({
				boundaryGap: [0, 0],
				splitNumber: 5
			}, o),
			a = i.defaults({
				scale: !0,
				min: "dataMin",
				max: "dataMax"
			}, s),
			l = i.defaults({}, s);
		l.scale = !0, t.exports = {
			categoryAxis: r,
			valueAxis: s,
			timeAxis: a,
			logAxis: l
		}
	}, , function(t, e, n) {
		var i = n(17);
		t.exports = function(t, e, n) {
			function o(t) {
				var o = [e, "normal", "color"],
					r = n.get("color"),
					s = t.getData(),
					a = t.get(o) || r[t.seriesIndex % r.length];
				s.setVisual("color", a), n.isSeriesFiltered(t) || ("function" != typeof a || a instanceof i || s.each(function(e) {
					s.setItemVisual(e, "color", a(t.getDataParams(e)))
				}), s.each(function(t) {
					var e = s.getItemModel(t),
						n = e.get(o, !0);
					null != n && s.setItemVisual(t, "color", n)
				}))
			}
			t ? n.eachSeriesByType(t, o) : n.eachSeries(o)
		}
	}, function(t, e) {
		t.exports = function(t, e, n, i, o, r) {
			if (r > e && r > i || e > r && i > r) return 0;
			if (i === e) return 0;
			var s = e > i ? 1 : -1,
				a = (r - e) / (i - e),
				l = a * (n - t) + t;
			return l > o ? s : 0
		}
	}, function(t, e, n) {
		"use strict";
		var i = n(1),
			o = n(17),
			r = function(t, e, n, i, r) {
				this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == n ? 1 : n, this.y2 = null == i ? 0 : i, o.call(this, r)
			};
		r.prototype = {
			constructor: r,
			type: "linear"
		}, i.inherits(r, o), t.exports = r
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			return t > a || -a > t
		}
		var o = n(19),
			r = n(5),
			s = o.identity,
			a = 5e-5,
			l = function(t) {
				t = t || {}, t.position || (this.position = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null
			},
			u = l.prototype;
		u.transform = null, u.needLocalTransform = function() {
			return i(this.rotation) || i(this.position[0]) || i(this.position[1]) || i(this.scale[0] - 1) || i(this.scale[1] - 1)
		}, u.updateTransform = function() {
			var t = this.parent,
				e = t && t.transform,
				n = this.needLocalTransform(),
				i = this.transform;
			return n || e ? (i = i || o.create(), n ? this.getLocalTransform(i) : s(i), e && (n ? o.mul(i, t.transform, i) : o.copy(i, t.transform)), this.transform = i, this.invTransform = this.invTransform || o.create(), void o.invert(this.invTransform, i)) : void(i && s(i))
		}, u.getLocalTransform = function(t) {
			t = t || [], s(t);
			var e = this.origin,
				n = this.scale,
				i = this.rotation,
				r = this.position;
			return e && (t[4] -= e[0], t[5] -= e[1]), o.scale(t, t, n), i && o.rotate(t, t, i), e && (t[4] += e[0], t[5] += e[1]), t[4] += r[0], t[5] += r[1], t
		}, u.setTransform = function(t) {
			var e = this.transform;
			e && t.transform(e[0], e[1], e[2], e[3], e[4], e[5])
		};
		var p = [];
		u.decomposeTransform = function() {
			if (this.transform) {
				var t = this.parent,
					e = this.transform;
				t && t.transform && (o.mul(p, t.invTransform, e), e = p);
				var n = e[0] * e[0] + e[1] * e[1],
					r = e[2] * e[2] + e[3] * e[3],
					s = this.position,
					a = this.scale;
				i(n - 1) && (n = Math.sqrt(n)), i(r - 1) && (r = Math.sqrt(r)), e[0] < 0 && (n = -n), e[3] < 0 && (r = -r), s[0] = e[4], s[1] = e[5], a[0] = n, a[1] = r, this.rotation = Math.atan2(-e[1] / r, e[0] / n)
			}
		}, u.getGlobalScale = function() {
			var t = this.transform;
			if (!t) return [1, 1];
			var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]),
				n = Math.sqrt(t[2] * t[2] + t[3] * t[3]);
			return t[0] < 0 && (e = -e), t[3] < 0 && (n = -n), [e, n]
		}, u.transformCoordToLocal = function(t, e) {
			var n = [t, e],
				i = this.invTransform;
			return i && r.applyTransform(n, n, i), n
		}, u.transformCoordToGlobal = function(t, e) {
			var n = [t, e],
				i = this.transform;
			return i && r.applyTransform(n, n, i), n
		}, t.exports = l
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			o.each(r, function(e) {
				this[e] = o.bind(t[e], t)
			}, this)
		}
		var o = n(1),
			r = ["getDom", "getZr", "getWidth", "getHeight", "dispatchAction", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption"];
		t.exports = i
	}, function(t, e, n) {
		var i = n(1);
		n(52), n(80), n(81);
		var o = n(109),
			r = n(2);
		r.registerLayout(i.curry(o, "bar")), r.registerVisualCoding("chart", function(t) {
			t.eachSeriesByType("bar", function(t) {
				var e = t.getData();
				e.setVisual("legendSymbol", "roundRect")
			})
		}), n(36)
	}, function(t, e, n) {
		"use strict";
		var i = n(13),
			o = n(35);
		t.exports = i.extend({
			type: "series.bar",
			dependencies: ["grid", "polar"],
			getInitialData: function(t, e) {
				return o(t.data, this, e)
			},
			getMarkerPosition: function(t) {
				var e = this.coordinateSystem;
				if (e) {
					var n = e.dataToPoint(t),
						i = this.getData(),
						o = i.getLayout("offset"),
						r = i.getLayout("size"),
						s = e.getBaseAxis().isHorizontal() ? 0 : 1;
					return n[s] += o + r / 2, n
				}
				return [NaN, NaN]
			},
			defaultOption: {
				zlevel: 0,
				z: 2,
				coordinateSystem: "cartesian2d",
				legendHoverLink: !0,
				xAxisIndex: 0,
				yAxisIndex: 0,
				barMinHeight: 0,
				itemStyle: {
					normal: {
						barBorderColor: "#fff",
						barBorderWidth: 0
					},
					emphasis: {
						barBorderColor: "#fff",
						barBorderWidth: 0
					}
				}
			}
		})
	}, function(t, e, n) {
		"use strict";

		function i(t, e) {
			var n = t.width > 0 ? 1 : -1,
				i = t.height > 0 ? 1 : -1;
			e = Math.min(e, Math.abs(t.width), Math.abs(t.height)), t.x += n * e / 2, t.y += i * e / 2, t.width -= n * e, t.height -= i * e
		}
		var o = n(1),
			r = n(3);
		o.extend(n(12).prototype, n(82)), t.exports = n(2).extendChartView({
			type: "bar",
			render: function(t, e, n) {
				var i = t.get("coordinateSystem");
				return "cartesian2d" === i && this._renderOnCartesian(t, e, n), this.group
			},
			_renderOnCartesian: function(t, e, n) {
				function s(e, n) {
					var s = l.getItemLayout(e),
						a = l.getItemModel(e).get(d) || 0;
					i(s, a);
					var u = new r.Rect({
						shape: o.extend({}, s)
					});
					if (g) {
						var p = u.shape,
							h = c ? "height" : "width",
							f = {};
						p[h] = 0, f[h] = s[h], r[n ? "updateProps" : "initProps"](u, {
							shape: f
						}, t, e)
					}
					return u
				}
				var a = this.group,
					l = t.getData(),
					u = this._data,
					p = t.coordinateSystem,
					h = p.getBaseAxis(),
					c = h.isHorizontal(),
					g = t.get("animation"),
					d = ["itemStyle", "normal", "barBorderWidth"];
				l.diff(u).add(function(t) {
					if (l.hasValue(t)) {
						var e = s(t);
						l.setItemGraphicEl(t, e), a.add(e)
					}
				}).update(function(e, n) {
					var o = u.getItemGraphicEl(n);
					if (!l.hasValue(e)) return void a.remove(o);
					o || (o = s(e, !0));
					var p = l.getItemLayout(e),
						h = l.getItemModel(e).get(d) || 0;
					i(p, h), r.updateProps(o, {
						shape: p
					}, t, e), l.setItemGraphicEl(e, o), a.add(o)
				}).remove(function(e) {
					var n = u.getItemGraphicEl(e);
					n && (n.style.text = "", r.updateProps(n, {
						shape: {
							width: 0
						}
					}, t, e, function() {
						a.remove(n)
					}))
				}).execute(), this._updateStyle(t, l, c), this._data = l
			},
			_updateStyle: function(t, e, n) {
				function i(t, e, n, i, o) {
					r.setText(t, e, n), t.text = i, "outside" === t.textPosition && (t.textPosition = o)
				}
				e.eachItemGraphicEl(function(s, a) {
					var l = e.getItemModel(a),
						u = e.getItemVisual(a, "color"),
						p = e.getItemVisual(a, "opacity"),
						h = e.getItemLayout(a),
						c = l.getModel("itemStyle.normal"),
						g = l.getModel("itemStyle.emphasis").getBarItemStyle();
					s.setShape("r", c.get("barBorderRadius") || 0), s.useStyle(o.defaults({
						fill: u,
						opacity: p
					}, c.getBarItemStyle()));
					var d = n ? h.height > 0 ? "bottom" : "top" : h.width > 0 ? "left" : "right",
						f = l.getModel("label.normal"),
						m = l.getModel("label.emphasis"),
						y = s.style;
					f.get("show") ? i(y, f, u, o.retrieve(t.getFormattedLabel(a, "normal"), t.getRawValue(a)), d) : y.text = "", m.get("show") ? i(g, m, u, o.retrieve(t.getFormattedLabel(a, "emphasis"), t.getRawValue(a)), d) : g.text = "", r.setHoverStyle(s, g)
				})
			},
			remove: function(t, e) {
				var n = this.group;
				t.get("animation") ? this._data && this._data.eachItemGraphicEl(function(e) {
					e.style.text = "", r.updateProps(e, {
						shape: {
							width: 0
						}
					}, t, e.dataIndex, function() {
						n.remove(e)
					})
				}) : n.removeAll()
			}
		})
	}, function(t, e, n) {
		t.exports = {
			getBarItemStyle: n(30)([
				["fill", "color"],
				["stroke", "borderColor"],
				["lineWidth", "borderWidth"],
				["stroke", "barBorderColor"],
				["lineWidth", "barBorderWidth"],
				["opacity"],
				["shadowBlur"],
				["shadowOffsetX"],
				["shadowOffsetY"],
				["shadowColor"]
			])
		}
	}, function(t, e, n) {
		function i(t) {
			return "_" + t + "Type"
		}
		function o(t, e, n) {
			var i = e.getItemVisual(n, "color"),
				o = e.getItemVisual(n, t),
				r = e.getItemVisual(n, t + "Size");
			if (o && "none" !== o) {
				g.isArray(r) || (r = [r, r]);
				var s = u.createSymbol(o, -r[0] / 2, -r[1] / 2, r[0], r[1], i);
				return s.name = t, s
			}
		}
		function r(t) {
			var e = new h({
				name: "line"
			});
			return s(e.shape, t), e
		}
		function s(t, e) {
			var n = e[0],
				i = e[1],
				o = e[2];
			t.x1 = n[0], t.y1 = n[1], t.x2 = i[0], t.y2 = i[1], t.percent = 1, o && (t.cpx1 = o[0], t.cpy1 = o[1])
		}
		function a() {
			var t = this,
				e = t.childOfName("fromSymbol"),
				n = t.childOfName("toSymbol"),
				i = t.childOfName("label");
			if (e || n || !i.ignore) {
				for (var o = 1, r = this.parent; r;) r.scale && (o /= r.scale[0]), r = r.parent;
				var s = t.childOfName("line");
				if (this.__dirty || s.__dirty) {
					var a = s.shape.percent,
						l = s.pointAt(0),
						u = s.pointAt(a),
						h = p.sub([], u, l);
					if (p.normalize(h, h), e) {
						e.attr("position", l);
						var c = s.tangentAt(0);
						e.attr("rotation", Math.PI / 2 - Math.atan2(c[1], c[0])), e.attr("scale", [o * a, o * a])
					}
					if (n) {
						n.attr("position", u);
						var c = s.tangentAt(1);
						n.attr("rotation", -Math.PI / 2 - Math.atan2(c[1], c[0])), n.attr("scale", [o * a, o * a])
					}
					if (!i.ignore) {
						i.attr("position", u);
						var g, d, f, m = 5 * o;
						if ("end" === i.__position) g = [h[0] * m + u[0], h[1] * m + u[1]], d = h[0] > .8 ? "left" : h[0] < -.8 ? "right" : "center", f = h[1] > .8 ? "top" : h[1] < -.8 ? "bottom" : "middle";
						else if ("middle" === i.__position) {
							var y = a / 2,
								c = s.tangentAt(y),
								v = [c[1], -c[0]],
								x = s.pointAt(y);
							v[1] > 0 && (v[0] = -v[0], v[1] = -v[1]), g = [x[0] + v[0] * m, x[1] + v[1] * m], d = "center", f = "bottom";
							var j = -Math.atan2(c[1], c[0]);
							u[0] < l[0] && (j = Math.PI + j), i.attr("rotation", j)
						} else g = [-h[0] * m + l[0], -h[1] * m + l[1]], d = h[0] > .8 ? "right" : h[0] < -.8 ? "left" : "center", f = h[1] > .8 ? "bottom" : h[1] < -.8 ? "top" : "middle";
						i.attr({
							style: {
								textVerticalAlign: i.__verticalAlign || f,
								textAlign: i.__textAlign || d
							},
							position: g,
							scale: [o, o]
						})
					}
				}
			}
		}
		function l(t, e) {
			c.Group.call(this), this._createLine(t, e)
		}
		var u = n(25),
			p = n(5),
			h = n(164),
			c = n(3),
			g = n(1),
			d = n(4),
			f = ["fromSymbol", "toSymbol"],
			m = l.prototype;
		m.beforeUpdate = a, m._createLine = function(t, e) {
			var n = t.hostModel,
				s = t.getItemLayout(e),
				a = r(s);
			a.shape.percent = 0, c.initProps(a, {
				shape: {
					percent: 1
				}
			}, n, e), this.add(a);
			var l = new c.Text({
				name: "label"
			});
			this.add(l), g.each(f, function(n) {
				var r = o(n, t, e);
				this.add(r), this[i(n)] = t.getItemVisual(e, n)
			}, this), this._updateCommonStl(t, e)
		}, m.updateData = function(t, e) {
			var n = t.hostModel,
				r = this.childOfName("line"),
				a = t.getItemLayout(e),
				l = {
					shape: {}
				};
			s(l.shape, a), c.updateProps(r, l, n, e), g.each(f, function(n) {
				var r = t.getItemVisual(e, n),
					s = i(n);
				if (this[s] !== r) {
					var a = o(n, t, e);
					this.remove(this.childOfName(n)), this.add(a)
				}
				this[s] = r
			}, this), this._updateCommonStl(t, e)
		}, m._updateCommonStl = function(t, e) {
			var n = t.hostModel,
				i = this.childOfName("line"),
				o = t.getItemModel(e),
				r = o.getModel("label.normal"),
				s = r.getModel("textStyle"),
				a = o.getModel("label.emphasis"),
				l = a.getModel("textStyle"),
				u = d.round(n.getRawValue(e));
			isNaN(u) && (u = t.getName(e)), i.useStyle(g.extend({
				strokeNoScale: !0,
				fill: "none",
				stroke: t.getItemVisual(e, "color")
			}, o.getModel("lineStyle.normal").getLineStyle())), i.hoverStyle = o.getModel("lineStyle.emphasis").getLineStyle();
			var p = t.getItemVisual(e, "color") || "#000",
				h = this.childOfName("label");
			h.setStyle({
				text: r.get("show") ? g.retrieve(n.getFormattedLabel(e, "normal", t.dataType), u) : "",
				textFont: s.getFont(),
				fill: s.getTextColor() || p
			}), h.hoverStyle = {
				text: a.get("show") ? g.retrieve(n.getFormattedLabel(e, "emphasis", t.dataType), u) : "",
				textFont: l.getFont(),
				fill: l.getTextColor() || p
			}, h.__textAlign = s.get("align"), h.__verticalAlign = s.get("baseline"), h.__position = r.get("position"), h.ignore = !h.style.text && !h.hoverStyle.text, c.setHoverStyle(this)
		}, m.updateLayout = function(t, e) {
			var n = t.getItemLayout(e),
				i = this.childOfName("line");
			s(i.shape, n), i.dirty(!0)
		}, m.setLinePoints = function(t) {
			var e = this.childOfName("line");
			s(e.shape, t), e.dirty()
		}, g.inherits(l, c.Group), t.exports = l
	}, function(t, e, n) {
		function i(t) {
			return isNaN(t[0]) || isNaN(t[1])
		}
		function o(t) {
			return !i(t[0]) && !i(t[1])
		}
		function r(t) {
			this._ctor = t || a, this.group = new s.Group
		}
		var s = n(3),
			a = n(83),
			l = r.prototype;
		l.updateData = function(t) {
			var e = this._lineData,
				n = this.group,
				i = this._ctor;
			t.diff(e).add(function(e) {
				if (o(t.getItemLayout(e))) {
					var r = new i(t, e);
					t.setItemGraphicEl(e, r), n.add(r)
				}
			}).update(function(r, s) {
				var a = e.getItemGraphicEl(s);
				return o(t.getItemLayout(r)) ? (a ? a.updateData(t, r) : a = new i(t, r), t.setItemGraphicEl(r, a), void n.add(a)) : void n.remove(a)
			}).remove(function(t) {
				n.remove(e.getItemGraphicEl(t))
			}).execute(), this._lineData = t
		}, l.updateLayout = function() {
			var t = this._lineData;
			t.eachItemGraphicEl(function(e, n) {
				e.updateLayout(t, n)
			}, this)
		}, l.remove = function() {
			this.group.removeAll()
		}, t.exports = r
	}, function(t, e, n) {
		var i = n(1),
			o = n(2);
		n(86), n(87), o.registerVisualCoding("chart", i.curry(n(44), "line", "circle", "line")), o.registerLayout(i.curry(n(53), "line")), o.registerProcessor("statistic", i.curry(n(121), "line")), n(36)
	}, function(t, e, n) {
		"use strict";
		var i = n(35),
			o = n(13);
		t.exports = o.extend({
			type: "series.line",
			dependencies: ["grid", "polar"],
			getInitialData: function(t, e) {
				return i(t.data, this, e)
			},
			defaultOption: {
				zlevel: 0,
				z: 2,
				coordinateSystem: "cartesian2d",
				legendHoverLink: !0,
				hoverAnimation: !0,
				xAxisIndex: 0,
				yAxisIndex: 0,
				polarIndex: 0,
				clipOverflow: !0,
				label: {
					normal: {
						position: "top"
					}
				},
				lineStyle: {
					normal: {
						width: 2,
						type: "solid"
					}
				},
				smooth: !1,
				smoothMonotone: null,
				symbol: "emptyCircle",
				symbolSize: 4,
				symbolRotate: null,
				showSymbol: !0,
				showAllSymbol: !1,
				connectNulls: !1,
				sampling: "none",
				animationEasing: "linear"
			}
		})
	}, function(t, e, n) {
		"use strict";

		function i(t, e) {
			if (t.length === e.length) {
				for (var n = 0; n < t.length; n++) {
					var i = t[n],
						o = e[n];
					if (i[0] !== o[0] || i[1] !== o[1]) return
				}
				return !0
			}
		}
		function o(t) {
			return "number" == typeof t ? t : t ? .3 : 0
		}
		function r(t) {
			var e = t.getGlobalExtent();
			if (t.onBand) {
				var n = t.getBandWidth() / 2 - 1,
					i = e[1] > e[0] ? 1 : -1;
				e[0] += i * n, e[1] -= i * n
			}
			return e
		}
		function s(t) {
			return t >= 0 ? 1 : -1
		}
		function a(t, e) {
			var n = t.getBaseAxis(),
				i = t.getOtherAxis(n),
				o = n.onZero ? 0 : i.scale.getExtent()[0],
				r = i.dim,
				a = "x" === r || "radius" === r ? 1 : 0;
			return e.mapArray([r], function(i, l) {
				for (var u, p = e.stackedOn; p && s(p.get(r, l)) === s(i);) {
					u = p;
					break
				}
				var h = [];
				return h[a] = e.get(n.dim, l), h[1 - a] = u ? u.get(r, l, !0) : o, t.dataToPoint(h)
			}, !0)
		}
		function l(t, e) {
			return null != e.dataIndex ? e.dataIndex : null != e.name ? t.indexOfName(e.name) : void 0
		}
		function u(t, e, n) {
			var i = r(t.getAxis("x")),
				o = r(t.getAxis("y")),
				s = t.getBaseAxis().isHorizontal(),
				a = Math.min(i[0], i[1]),
				l = Math.min(o[0], o[1]),
				u = Math.max(i[0], i[1]) - a,
				p = Math.max(o[0], o[1]) - l,
				h = n.get("lineStyle.normal.width") || 2,
				c = n.get("clipOverflow") ? h / 2 : Math.max(u, p);
			s ? (l -= c, p += 2 * c) : (a -= c, u += 2 * c);
			var g = new m.Rect({
				shape: {
					x: a,
					y: l,
					width: u,
					height: p
				}
			});
			return e && (g.shape[s ? "width" : "height"] = 0, m.initProps(g, {
				shape: {
					width: u,
					height: p
				}
			}, n)), g
		}
		function p(t, e, n) {
			var i = t.getAngleAxis(),
				o = t.getRadiusAxis(),
				r = o.getExtent(),
				s = i.getExtent(),
				a = Math.PI / 180,
				l = new m.Sector({
					shape: {
						cx: t.cx,
						cy: t.cy,
						r0: r[0],
						r: r[1],
						startAngle: -s[0] * a,
						endAngle: -s[1] * a,
						clockwise: i.inverse
					}
				});
			return e && (l.shape.endAngle = -s[0] * a, m.initProps(l, {
				shape: {
					endAngle: -s[1] * a
				}
			}, n)), l
		}
		function h(t, e, n) {
			return "polar" === t.type ? p(t, e, n) : u(t, e, n)
		}
		var c = n(1),
			g = n(39),
			d = n(47),
			f = n(88),
			m = n(3),
			y = n(89),
			v = n(26);
		t.exports = v.extend({
			type: "line",
			init: function() {
				var t = new m.Group,
					e = new g;
				this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t
			},
			render: function(t, e, n) {
				var r = t.coordinateSystem,
					s = this.group,
					l = t.getData(),
					u = t.getModel("lineStyle.normal"),
					p = t.getModel("areaStyle.normal"),
					g = l.mapArray(l.getItemLayout, !0),
					d = "polar" === r.type,
					f = this._coordSys,
					m = this._symbolDraw,
					y = this._polyline,
					v = this._polygon,
					x = this._lineGroup,
					j = t.get("animation"),
					E = !p.isEmpty(),
					I = a(r, l),
					C = t.get("showSymbol"),
					S = C && !d && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, r),
					b = this._data;
				b && b.eachItemGraphicEl(function(t, e) {
					t.__temp && (s.remove(t), b.setItemGraphicEl(e, null))
				}), C || m.remove(), s.add(x), y && f.type === r.type ? (E && !v ? v = this._newPolygon(g, I, r, j) : v && !E && (x.remove(v), v = this._polygon = null), x.setClipPath(h(r, !1, t)), C && m.updateData(l, S), l.eachItemGraphicEl(function(t) {
					t.stopAnimation(!0)
				}), i(this._stackedOnPoints, I) && i(this._points, g) || (j ? this._updateAnimation(l, I, r, n) : (y.setShape({
					points: g
				}), v && v.setShape({
					points: g,
					stackedOnPoints: I
				})))) : (C && m.updateData(l, S), y = this._newPolyline(g, r, j), E && (v = this._newPolygon(g, I, r, j)), x.setClipPath(h(r, !0, t))), y.useStyle(c.defaults(u.getLineStyle(), {
					fill: "none",
					stroke: l.getVisual("color"),
					lineJoin: "bevel"
				}));
				var L = t.get("smooth");
				if (L = o(t.get("smooth")), y.setShape({
					smooth: L,
					smoothMonotone: t.get("smoothMonotone"),
					connectNulls: t.get("connectNulls")
				}), v) {
					var w = l.stackedOn,
						P = 0;
					if (v.useStyle(c.defaults(p.getAreaStyle(), {
						fill: l.getVisual("color"),
						opacity: .7,
						lineJoin: "bevel"
					})), w) {
						var M = w.hostModel;
						P = o(M.get("smooth"))
					}
					v.setShape({
						smooth: L,
						stackedOnSmooth: P,
						smoothMonotone: t.get("smoothMonotone"),
						connectNulls: t.get("connectNulls")
					})
				}
				this._data = l, this._coordSys = r, this._stackedOnPoints = I, this._points = g
			},
			highlight: function(t, e, n, i) {
				var o = t.getData(),
					r = l(o, i);
				if (null != r && r >= 0) {
					var s = o.getItemGraphicEl(r);
					if (!s) {
						var a = o.getItemLayout(r);
						s = new d(o, r, n), s.position = a, s.setZ(t.get("zlevel"), t.get("z")), s.ignore = isNaN(a[0]) || isNaN(a[1]), s.__temp = !0, o.setItemGraphicEl(r, s), s.stopSymbolAnimation(!0), this.group.add(s)
					}
					s.highlight()
				} else v.prototype.highlight.call(this, t, e, n, i)
			},
			downplay: function(t, e, n, i) {
				var o = t.getData(),
					r = l(o, i);
				if (null != r && r >= 0) {
					var s = o.getItemGraphicEl(r);
					s && (s.__temp ? (o.setItemGraphicEl(r, null), this.group.remove(s)) : s.downplay())
				} else v.prototype.downplay.call(this, t, e, n, i)
			},
			_newPolyline: function(t) {
				var e = this._polyline;
				return e && this._lineGroup.remove(e), e = new y.Polyline({
					shape: {
						points: t
					},
					silent: !0,
					z2: 10
				}), this._lineGroup.add(e), this._polyline = e, e
			},
			_newPolygon: function(t, e) {
				var n = this._polygon;
				return n && this._lineGroup.remove(n), n = new y.Polygon({
					shape: {
						points: t,
						stackedOnPoints: e
					},
					silent: !0
				}), this._lineGroup.add(n), this._polygon = n, n
			},
			_getSymbolIgnoreFunc: function(t, e) {
				var n = e.getAxesByScale("ordinal")[0];
				return n && n.isLabelIgnored ? c.bind(n.isLabelIgnored, n) : void 0
			},
			_updateAnimation: function(t, e, n, i) {
				var o = this._polyline,
					r = this._polygon,
					s = t.hostModel,
					a = f(this._data, t, this._stackedOnPoints, e, this._coordSys, n);
				o.shape.points = a.current, m.updateProps(o, {
					shape: {
						points: a.next
					}
				}, s), r && (r.setShape({
					points: a.current,
					stackedOnPoints: a.stackedOnCurrent
				}), m.updateProps(r, {
					shape: {
						points: a.next,
						stackedOnPoints: a.stackedOnNext
					}
				}, s));
				for (var l = [], u = a.status, p = 0; p < u.length; p++) {
					var h = u[p].cmd;
					if ("=" === h) {
						var c = t.getItemGraphicEl(u[p].idx1);
						c && l.push({
							el: c,
							ptIdx: p
						})
					}
				}
				o.animators && o.animators.length && o.animators[0].during(function() {
					for (var t = 0; t < l.length; t++) {
						var e = l[t].el;
						e.attr("position", o.shape.points[l[t].ptIdx])
					}
				})
			},
			remove: function(t) {
				var e = this.group,
					n = this._data;
				this._lineGroup.removeAll(), this._symbolDraw.remove(!0), n && n.eachItemGraphicEl(function(t, i) {
					t.__temp && (e.remove(t), n.setItemGraphicEl(i, null))
				}), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
			}
		})
	}, function(t, e) {
		function n(t) {
			return t >= 0 ? 1 : -1
		}
		function i(t, e, i) {
			for (var o, r = t.getBaseAxis(), s = t.getOtherAxis(r), a = r.onZero ? 0 : s.scale.getExtent()[0], l = s.dim, u = "x" === l || "radius" === l ? 1 : 0, p = e.stackedOn, h = e.get(l, i); p && n(p.get(l, i)) === n(h);) {
				o = p;
				break
			}
			var c = [];
			return c[u] = e.get(r.dim, i), c[1 - u] = o ? o.get(l, i, !0) : a, t.dataToPoint(c)
		}
		function o(t, e) {
			var n = [];
			return e.diff(t).add(function(t) {
				n.push({
					cmd: "+",
					idx: t
				})
			}).update(function(t, e) {
				n.push({
					cmd: "=",
					idx: e,
					idx1: t
				})
			}).remove(function(t) {
				n.push({
					cmd: "-",
					idx: t
				})
			}).execute(), n
		}
		t.exports = function(t, e, n, r, s, a) {
			for (var l = o(t, e), u = [], p = [], h = [], c = [], g = [], d = [], f = [], m = a.dimensions, y = 0; y < l.length; y++) {
				var v = l[y],
					x = !0;
				switch (v.cmd) {
				case "=":
					var j = t.getItemLayout(v.idx),
						E = e.getItemLayout(v.idx1);
					(isNaN(j[0]) || isNaN(j[1])) && (j = E.slice()), u.push(j), p.push(E), h.push(n[v.idx]), c.push(r[v.idx1]), f.push(e.getRawIndex(v.idx1));
					break;
				case "+":
					var I = v.idx;
					u.push(s.dataToPoint([e.get(m[0], I, !0), e.get(m[1], I, !0)])), p.push(e.getItemLayout(I).slice()), h.push(i(s, e, I)), c.push(r[I]), f.push(e.getRawIndex(I));
					break;
				case "-":
					var I = v.idx,
						C = t.getRawIndex(I);
					C !== I ? (u.push(t.getItemLayout(I)), p.push(a.dataToPoint([t.get(m[0], I, !0), t.get(m[1], I, !0)])), h.push(n[I]), c.push(i(a, t, I)), f.push(C)) : x = !1
				}
				x && (g.push(v), d.push(d.length))
			}
			d.sort(function(t, e) {
				return f[t] - f[e]
			});
			for (var S = [], b = [], L = [], w = [], P = [], y = 0; y < d.length; y++) {
				var I = d[y];
				S[y] = u[I], b[y] = p[I], L[y] = h[I], w[y] = c[I], P[y] = g[I]
			}
			return {
				current: S,
				next: b,
				stackedOnCurrent: L,
				stackedOnNext: w,
				status: P
			}
		}
	}, function(t, e, n) {
		function i(t) {
			return isNaN(t[0]) || isNaN(t[1])
		}
		function o(t, e, n, o, r, s, f, m, y, v, x) {
			for (var j = 0, E = n, I = 0; o > I; I++) {
				var C = e[E];
				if (E >= r || 0 > E) break;
				if (i(C)) {
					if (x) {
						E += s;
						continue
					}
					break
				}
				if (E === n) t[s > 0 ? "moveTo" : "lineTo"](C[0], C[1]), h(g, C);
				else if (y > 0) {
					var S = E + s,
						b = e[S];
					if (x) for (; b && i(e[S]);) S += s, b = e[S];
					var L = .5,
						w = e[j],
						b = e[S];
					if (!b || i(b)) h(d, C);
					else {
						i(b) && !x && (b = C), a.sub(c, b, w);
						var P, M;
						if ("x" === v || "y" === v) {
							var _ = "x" === v ? 0 : 1;
							P = Math.abs(C[_] - w[_]), M = Math.abs(C[_] - b[_])
						} else P = a.dist(C, w), M = a.dist(C, b);
						L = M / (M + P), p(d, C, c, -y * (1 - L))
					}
					l(g, g, m), u(g, g, f), l(d, d, m), u(d, d, f), t.bezierCurveTo(g[0], g[1], d[0], d[1], C[0], C[1]), p(g, C, c, y * L)
				} else t.lineTo(C[0], C[1]);
				j = E, E += s
			}
			return I
		}
		function r(t, e) {
			var n = [1 / 0, 1 / 0],
				i = [-(1 / 0), -(1 / 0)];
			if (e) for (var o = 0; o < t.length; o++) {
				var r = t[o];
				r[0] < n[0] && (n[0] = r[0]), r[1] < n[1] && (n[1] = r[1]), r[0] > i[0] && (i[0] = r[0]), r[1] > i[1] && (i[1] = r[1])
			}
			return {
				min: e ? n : i,
				max: e ? i : n
			}
		}
		var s = n(6),
			a = n(5),
			l = a.min,
			u = a.max,
			p = a.scaleAndAdd,
			h = a.copy,
			c = [],
			g = [],
			d = [];
		t.exports = {
			Polyline: s.extend({
				type: "ec-polyline",
				shape: {
					points: [],
					smooth: 0,
					smoothConstraint: !0,
					smoothMonotone: null,
					connectNulls: !1
				},
				style: {
					fill: null,
					stroke: "#000"
				},
				buildPath: function(t, e) {
					var n = e.points,
						s = 0,
						a = n.length,
						l = r(n, e.smoothConstraint);
					if (e.connectNulls) {
						for (; a > 0 && i(n[a - 1]); a--);
						for (; a > s && i(n[s]); s++);
					}
					for (; a > s;) s += o(t, n, s, a, a, 1, l.min, l.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1
				}
			}),
			Polygon: s.extend({
				type: "ec-polygon",
				shape: {
					points: [],
					stackedOnPoints: [],
					smooth: 0,
					stackedOnSmooth: 0,
					smoothConstraint: !0,
					smoothMonotone: null,
					connectNulls: !1
				},
				buildPath: function(t, e) {
					var n = e.points,
						s = e.stackedOnPoints,
						a = 0,
						l = n.length,
						u = e.smoothMonotone,
						p = r(n, e.smoothConstraint),
						h = r(s, e.smoothConstraint);
					if (e.connectNulls) {
						for (; l > 0 && i(n[l - 1]); l--);
						for (; l > a && i(n[a]); a++);
					}
					for (; l > a;) {
						var c = o(t, n, a, l, l, 1, p.min, p.max, e.smooth, u, e.connectNulls);
						o(t, s, a + c - 1, c, l, -1, h.min, h.max, e.stackedOnSmooth, u, e.connectNulls), a += c + 1, t.closePath()
					}
				}
			})
		}
	}, function(t, e, n) {
		var i = n(1),
			o = n(2);
		n(91), n(92), n(69)("pie", [{
			type: "pieToggleSelect",
			event: "pieselectchanged",
			method: "toggleSelected"
		}, {
			type: "pieSelect",
			event: "pieselected",
			method: "select"
		}, {
			type: "pieUnSelect",
			event: "pieunselected",
			method: "unSelect"
		}]), o.registerVisualCoding("chart", i.curry(n(64), "pie")), o.registerLayout(i.curry(n(94), "pie")), o.registerProcessor("filter", i.curry(n(63), "pie"))
	}, function(t, e, n) {
		"use strict";
		var i = n(15),
			o = n(1),
			r = n(7),
			s = n(31),
			a = n(61),
			l = n(2).extendSeriesModel({
				type: "series.pie",
				init: function(t) {
					l.superApply(this, "init", arguments), this.legendDataProvider = function() {
						return this._dataBeforeProcessed
					}, this.updateSelectedMap(t.data), this._defaultLabelLine(t)
				},
				mergeOption: function(t) {
					l.superCall(this, "mergeOption", t), this.updateSelectedMap(this.option.data)
				},
				getInitialData: function(t, e) {
					var n = s(["value"], t.data),
						o = new i(n, this);
					return o.initData(t.data), o
				},
				getDataParams: function(t) {
					var e = this._data,
						n = l.superCall(this, "getDataParams", t),
						i = e.getSum("value");
					return n.percent = i ? +(e.get("value", t) / i * 100).toFixed(2) : 0, n.$vars.push("percent"), n
				},
				_defaultLabelLine: function(t) {
					r.defaultEmphasis(t.labelLine, ["show"]);
					var e = t.labelLine.normal,
						n = t.labelLine.emphasis;
					e.show = e.show && t.label.normal.show, n.show = n.show && t.label.emphasis.show
				},
				defaultOption: {
					zlevel: 0,
					z: 2,
					legendHoverLink: !0,
					hoverAnimation: !0,
					center: ["50%", "50%"],
					radius: [0, "75%"],
					clockwise: !0,
					startAngle: 90,
					minAngle: 0,
					selectedOffset: 10,
					avoidLabelOverlap: !0,
					label: {
						normal: {
							rotate: !1,
							show: !0,
							position: "outer"
						},
						emphasis: {}
					},
					labelLine: {
						normal: {
							show: !0,
							length: 15,
							length2: 15,
							smooth: !1,
							lineStyle: {
								width: 1,
								type: "solid"
							}
						}
					},
					itemStyle: {
						normal: {
							borderColor: "rgba(0,0,0,0)",
							borderWidth: 1
						},
						emphasis: {
							borderColor: "rgba(0,0,0,0)",
							borderWidth: 1
						}
					},
					animationEasing: "cubicOut",
					data: []
				}
			});
		o.mixin(l, a), t.exports = l
	}, function(t, e, n) {
		function i(t, e, n, i) {
			var r = e.getData(),
				s = this.dataIndex,
				a = r.getName(s),
				l = e.get("selectedOffset");
			i.dispatchAction({
				type: "pieToggleSelect",
				from: t,
				name: a,
				seriesId: e.id
			}), r.each(function(t) {
				o(r.getItemGraphicEl(t), r.getItemLayout(t), e.isSelected(r.getName(t)), l, n)
			})
		}
		function o(t, e, n, i, o) {
			var r = (e.startAngle + e.endAngle) / 2,
				s = Math.cos(r),
				a = Math.sin(r),
				l = n ? i : 0,
				u = [s * l, a * l];
			o ? t.animate().when(200, {
				position: u
			}).start("bounceOut") : t.attr("position", u)
		}
		function r(t, e) {
			function n() {
				r.ignore = r.hoverIgnore, s.ignore = s.hoverIgnore
			}
			function i() {
				r.ignore = r.normalIgnore, s.ignore = s.normalIgnore
			}
			a.Group.call(this);
			var o = new a.Sector({
				z2: 2
			}),
				r = new a.Polyline,
				s = new a.Text;
			this.add(o), this.add(r), this.add(s), this.updateData(t, e, !0), this.on("emphasis", n).on("normal", i).on("mouseover", n).on("mouseout", i)
		}
		function s(t, e, n, i, o) {
			var r = i.getModel("textStyle"),
				s = "inside" === o || "inner" === o;
			return {
				fill: r.getTextColor() || (s ? "#fff" : t.getItemVisual(e, "color")),
				opacity: t.getItemVisual(e, "opacity"),
				textFont: r.getFont(),
				text: l.retrieve(t.hostModel.getFormattedLabel(e, n), t.getName(e))
			}
		}
		var a = n(3),
			l = n(1),
			u = r.prototype;
		u.updateData = function(t, e, n) {
			function i() {
				s.stopAnimation(!0), s.animateTo({
					shape: {
						r: h.r + 10
					}
				}, 300, "elasticOut")
			}
			function r() {
				s.stopAnimation(!0), s.animateTo({
					shape: {
						r: h.r
					}
				}, 300, "elasticOut")
			}
			var s = this.childAt(0),
				u = t.hostModel,
				p = t.getItemModel(e),
				h = t.getItemLayout(e),
				c = l.extend({}, h);
			c.label = null, n ? (s.setShape(c), s.shape.endAngle = h.startAngle, a.updateProps(s, {
				shape: {
					endAngle: h.endAngle
				}
			}, u, e)) : a.updateProps(s, {
				shape: c
			}, u, e);
			var g = p.getModel("itemStyle"),
				d = t.getItemVisual(e, "color");
			s.useStyle(l.defaults({
				fill: d
			}, g.getModel("normal").getItemStyle())), s.hoverStyle = g.getModel("emphasis").getItemStyle(), o(this, t.getItemLayout(e), p.get("selected"), u.get("selectedOffset"), u.get("animation")), s.off("mouseover").off("mouseout").off("emphasis").off("normal"), p.get("hoverAnimation") && s.on("mouseover", i).on("mouseout", r).on("emphasis", i).on("normal", r), this._updateLabel(t, e), a.setHoverStyle(this)
		}, u._updateLabel = function(t, e) {
			var n = this.childAt(1),
				i = this.childAt(2),
				o = t.hostModel,
				r = t.getItemModel(e),
				l = t.getItemLayout(e),
				u = l.label,
				p = t.getItemVisual(e, "color");
			a.updateProps(n, {
				shape: {
					points: u.linePoints || [
						[u.x, u.y],
						[u.x, u.y],
						[u.x, u.y]
					]
				}
			}, o, e), a.updateProps(i, {
				style: {
					x: u.x,
					y: u.y
				}
			}, o, e), i.attr({
				style: {
					textVerticalAlign: u.verticalAlign,
					textAlign: u.textAlign,
					textFont: u.font
				},
				rotation: u.rotation,
				origin: [u.x, u.y],
				z2: 10
			});
			var h = r.getModel("label.normal"),
				c = r.getModel("label.emphasis"),
				g = r.getModel("labelLine.normal"),
				d = r.getModel("labelLine.emphasis"),
				f = h.get("position") || c.get("position");
			i.setStyle(s(t, e, "normal", h, f)), i.ignore = i.normalIgnore = !h.get("show"), i.hoverIgnore = !c.get("show"), n.ignore = n.normalIgnore = !g.get("show"), n.hoverIgnore = !d.get("show"), n.setStyle({
				stroke: p,
				opacity: t.getItemVisual(e, "opacity")
			}), n.setStyle(g.getModel("lineStyle").getLineStyle()), i.hoverStyle = s(t, e, "emphasis", c, f), n.hoverStyle = d.getModel("lineStyle").getLineStyle();
			var m = g.get("smooth");
			m && m === !0 && (m = .4), n.setShape({
				smooth: m
			})
		}, l.inherits(r, a.Group);
		var p = n(26).extend({
			type: "pie",
			init: function() {
				var t = new a.Group;
				this._sectorGroup = t
			},
			render: function(t, e, n, o) {
				if (!o || o.from !== this.uid) {
					var s = t.getData(),
						a = this._data,
						u = this.group,
						p = e.get("animation"),
						h = !a,
						c = l.curry(i, this.uid, t, p, n),
						g = t.get("selectedMode");
					if (s.diff(a).add(function(t) {
						var e = new r(s, t);
						h && e.eachChild(function(t) {
							t.stopAnimation(!0)
						}), g && e.on("click", c), s.setItemGraphicEl(t, e), u.add(e)
					}).update(function(t, e) {
						var n = a.getItemGraphicEl(e);
						n.updateData(s, t), n.off("click"), g && n.on("click", c), u.add(n), s.setItemGraphicEl(t, n)
					}).remove(function(t) {
						var e = a.getItemGraphicEl(t);
						u.remove(e)
					}).execute(), p && h && s.count() > 0) {
						var d = s.getItemLayout(0),
							f = Math.max(n.getWidth(), n.getHeight()) / 2,
							m = l.bind(u.removeClipPath, u);
						u.setClipPath(this._createClipPath(d.cx, d.cy, f, d.startAngle, d.clockwise, m, t))
					}
					this._data = s
				}
			},
			_createClipPath: function(t, e, n, i, o, r, s) {
				var l = new a.Sector({
					shape: {
						cx: t,
						cy: e,
						r0: 0,
						r: n,
						startAngle: i,
						endAngle: i,
						clockwise: o
					}
				});
				return a.initProps(l, {
					shape: {
						endAngle: i + (o ? 1 : -1) * Math.PI * 2
					}
				}, s, r), l
			}
		});
		t.exports = p
	}, function(t, e, n) {
		"use strict";

		function i(t, e, n, i, o, r, s) {
			function a(e, n, i, o) {
				for (var r = e; n > r; r++) if (t[r].y += i, r > e && n > r + 1 && t[r + 1].y > t[r].y + t[r].height) return void l(r, i / 2);
				l(n - 1, i / 2)
			}
			function l(e, n) {
				for (var i = e; i >= 0 && (t[i].y -= n, !(i > 0 && t[i].y > t[i - 1].y + t[i - 1].height)); i--);
			}
			function u(t, e, n, i, o, r) {
				for (var s = r > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, a = 0, l = t.length; l > a; a++) if ("center" !== t[a].position) {
					var u = Math.abs(t[a].y - i),
						p = t[a].len,
						h = t[a].len2,
						c = o + p > u ? Math.sqrt((o + p + h) * (o + p + h) - u * u) : Math.abs(t[a].x - n);
					e && c >= s && (c = s - 10), !e && s >= c && (c = s + 10), t[a].x = n + c * r, s = c
				}
			}
			t.sort(function(t, e) {
				return t.y - e.y
			});
			for (var p, h = 0, c = t.length, g = [], d = [], f = 0; c > f; f++) p = t[f].y - h, 0 > p && a(f, c, -p, o), h = t[f].y + t[f].height;
			0 > s - h && l(c - 1, h - s);
			for (var f = 0; c > f; f++) t[f].y >= n ? d.push(t[f]) : g.push(t[f]);
			u(g, !1, e, n, i, o), u(d, !0, e, n, i, o)
		}
		function o(t, e, n, o, r, s) {
			for (var a = [], l = [], u = 0; u < t.length; u++) t[u].x < e ? a.push(t[u]) : l.push(t[u]);
			i(l, e, n, o, 1, r, s), i(a, e, n, o, -1, r, s);
			for (var u = 0; u < t.length; u++) {
				var p = t[u].linePoints;
				if (p) {
					var h = p[1][0] - p[2][0];
					t[u].x < e ? p[2][0] = t[u].x + 3 : p[2][0] = t[u].x - 3, p[1][1] = p[2][1] = t[u].y, p[1][0] = p[2][0] + h
				}
			}
		}
		var r = n(18);
		t.exports = function(t, e, n, i) {
			var s, a, l = t.getData(),
				u = [],
				p = !1;
			l.each(function(n) {
				var i, o, h, c, g = l.getItemLayout(n),
					d = l.getItemModel(n),
					f = d.getModel("label.normal"),
					m = f.get("position") || d.get("label.emphasis.position"),
					y = d.getModel("labelLine.normal"),
					v = y.get("length"),
					x = y.get("length2"),
					j = (g.startAngle + g.endAngle) / 2,
					E = Math.cos(j),
					I = Math.sin(j);
				s = g.cx, a = g.cy;
				var C = "inside" === m || "inner" === m;
				if ("center" === m) i = g.cx, o = g.cy, c = "center";
				else {
					var S = (C ? (g.r + g.r0) / 2 * E : g.r * E) + s,
						b = (C ? (g.r + g.r0) / 2 * I : g.r * I) + a;
					if (i = S + 3 * E, o = b + 3 * I, !C) {
						var L = S + E * (v + e - g.r),
							w = b + I * (v + e - g.r),
							P = L + (0 > E ? -1 : 1) * x,
							M = w;
						i = P + (0 > E ? -5 : 5), o = M, h = [
							[S, b],
							[L, w],
							[P, M]
						]
					}
					c = C ? "center" : E > 0 ? "left" : "right"
				}
				var _ = f.getModel("textStyle").getFont(),
					N = f.get("rotate") ? 0 > E ? -j + Math.PI : -j : 0,
					A = t.getFormattedLabel(n, "normal") || l.getName(n),
					T = r.getBoundingRect(A, _, c, "top");
				p = !! N, g.label = {
					x: i,
					y: o,
					position: m,
					height: T.height,
					len: v,
					len2: x,
					linePoints: h,
					textAlign: c,
					verticalAlign: "middle",
					font: _,
					rotation: N
				}, C || u.push(g.label)
			}), !p && t.get("avoidLabelOverlap") && o(u, s, a, e, n, i)
		}
	}, function(t, e, n) {
		var i = n(4),
			o = i.parsePercent,
			r = n(93),
			s = n(1),
			a = 2 * Math.PI,
			l = Math.PI / 180;
		t.exports = function(t, e, n) {
			e.eachSeriesByType(t, function(t) {
				var e = t.get("center"),
					u = t.get("radius");
				s.isArray(u) || (u = [0, u]), s.isArray(e) || (e = [e, e]);
				var p = n.getWidth(),
					h = n.getHeight(),
					c = Math.min(p, h),
					g = o(e[0], p),
					d = o(e[1], h),
					f = o(u[0], c / 2),
					m = o(u[1], c / 2),
					y = t.getData(),
					v = -t.get("startAngle") * l,
					x = t.get("minAngle") * l,
					j = y.getSum("value"),
					E = Math.PI / (j || y.count()) * 2,
					I = t.get("clockwise"),
					C = t.get("roseType"),
					S = y.getDataExtent("value");
				S[0] = 0;
				var b = a,
					L = 0,
					w = v,
					P = I ? 1 : -1;
				if (y.each("value", function(t, e) {
					var n;
					n = "area" !== C ? 0 === j ? E : t * E : a / (y.count() || 1), x > n ? (n = x, b -= x) : L += t;
					var o = w + P * n;
					y.setItemLayout(e, {
						angle: n,
						startAngle: w,
						endAngle: o,
						clockwise: I,
						cx: g,
						cy: d,
						r0: f,
						r: C ? i.linearMap(t, S, [f, m]) : m
					}), w = o
				}, !0), a > b) if (.001 >= b) {
					var M = a / y.count();
					y.each(function(t) {
						var e = y.getItemLayout(t);
						e.startAngle = v + P * t * M, e.endAngle = v + P * (t + 1) * M
					})
				} else E = b / L, w = v, y.each("value", function(t, e) {
					var n = y.getItemLayout(e),
						i = n.angle === x ? x : t * E;
					n.startAngle = w, n.endAngle = w + P * i, w += i
				});
				r(t, m, p, h)
			})
		}
	}, function(t, e, n) {
		"use strict";
		n(51), n(96)
	}, function(t, e, n) {
		function i(t, e) {
			function n(t, e) {
				var n = i.getAxis(t);
				return n.toGlobalCoord(n.dataToCoord(0))
			}
			var i = t.coordinateSystem,
				o = e.axis,
				r = {},
				s = o.position,
				a = o.onZero ? "onZero" : s,
				l = o.dim,
				u = i.getRect(),
				p = [u.x, u.x + u.width, u.y, u.y + u.height],
				h = {
					x: {
						top: p[2],
						bottom: p[3]
					},
					y: {
						left: p[0],
						right: p[1]
					}
				};
			h.x.onZero = Math.max(Math.min(n("y"), h.x.bottom), h.x.top), h.y.onZero = Math.max(Math.min(n("x"), h.y.right), h.y.left), r.position = ["y" === l ? h.y[a] : p[0], "x" === l ? h.x[a] : p[3]];
			var c = {
				x: 0,
				y: 1
			};
			r.rotation = Math.PI / 2 * c[l];
			var g = {
				top: -1,
				bottom: 1,
				left: -1,
				right: 1
			};
			r.labelDirection = r.tickDirection = r.nameDirection = g[s], o.onZero && (r.labelOffset = h[l][s] - h[l].onZero), e.getModel("axisTick").get("inside") && (r.tickDirection = -r.tickDirection), e.getModel("axisLabel").get("inside") && (r.labelDirection = -r.labelDirection);
			var d = e.getModel("axisLabel").get("rotate");
			return r.labelRotation = "top" === a ? -d : d, r.labelInterval = o.getLabelInterval(), r.z2 = 1, r
		}
		var o = n(1),
			r = n(3),
			s = n(49),
			a = s.ifIgnoreOnTick,
			l = s.getInterval,
			u = ["axisLine", "axisLabel", "axisTick", "axisName"],
			p = ["splitLine", "splitArea"],
			h = n(2).extendComponentView({
				type: "axis",
				render: function(t, e) {
					if (this.group.removeAll(), t.get("show")) {
						var n = e.getComponent("grid", t.get("gridIndex")),
							r = i(n, t),
							a = new s(t, r);
						o.each(u, a.add, a), this.group.add(a.getGroup()), o.each(p, function(e) {
							t.get(e + ".show") && this["_" + e](t, n, r.labelInterval)
						}, this)
					}
				},
				_splitLine: function(t, e, n) {
					var i = t.axis,
						s = t.getModel("splitLine"),
						u = s.getModel("lineStyle"),
						p = u.get("width"),
						h = u.get("color"),
						c = l(s, n);
					h = o.isArray(h) ? h : [h];
					for (var g = e.coordinateSystem.getRect(), d = i.isHorizontal(), f = [], m = 0, y = i.getTicksCoords(), v = [], x = [], j = 0; j < y.length; j++) if (!a(i, j, c)) {
						var E = i.toGlobalCoord(y[j]);
						d ? (v[0] = E, v[1] = g.y, x[0] = E, x[1] = g.y + g.height) : (v[0] = g.x, v[1] = E, x[0] = g.x + g.width, x[1] = E);
						var I = m++ % h.length;
						f[I] = f[I] || [], f[I].push(new r.Line(r.subPixelOptimizeLine({
							shape: {
								x1: v[0],
								y1: v[1],
								x2: x[0],
								y2: x[1]
							},
							style: {
								lineWidth: p
							},
							silent: !0
						})))
					}
					for (var C = u.getLineStyle(), j = 0; j < f.length; j++) this.group.add(r.mergePath(f[j], {
						style: o.defaults({
							stroke: h[j % h.length]
						}, C),
						silent: !0
					}))
				},
				_splitArea: function(t, e, n) {
					var i = t.axis,
						s = t.getModel("splitArea"),
						u = s.getModel("areaStyle"),
						p = u.get("color"),
						h = e.coordinateSystem.getRect(),
						c = i.getTicksCoords(),
						g = i.toGlobalCoord(c[0]),
						d = i.toGlobalCoord(c[0]),
						f = [],
						m = 0,
						y = l(s, n);
					p = o.isArray(p) ? p : [p];
					for (var v = 1; v < c.length; v++) if (!a(i, v, y)) {
						var x, j, E, I, C = i.toGlobalCoord(c[v]);
						i.isHorizontal() ? (x = g, j = h.y, E = C - x, I = h.height) : (x = h.x, j = d, E = h.width, I = C - j);
						var S = m++ % p.length;
						f[S] = f[S] || [], f[S].push(new r.Rect({
							shape: {
								x: x,
								y: j,
								width: E,
								height: I
							},
							silent: !0
						})), g = x + E, d = j + I
					}
					for (var b = u.getAreaStyle(), v = 0; v < f.length; v++) this.group.add(r.mergePath(f[v], {
						style: o.defaults({
							fill: p[v % p.length]
						}, b),
						silent: !0
					}))
				}
			});
		h.extend({
			type: "xAxis"
		}), h.extend({
			type: "yAxis"
		})
	}, function(t, e, n) {
		var i = n(1),
			o = n(7),
			r = n(2);
		r.registerAction("dataZoom", function(t, e) {
			var n = o.createLinkedNodesFinder(i.bind(e.eachComponent, e, "dataZoom"), o.eachAxisDim, function(t, e) {
				return t.get(e.axisIndex)
			}),
				r = [];
			e.eachComponent({
				mainType: "dataZoom",
				query: t
			}, function(t, e) {
				r.push.apply(r, n(t).nodes)
			}), i.each(r, function(e, n) {
				e.setRawRange({
					start: t.start,
					end: t.end,
					startValue: t.startValue,
					endValue: t.endValue
				})
			})
		})
	}, function(t, e, n) {
		function i(t, e, n) {
			n.getAxisProxy(t.name, e).reset(n)
		}
		function o(t, e, n) {
			n.getAxisProxy(t.name, e).filterData(n)
		}
		var r = n(2);
		r.registerProcessor("filter", function(t, e) {
			t.eachComponent("dataZoom", function(t) {
				t.eachTargetAxis(i), t.eachTargetAxis(o)
			}), t.eachComponent("dataZoom", function(t) {
				var e = t.findRepresentativeAxisProxy(),
					n = e.getDataPercentWindow(),
					i = e.getDataValueWindow();
				t.setRawRange({
					start: n[0],
					end: n[1],
					startValue: i[0],
					endValue: i[1]
				})
			})
		})
	}, function(t, e, n) {
		function i(t) {
			var e = t[s];
			return e || (e = t[s] = [{}]), e
		}
		var o = n(1),
			r = o.each,
			s = "\0_ec_hist_store",
			a = {
				push: function(t, e) {
					var n = i(t);
					r(e, function(e, i) {
						for (var o = n.length - 1; o >= 0; o--) {
							var r = n[o];
							if (r[i]) break
						}
						if (0 > o) {
							var s = t.queryComponents({
								mainType: "dataZoom",
								subType: "select",
								id: i
							})[0];
							if (s) {
								var a = s.getPercentRange();
								n[0][i] = {
									dataZoomId: i,
									start: a[0],
									end: a[1]
								}
							}
						}
					}), n.push(e)
				},
				pop: function(t) {
					var e = i(t),
						n = e[e.length - 1];
					e.length > 1 && e.pop();
					var o = {};
					return r(n, function(t, n) {
						for (var i = e.length - 1; i >= 0; i--) {
							var t = e[i][n];
							if (t) {
								o[n] = t;
								break
							}
						}
					}), o
				},
				clear: function(t) {
					t[s] = null
				},
				count: function(t) {
					return i(t).length
				}
			};
		t.exports = a
	}, function(t, e, n) {
		n(10).registerSubTypeDefaulter("dataZoom", function(t) {
			return "slider"
		})
	}, function(t, e) {
		function n(t) {
			return t[i] || (t[i] = {})
		}
		var i = "\0_ec_interaction_mutex",
			o = {
				take: function(t, e) {
					n(e)[t] = !0
				},
				release: function(t, e) {
					n(e)[t] = !1
				},
				isTaken: function(t, e) {
					return !!n(e)[t]
				}
			};
		t.exports = o
	}, function(t, e, n) {
		function i(t, e, n) {
			o.positionGroup(t, e.getBoxLayoutParams(), {
				width: n.getWidth(),
				height: n.getHeight()
			}, e.get("padding"))
		}
		var o = n(11),
			r = n(9),
			s = n(3);
		t.exports = {
			layout: function(t, e, n) {
				var r = o.getLayoutRect(e.getBoxLayoutParams(), {
					width: n.getWidth(),
					height: n.getHeight()
				}, e.get("padding"));
				o.box(e.get("orient"), t, e.get("itemGap"), r.width, r.height), i(t, e, n)
			},
			addBackground: function(t, e) {
				var n = r.normalizeCssArray(e.get("padding")),
					i = t.getBoundingRect(),
					o = e.getItemStyle(["color", "opacity"]);
				o.fill = e.get("backgroundColor");
				var a = new s.Rect({
					shape: {
						x: i.x - n[3],
						y: i.y - n[0],
						width: i.width + n[1] + n[3],
						height: i.height + n[0] + n[2]
					},
					style: o,
					silent: !0,
					z2: -1
				});
				s.subPixelOptimizeRect(a), t.add(a)
			}
		}
	}, function(t, e, n) {
		function i(t, e, n) {
			var i = -1;
			do i = Math.max(s.getPrecision(t.get(e, n)), i), t = t.stackedOn;
			while (t);
			return i
		}
		function o(t, e, n, o, r, s) {
			var a = [],
				l = d(e, o, t),
				u = e.indexOfNearest(o, l, !0);
			a[r] = e.get(n, u, !0), a[s] = e.get(o, u, !0);
			var p = i(e, o, u);
			return p >= 0 && (a[s] = +a[s].toFixed(p)), a
		}
		var r = n(1),
			s = n(4),
			a = r.indexOf,
			l = r.curry,
			u = {
				min: l(o, "min"),
				max: l(o, "max"),
				average: l(o, "average")
			},
			p = function(t, e) {
				var n = t.getData(),
					i = t.coordinateSystem;
				if (e && (isNaN(parseFloat(e.x)) || isNaN(parseFloat(e.y))) && !r.isArray(e.coord) && i) {
					var o = h(e, n, i, t);
					if (e = r.clone(e), e.type && u[e.type] && o.baseAxis && o.valueAxis) {
						var s = i.dimensions,
							l = a(s, o.baseAxis.dim),
							p = a(s, o.valueAxis.dim);
						e.coord = u[e.type](n, o.baseDataDim, o.valueDataDim, l, p), e.value = e.coord[p]
					} else e.coord = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis]
				}
				return e
			},
			h = function(t, e, n, i) {
				var o = {};
				return null != t.valueIndex || null != t.valueDim ? (o.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, o.valueAxis = n.getAxis(i.dataDimToCoordDim(o.valueDataDim)), o.baseAxis = n.getOtherAxis(o.valueAxis), o.baseDataDim = i.coordDimToDataDim(o.baseAxis.dim)[0]) : (o.baseAxis = i.getBaseAxis(), o.valueAxis = n.getOtherAxis(o.baseAxis), o.baseDataDim = i.coordDimToDataDim(o.baseAxis.dim)[0], o.valueDataDim = i.coordDimToDataDim(o.valueAxis.dim)[0]), o
			},
			c = function(t, e) {
				return !(t && t.containData && e.coord) || null != e.x && null != e.y || t.containData(e.coord)
			},
			g = function(t, e, n, i) {
				return 2 > i ? t.coord && t.coord[i] : t.value
			},
			d = function(t, e, n) {
				return "average" === n ? t.getSum(e, !0) / t.count() : t.getDataExtent(e, !0)["max" === n ? 1 : 0]
			};
		t.exports = {
			dataTransform: p,
			dataFilter: c,
			dimValueGetter: g,
			getAxisInfo: h,
			numCalculate: d
		}
	}, function(t, e, n) {
		var i = n(1),
			o = n(43),
			r = n(108),
			s = function(t, e, n, i, r) {
				o.call(this, t, e, n), this.type = i || "value", this.position = r || "bottom"
			};
		s.prototype = {
			constructor: s,
			index: 0,
			onZero: !1,
			model: null,
			isHorizontal: function() {
				var t = this.position;
				return "top" === t || "bottom" === t
			},
			getGlobalExtent: function() {
				var t = this.getExtent();
				return t[0] = this.toGlobalCoord(t[0]), t[1] = this.toGlobalCoord(t[1]), t
			},
			getLabelInterval: function() {
				var t = this._labelInterval;
				return t || (t = this._labelInterval = r(this)), t
			},
			isLabelIgnored: function(t) {
				if ("category" === this.type) {
					var e = this.getLabelInterval();
					return "function" == typeof e && !e(t, this.scale.getLabel(t)) || t % (e + 1)
				}
			},
			toLocalCoord: null,
			toGlobalCoord: null
		}, i.inherits(s, o), t.exports = s
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			return this._axes[t]
		}
		var o = n(1),
			r = function(t) {
				this._axes = {}, this._dimList = [], this.name = t || ""
			};
		r.prototype = {
			constructor: r,
			type: "cartesian",
			getAxis: function(t) {
				return this._axes[t]
			},
			getAxes: function() {
				return o.map(this._dimList, i, this)
			},
			getAxesByScale: function(t) {
				return t = t.toLowerCase(), o.filter(this.getAxes(), function(e) {
					return e.scale.type === t
				})
			},
			addAxis: function(t) {
				var e = t.dim;
				this._axes[e] = t, this._dimList.push(e)
			},
			dataToCoord: function(t) {
				return this._dataCoordConvert(t, "dataToCoord")
			},
			coordToData: function(t) {
				return this._dataCoordConvert(t, "coordToData")
			},
			_dataCoordConvert: function(t, e) {
				for (var n = this._dimList, i = t instanceof Array ? [] : {}, o = 0; o < n.length; o++) {
					var r = n[o],
						s = this._axes[r];
					i[r] = s[e](t[r])
				}
				return i
			}
		}, t.exports = r
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			r.call(this, t)
		}
		var o = n(1),
			r = n(105);
		i.prototype = {
			constructor: i,
			type: "cartesian2d",
			dimensions: ["x", "y"],
			getBaseAxis: function() {
				return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
			},
			containPoint: function(t) {
				var e = this.getAxis("x"),
					n = this.getAxis("y");
				return e.contain(e.toLocalCoord(t[0])) && n.contain(n.toLocalCoord(t[1]))
			},
			containData: function(t) {
				return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1])
			},
			dataToPoints: function(t, e) {
				return t.mapArray(["x", "y"], function(t, e) {
					return this.dataToPoint([t, e])
				}, e, this)
			},
			dataToPoint: function(t, e) {
				var n = this.getAxis("x"),
					i = this.getAxis("y");
				return [n.toGlobalCoord(n.dataToCoord(t[0], e)), i.toGlobalCoord(i.dataToCoord(t[1], e))]
			},
			pointToData: function(t, e) {
				var n = this.getAxis("x"),
					i = this.getAxis("y");
				return [n.coordToData(n.toLocalCoord(t[0]), e), i.coordToData(i.toLocalCoord(t[1]), e)]
			},
			getOtherAxis: function(t) {
				return this.getAxis("x" === t.dim ? "y" : "x")
			}
		}, o.inherits(i, r), t.exports = i
	}, function(t, e, n) {
		"use strict";
		n(51);
		var i = n(10);
		t.exports = i.extend({
			type: "grid",
			dependencies: ["xAxis", "yAxis"],
			layoutMode: "box",
			coordinateSystem: null,
			defaultOption: {
				show: !1,
				zlevel: 0,
				z: 0,
				left: "10%",
				top: 60,
				right: "10%",
				bottom: 60,
				containLabel: !1,
				backgroundColor: "rgba(0,0,0,0)",
				borderWidth: 1,
				borderColor: "#ccc"
			}
		})
	}, function(t, e, n) {
		"use strict";
		var i = n(1),
			o = n(24);
		t.exports = function(t) {
			var e = t.model,
				n = e.getModel("axisLabel"),
				r = n.get("interval");
			return "category" !== t.type || "auto" !== r ? "auto" === r ? 0 : r : o.getAxisLabelInterval(i.map(t.scale.getTicks(), t.dataToCoord, t), e.getFormattedLabels(), n.getModel("textStyle").getFont(), t.isHorizontal())
		}
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			return t.get("stack") || "__ec_stack_" + t.seriesIndex
		}
		function o(t, e) {
			var n = {};
			s.each(t, function(t, e) {
				var o = t.coordinateSystem,
					r = o.getBaseAxis(),
					s = n[r.index] || {
						remainedWidth: r.getBandWidth(),
						autoWidthCount: 0,
						categoryGap: "20%",
						gap: "30%",
						axis: r,
						stacks: {}
					},
					a = s.stacks;
				n[r.index] = s;
				var l = i(t);
				a[l] || s.autoWidthCount++, a[l] = a[l] || {
					width: 0,
					maxWidth: 0
				};
				var u = t.get("barWidth"),
					p = t.get("barMaxWidth"),
					h = t.get("barGap"),
					c = t.get("barCategoryGap");
				u && !a[l].width && (u = Math.min(s.remainedWidth, u), a[l].width = u, s.remainedWidth -= u), p && (a[l].maxWidth = p), null != h && (s.gap = h), null != c && (s.categoryGap = c)
			});
			var o = {};
			return s.each(n, function(t, e) {
				o[e] = {};
				var n = t.stacks,
					i = t.axis,
					r = i.getBandWidth(),
					a = l(t.categoryGap, r),
					u = l(t.gap, 1),
					p = t.remainedWidth,
					h = t.autoWidthCount,
					c = (p - a) / (h + (h - 1) * u);
				c = Math.max(c, 0), s.each(n, function(t, e) {
					var n = t.maxWidth;
					!t.width && n && c > n && (n = Math.min(n, p), p -= n, t.width = n, h--)
				}), c = (p - a) / (h + (h - 1) * u), c = Math.max(c, 0);
				var g, d = 0;
				s.each(n, function(t, e) {
					t.width || (t.width = c), g = t, d += t.width * (1 + u)
				}), g && (d -= g.width * u);
				var f = -d / 2;
				s.each(n, function(t, n) {
					o[e][n] = o[e][n] || {
						offset: f,
						width: t.width
					}, f += t.width * (1 + u)
				})
			}), o
		}
		function r(t, e, n) {
			var r = o(s.filter(e.getSeriesByType(t), function(t) {
				return !e.isSeriesFiltered(t) && t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type
			})),
				a = {};
			e.eachSeriesByType(t, function(t) {
				var e = t.getData(),
					n = t.coordinateSystem,
					o = n.getBaseAxis(),
					s = i(t),
					l = r[o.index][s],
					u = l.offset,
					p = l.width,
					h = n.getOtherAxis(o),
					c = t.get("barMinHeight") || 0,
					g = o.onZero ? h.toGlobalCoord(h.dataToCoord(0)) : h.getGlobalExtent()[0],
					d = n.dataToPoints(e, !0);
				a[s] = a[s] || [], e.setLayout({
					offset: u,
					size: p
				}), e.each(h.dim, function(t, n) {
					if (!isNaN(t)) {
						a[s][n] || (a[s][n] = {
							p: g,
							n: g
						});
						var i, o, r, l, f = t >= 0 ? "p" : "n",
							m = d[n],
							y = a[s][n][f];
						h.isHorizontal() ? (i = y, o = m[1] + u, r = m[0] - y, l = p, Math.abs(r) < c && (r = (0 > r ? -1 : 1) * c), a[s][n][f] += r) : (i = m[0] + u, o = y, r = p, l = m[1] - y, Math.abs(l) < c && (l = (0 >= l ? -1 : 1) * c), a[s][n][f] += l), e.setItemLayout(n, {
							x: i,
							y: o,
							width: r,
							height: l
						})
					}
				}, !0)
			}, this)
		}
		var s = n(1),
			a = n(4),
			l = a.parsePercent;
		t.exports = r
	}, function(t, e, n) {
		var i = n(3),
			o = n(1),
			r = Math.PI;
		t.exports = function(t, e) {
			e = e || {}, o.defaults(e, {
				text: "loading",
				color: "#c23531",
				textColor: "#000",
				maskColor: "rgba(255, 255, 255, 0.8)",
				zlevel: 0
			});
			var n = new i.Rect({
				style: {
					fill: e.maskColor
				},
				zlevel: e.zlevel,
				z: 1e4
			}),
				s = new i.Arc({
					shape: {
						startAngle: -r / 2,
						endAngle: -r / 2 + .1,
						r: 10
					},
					style: {
						stroke: e.color,
						lineCap: "round",
						lineWidth: 5
					},
					zlevel: e.zlevel,
					z: 10001
				}),
				a = new i.Rect({
					style: {
						fill: "none",
						text: e.text,
						textPosition: "right",
						textDistance: 10,
						textFill: e.textColor
					},
					zlevel: e.zlevel,
					z: 10001
				});
			s.animateShape(!0).when(1e3, {
				endAngle: 3 * r / 2
			}).start("circularInOut"), s.animateShape(!0).when(1e3, {
				startAngle: 3 * r / 2
			}).delay(300).start("circularInOut");
			var l = new i.Group;
			return l.add(s), l.add(a), l.add(n), l.resize = function() {
				var e = t.getWidth() / 2,
					i = t.getHeight() / 2;
				s.setShape({
					cx: e,
					cy: i
				});
				var o = s.shape.r;
				a.setShape({
					x: e - o,
					y: i - o,
					width: 2 * o,
					height: 2 * o
				}), n.setShape({
					x: 0,
					y: 0,
					width: t.getWidth(),
					height: t.getHeight()
				})
			}, l.resize(), l
		}
	}, function(t, e, n) {
		function i(t, e) {
			for (var n in e) j.hasClass(n) || ("object" == typeof e[n] ? t[n] = t[n] ? h.merge(t[n], e[n], !1) : h.clone(e[n]) : null == t[n] && (t[n] = e[n]))
		}
		function o(t) {
			t = t, this.option = {}, this.option[I] = 1, this._componentsMap = {}, this._seriesIndices = null, i(t, this._theme.option), h.merge(t, E, !1), this.mergeOption(t)
		}
		function r(t, e) {
			h.isArray(e) || (e = e ? [e] : []);
			var n = {};
			return d(e, function(e) {
				n[e] = (t[e] || []).slice()
			}), n
		}
		function s(t, e) {
			var n = {};
			d(e, function(t, e) {
				var i = t.exist;
				i && (n[i.id] = t)
			}), d(e, function(e, i) {
				var o = e.option;
				if (h.assert(!o || null == o.id || !n[o.id] || n[o.id] === e, "id duplicates: " + (o && o.id)), o && null != o.id && (n[o.id] = e), x(o)) {
					var r = a(t, o, e.exist);
					e.keyInfo = {
						mainType: t,
						subType: r
					}
				}
			}), d(e, function(t, e) {
				var i = t.exist,
					o = t.option,
					r = t.keyInfo;
				if (x(o)) {
					if (r.name = null != o.name ? o.name + "" : i ? i.name : "\0-", i) r.id = i.id;
					else if (null != o.id) r.id = o.id + "";
					else {
						var s = 0;
						do r.id = "\0" + r.name + "\0" + s++;
						while (n[r.id])
					}
					n[r.id] = t
				}
			})
		}
		function a(t, e, n) {
			var i = e.type ? e.type : n ? n.subType : j.determineSubType(t, e);
			return i
		}
		function l(t) {
			return m(t, function(t) {
				return t.componentIndex
			}) || []
		}
		function u(t, e) {
			return e.hasOwnProperty("subType") ? f(t, function(t) {
				return t.subType === e.subType
			}) : t
		}
		function p(t) {
			if (!t._seriesIndices) throw new Error("Series has not been initialized yet.")
		}
		var h = n(1),
			c = n(7),
			g = n(12),
			d = h.each,
			f = h.filter,
			m = h.map,
			y = h.isArray,
			v = h.indexOf,
			x = h.isObject,
			j = n(10),
			E = n(113),
			I = "\0_ec_inner",
			C = g.extend({
				constructor: C,
				init: function(t, e, n, i) {
					n = n || {}, this.option = null, this._theme = new g(n), this._optionManager = i
				},
				setOption: function(t, e) {
					h.assert(!(I in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption()
				},
				resetOption: function(t) {
					var e = !1,
						n = this._optionManager;
					if (!t || "recreate" === t) {
						var i = n.mountOption("recreate" === t);
						this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(i)) : o.call(this, i), e = !0
					}
					if ("timeline" !== t && "media" !== t || this.restoreData(), !t || "recreate" === t || "timeline" === t) {
						var r = n.getTimelineOption(this);
						r && (this.mergeOption(r), e = !0)
					}
					if (!t || "recreate" === t || "media" === t) {
						var s = n.getMediaOption(this, this._api);
						s.length && d(s, function(t) {
							this.mergeOption(t, e = !0)
						}, this)
					}
					return e
				},
				mergeOption: function(t) {
					function e(e, o) {
						var a = c.normalizeToArray(t[e]),
							u = c.mappingToExists(i[e], a);
						s(e, u);
						var p = r(i, o);
						n[e] = [], i[e] = [], d(u, function(t, o) {
							var r = t.exist,
								s = t.option;
							if (h.assert(x(s) || r, "Empty component definition"), s) {
								var a = j.getClass(e, t.keyInfo.subType, !0);
								r && r instanceof a ? (r.mergeOption(s, this), r.optionUpdated(this)) : (r = new a(s, this, this, h.extend({
									dependentModels: p,
									componentIndex: o
								}, t.keyInfo)), r.optionUpdated(this))
							} else r.mergeOption({}, this), r.optionUpdated(this);
							i[e][o] = r, n[e][o] = r.option
						}, this), "series" === e && (this._seriesIndices = l(i.series))
					}
					var n = this.option,
						i = this._componentsMap,
						o = [];
					d(t, function(t, e) {
						null != t && (j.hasClass(e) ? o.push(e) : n[e] = null == n[e] ? h.clone(t) : h.merge(n[e], t, !0))
					}), j.topologicalTravel(o, j.getAllClassMainTypes(), e, this)
				},
				getOption: function() {
					var t = h.clone(this.option);
					return d(t, function(e, n) {
						if (j.hasClass(n)) {
							for (var e = c.normalizeToArray(e), i = e.length - 1; i >= 0; i--) c.isIdInner(e[i]) && e.splice(i, 1);
							t[n] = e
						}
					}), delete t[I], t
				},
				getTheme: function() {
					return this._theme
				},
				getComponent: function(t, e) {
					var n = this._componentsMap[t];
					return n ? n[e || 0] : void 0
				},
				queryComponents: function(t) {
					var e = t.mainType;
					if (!e) return [];
					var n = t.index,
						i = t.id,
						o = t.name,
						r = this._componentsMap[e];
					if (!r || !r.length) return [];
					var s;
					if (null != n) y(n) || (n = [n]), s = f(m(n, function(t) {
						return r[t]
					}), function(t) {
						return !!t
					});
					else if (null != i) {
						var a = y(i);
						s = f(r, function(t) {
							return a && v(i, t.id) >= 0 || !a && t.id === i
						})
					} else if (null != o) {
						var l = y(o);
						s = f(r, function(t) {
							return l && v(o, t.name) >= 0 || !l && t.name === o
						})
					}
					return u(s, t)
				},
				findComponents: function(t) {
					function e(t) {
						var e = o + "Index",
							n = o + "Id",
							i = o + "Name";
						return t && (t.hasOwnProperty(e) || t.hasOwnProperty(n) || t.hasOwnProperty(i)) ? {
							mainType: o,
							index: t[e],
							id: t[n],
							name: t[i]
						} : null
					}
					function n(e) {
						return t.filter ? f(e, t.filter) : e
					}
					var i = t.query,
						o = t.mainType,
						r = e(i),
						s = r ? this.queryComponents(r) : this._componentsMap[o];
					return n(u(s, t))
				},
				eachComponent: function(t, e, n) {
					var i = this._componentsMap;
					if ("function" == typeof t) n = e, e = t, d(i, function(t, i) {
						d(t, function(t, o) {
							e.call(n, i, t, o)
						})
					});
					else if (h.isString(t)) d(i[t], e, n);
					else if (x(t)) {
						var o = this.findComponents(t);
						d(o, e, n)
					}
				},
				getSeriesByName: function(t) {
					var e = this._componentsMap.series;
					return f(e, function(e) {
						return e.name === t
					})
				},
				getSeriesByIndex: function(t) {
					return this._componentsMap.series[t]
				},
				getSeriesByType: function(t) {
					var e = this._componentsMap.series;
					return f(e, function(e) {
						return e.subType === t
					})
				},
				getSeries: function() {
					return this._componentsMap.series.slice()
				},
				eachSeries: function(t, e) {
					p(this), d(this._seriesIndices, function(n) {
						var i = this._componentsMap.series[n];
						t.call(e, i, n)
					}, this)
				},
				eachRawSeries: function(t, e) {
					d(this._componentsMap.series, t, e)
				},
				eachSeriesByType: function(t, e, n) {
					p(this), d(this._seriesIndices, function(i) {
						var o = this._componentsMap.series[i];
						o.subType === t && e.call(n, o, i)
					}, this)
				},
				eachRawSeriesByType: function(t, e, n) {
					return d(this.getSeriesByType(t), e, n)
				},
				isSeriesFiltered: function(t) {
					return p(this), h.indexOf(this._seriesIndices, t.componentIndex) < 0
				},
				filterSeries: function(t, e) {
					p(this);
					var n = f(this._componentsMap.series, t, e);
					this._seriesIndices = l(n)
				},
				restoreData: function() {
					var t = this._componentsMap;
					this._seriesIndices = l(t.series);
					var e = [];
					d(t, function(t, n) {
						e.push(n)
					}), j.topologicalTravel(e, j.getAllClassMainTypes(), function(e, n) {
						d(t[e], function(t) {
							t.restoreData()
						})
					})
				}
			});
		t.exports = C
	}, function(t, e, n) {
		function i(t) {
			this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption
		}
		function o(t, e) {
			var n, i, o = [],
				r = [],
				s = t.timeline;
			if (t.baseOption && (i = t.baseOption), (s || t.options) && (i = i || {}, o = (t.options || []).slice()), t.media) {
				i = i || {};
				var a = t.media;
				c(a, function(t) {
					t && t.option && (t.query ? r.push(t) : n || (n = t))
				})
			}
			return i || (i = t), i.timeline || (i.timeline = s), c([i].concat(o).concat(u.map(r, function(t) {
				return t.option
			})), function(t) {
				c(e, function(e) {
					e(t)
				})
			}), {
				baseOption: i,
				timelineOptions: o,
				mediaDefault: n,
				mediaList: r
			}
		}
		function r(t, e, n) {
			var i = {
				width: e,
				height: n,
				aspectratio: e / n
			},
				o = !0;
			return u.each(t, function(t, e) {
				var n = e.match(m);
				if (n && n[1] && n[2]) {
					var r = n[1],
						a = n[2].toLowerCase();
					s(i[a], t, r) || (o = !1)
				}
			}), o
		}
		function s(t, e, n) {
			return "min" === n ? t >= e : "max" === n ? e >= t : t === e
		}
		function a(t, e) {
			return t.join(",") === e.join(",")
		}
		function l(t, e) {
			e = e || {}, c(e, function(e, n) {
				if (null != e) {
					var i = t[n];
					if (h.hasClass(n)) {
						e = p.normalizeToArray(e), i = p.normalizeToArray(i);
						var o = p.mappingToExists(i, e);
						t[n] = d(o, function(t) {
							return t.option && t.exist ? f(t.exist, t.option, !0) : t.exist || t.option
						})
					} else t[n] = f(i, e, !0)
				}
			})
		}
		var u = n(1),
			p = n(7),
			h = n(10),
			c = u.each,
			g = u.clone,
			d = u.map,
			f = u.merge,
			m = /^(min|max)?(.+)$/;
		i.prototype = {
			constructor: i,
			setOption: function(t, e) {
				t = g(t, !0);
				var n = this._optionBackup,
					i = o.call(this, t, e);
				this._newBaseOption = i.baseOption, n ? (l(n.baseOption, i.baseOption), i.timelineOptions.length && (n.timelineOptions = i.timelineOptions), i.mediaList.length && (n.mediaList = i.mediaList), i.mediaDefault && (n.mediaDefault = i.mediaDefault)) : this._optionBackup = i
			},
			mountOption: function(t) {
				var e = this._optionBackup;
				return this._timelineOptions = d(e.timelineOptions, g), this._mediaList = d(e.mediaList, g), this._mediaDefault = g(e.mediaDefault), this._currentMediaIndices = [], g(t ? e.baseOption : this._newBaseOption)
			},
			getTimelineOption: function(t) {
				var e, n = this._timelineOptions;
				if (n.length) {
					var i = t.getComponent("timeline");
					i && (e = g(n[i.getCurrentIndex()], !0))
				}
				return e
			},
			getMediaOption: function(t) {
				var e = this._api.getWidth(),
					n = this._api.getHeight(),
					i = this._mediaList,
					o = this._mediaDefault,
					s = [],
					l = [];
				if (!i.length && !o) return l;
				for (var u = 0, p = i.length; p > u; u++) r(i[u].query, e, n) && s.push(u);
				return !s.length && o && (s = [-1]), s.length && !a(s, this._currentMediaIndices) && (l = d(s, function(t) {
					return g(-1 === t ? o.option : i[t].option)
				})), this._currentMediaIndices = s, l
			}
		}, t.exports = i
	}, function(t, e) {
		var n = "";
		"undefined" != typeof navigator && (n = navigator.platform || ""), t.exports = {
			color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
			grid: {},
			textStyle: {
				fontFamily: n.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
				fontSize: 12,
				fontStyle: "normal",
				fontWeight: "normal"
			},
			animation: !0,
			animationThreshold: 2e3,
			animationDuration: 1e3,
			animationDurationUpdate: 300,
			animationEasing: "exponentialOut",
			animationEasingUpdate: "cubicOut"
		}
	}, function(t, e, n) {
		t.exports = {
			getAreaStyle: n(30)([
				["fill", "color"],
				["shadowBlur"],
				["shadowOffsetX"],
				["shadowOffsetY"],
				["opacity"],
				["shadowColor"]
			])
		}
	}, function(t, e) {
		t.exports = {
			getBoxLayoutParams: function() {
				return {
					left: this.get("left"),
					top: this.get("top"),
					right: this.get("right"),
					bottom: this.get("bottom"),
					width: this.get("width"),
					height: this.get("height")
				}
			}
		}
	}, function(t, e, n) {
		t.exports = {
			getItemStyle: n(30)([
				["fill", "color"],
				["stroke", "borderColor"],
				["lineWidth", "borderWidth"],
				["opacity"],
				["shadowBlur"],
				["shadowOffsetX"],
				["shadowOffsetY"],
				["shadowColor"]
			])
		}
	}, function(t, e, n) {
		var i = n(30)([
			["lineWidth", "width"],
			["stroke", "color"],
			["opacity"],
			["shadowBlur"],
			["shadowOffsetX"],
			["shadowOffsetY"],
			["shadowColor"]
		]);
		t.exports = {
			getLineStyle: function(t) {
				var e = i.call(this, t),
					n = this.getLineDash();
				return n && (e.lineDash = n), e
			},
			getLineDash: function() {
				var t = this.get("type");
				return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
			}
		}
	}, function(t, e, n) {
		function i(t, e) {
			return t && t.getShallow(e)
		}
		var o = n(18);
		t.exports = {
			getTextColor: function() {
				var t = this.ecModel;
				return this.getShallow("color") || t && t.get("textStyle.color")
			},
			getFont: function() {
				var t = this.ecModel,
					e = t && t.getModel("textStyle");
				return [this.getShallow("fontStyle") || i(e, "fontStyle"), this.getShallow("fontWeight") || i(e, "fontWeight"), (this.getShallow("fontSize") || i(e, "fontSize") || 12) + "px", this.getShallow("fontFamily") || i(e, "fontFamily") || "sans-serif"].join(" ")
			},
			getTextRect: function(t) {
				var e = this.get("textStyle") || {};
				return o.getBoundingRect(t, this.getFont(), e.align, e.baseline)
			},
			ellipsis: function(t, e, n) {
				return o.ellipsis(t, this.getFont(), e, n)
			}
		}
	}, function(t, e, n) {
		function i(t, e) {
			e = e.split(",");
			for (var n = t, i = 0; i < e.length && (n = n && n[e[i]], null != n); i++);
			return n
		}
		function o(t, e, n, i) {
			e = e.split(",");
			for (var o, r = t, s = 0; s < e.length - 1; s++) o = e[s], null == r[o] && (r[o] = {}), r = r[o];
			(i || null == r[e[s]]) && (r[e[s]] = n)
		}
		function r(t) {
			h(l, function(e) {
				e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]])
			})
		}
		var s = n(1),
			a = n(120),
			l = [
				["x", "left"],
				["y", "top"],
				["x2", "right"],
				["y2", "bottom"]
			],
			u = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
			p = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"],
			h = s.each;
		t.exports = function(t) {
			h(t.series, function(t) {
				if (s.isObject(t)) {
					var e = t.type;
					if (a(t), "pie" !== e && "gauge" !== e || null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === e) {
						var n = i(t, "pointer.color");
						null != n && o(t, "itemStyle.normal.color", n)
					}
					for (var l = 0; l < p.length; l++) if (p[l] === t.type) {
						r(t);
						break
					}
				}
			}), t.dataRange && (t.visualMap = t.dataRange), h(u, function(e) {
				var n = t[e];
				n && (s.isArray(n) || (n = [n]), h(n, function(t) {
					r(t)
				}))
			})
		}
	}, function(t, e, n) {
		function i(t) {
			var e = t && t.itemStyle;
			e && o.each(r, function(n) {
				var i = e.normal,
					r = e.emphasis;
				i && i[n] && (t[n] = t[n] || {}, t[n].normal ? o.merge(t[n].normal, i[n]) : t[n].normal = i[n], i[n] = null), r && r[n] && (t[n] = t[n] || {}, t[n].emphasis ? o.merge(t[n].emphasis, r[n]) : t[n].emphasis = r[n], r[n] = null)
			})
		}
		var o = n(1),
			r = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
		t.exports = function(t) {
			if (t) {
				i(t), i(t.markPoint), i(t.markLine);
				var e = t.data;
				if (e) {
					for (var n = 0; n < e.length; n++) i(e[n]);
					var r = t.markPoint;
					if (r && r.data) for (var s = r.data, n = 0; n < s.length; n++) i(s[n]);
					var a = t.markLine;
					if (a && a.data) for (var l = a.data, n = 0; n < l.length; n++) o.isArray(l[n]) ? (i(l[n][0]), i(l[n][1])) : i(l[n])
				}
			}
		}
	}, function(t, e) {
		var n = {
			average: function(t) {
				for (var e = 0, n = 0, i = 0; i < t.length; i++) isNaN(t[i]) || (e += t[i], n++);
				return 0 === n ? NaN : e / n
			},
			sum: function(t) {
				for (var e = 0, n = 0; n < t.length; n++) e += t[n] || 0;
				return e
			},
			max: function(t) {
				for (var e = -(1 / 0), n = 0; n < t.length; n++) t[n] > e && (e = t[n]);
				return e
			},
			min: function(t) {
				for (var e = 1 / 0, n = 0; n < t.length; n++) t[n] < e && (e = t[n]);
				return e
			},
			nearest: function(t) {
				return t[0]
			}
		},
			i = function(t, e) {
				return Math.round(t.length / 2)
			};
		t.exports = function(t, e, o) {
			e.eachSeriesByType(t, function(t) {
				var e = t.getData(),
					o = t.get("sampling"),
					r = t.coordinateSystem;
				if ("cartesian2d" === r.type && o) {
					var s = r.getBaseAxis(),
						a = r.getOtherAxis(s),
						l = s.getExtent(),
						u = l[1] - l[0],
						p = Math.round(e.count() / u);
					if (p > 1) {
						var h;
						"string" == typeof o ? h = n[o] : "function" == typeof o && (h = o), h && (e = e.downSample(a.dim, 1 / p, h, i), t.setData(e))
					}
				}
			}, this)
		}
	}, function(t, e, n) {
		var i = n(1),
			o = n(32),
			r = n(4),
			s = n(38),
			a = o.prototype,
			l = s.prototype,
			u = Math.floor,
			p = Math.ceil,
			h = Math.pow,
			c = 10,
			g = Math.log,
			d = o.extend({
				type: "log",
				getTicks: function() {
					return i.map(l.getTicks.call(this), function(t) {
						return r.round(h(c, t))
					})
				},
				getLabel: l.getLabel,
				scale: function(t) {
					return t = a.scale.call(this, t), h(c, t)
				},
				setExtent: function(t, e) {
					t = g(t) / g(c), e = g(e) / g(c), l.setExtent.call(this, t, e)
				},
				getExtent: function() {
					var t = a.getExtent.call(this);
					return t[0] = h(c, t[0]), t[1] = h(c, t[1]), t
				},
				unionExtent: function(t) {
					t[0] = g(t[0]) / g(c), t[1] = g(t[1]) / g(c), a.unionExtent.call(this, t)
				},
				niceTicks: function(t) {
					t = t || 10;
					var e = this._extent,
						n = e[1] - e[0];
					if (!(n === 1 / 0 || 0 >= n)) {
						var i = h(10, u(g(n / t) / Math.LN10)),
							o = t / n * i;.5 >= o && (i *= 10);
						var s = [r.round(p(e[0] / i) * i), r.round(u(e[1] / i) * i)];
						this._interval = i, this._niceExtent = s
					}
				},
				niceExtent: l.niceExtent
			});
		i.each(["contain", "normalize"], function(t) {
			d.prototype[t] = function(e) {
				return e = g(e) / g(c), a[t].call(this, e)
			}
		}), d.create = function() {
			return new d
		}, t.exports = d
	}, function(t, e, n) {
		var i = n(1),
			o = n(32),
			r = o.prototype,
			s = o.extend({
				type: "ordinal",
				init: function(t, e) {
					this._data = t, this._extent = e || [0, t.length - 1]
				},
				parse: function(t) {
					return "string" == typeof t ? i.indexOf(this._data, t) : Math.round(t)
				},
				contain: function(t) {
					return t = this.parse(t), r.contain.call(this, t) && null != this._data[t]
				},
				normalize: function(t) {
					return r.normalize.call(this, this.parse(t))
				},
				scale: function(t) {
					return Math.round(r.scale.call(this, t))
				},
				getTicks: function() {
					for (var t = [], e = this._extent, n = e[0]; n <= e[1];) t.push(n), n++;
					return t
				},
				getLabel: function(t) {
					return this._data[t]
				},
				count: function() {
					return this._extent[1] - this._extent[0] + 1
				},
				niceTicks: i.noop,
				niceExtent: i.noop
			});
		s.create = function() {
			return new s
		}, t.exports = s
	}, function(t, e, n) {
		var i = n(1),
			o = n(4),
			r = n(9),
			s = n(38),
			a = s.prototype,
			l = Math.ceil,
			u = Math.floor,
			p = 1e3,
			h = 60 * p,
			c = 60 * h,
			g = 24 * c,
			d = function(t, e, n, i) {
				for (; i > n;) {
					var o = n + i >>> 1;
					t[o][2] < e ? n = o + 1 : i = o
				}
				return n
			},
			f = s.extend({
				type: "time",
				getLabel: function(t) {
					var e = this._stepLvl,
						n = new Date(t);
					return r.formatTime(e[0], n)
				},
				niceExtent: function(t, e, n) {
					var i = this._extent;
					if (i[0] === i[1] && (i[0] -= g, i[1] += g), i[1] === -(1 / 0) && i[0] === 1 / 0) {
						var r = new Date;
						i[1] = new Date(r.getFullYear(), r.getMonth(), r.getDate()), i[0] = i[1] - g
					}
					this.niceTicks(t);
					var s = this._interval;
					e || (i[0] = o.round(u(i[0] / s) * s)), n || (i[1] = o.round(l(i[1] / s) * s))
				},
				niceTicks: function(t) {
					t = t || 10;
					var e = this._extent,
						n = e[1] - e[0],
						i = n / t,
						r = m.length,
						s = d(m, i, 0, r),
						a = m[Math.min(s, r - 1)],
						p = a[2];
					if ("year" === a[0]) {
						var h = n / p,
							c = o.nice(h / t, !0);
						p *= c
					}
					var g = [l(e[0] / p) * p, u(e[1] / p) * p];
					this._stepLvl = a, this._interval = p, this._niceExtent = g
				},
				parse: function(t) {
					return +o.parseDate(t)
				}
			});
		i.each(["contain", "normalize"], function(t) {
			f.prototype[t] = function(e) {
				return a[t].call(this, this.parse(e))
			}
		});
		var m = [
			["hh:mm:ss", 1, p],
			["hh:mm:ss", 5, 5 * p],
			["hh:mm:ss", 10, 10 * p],
			["hh:mm:ss", 15, 15 * p],
			["hh:mm:ss", 30, 30 * p],
			["hh:mm\nMM-dd", 1, h],
			["hh:mm\nMM-dd", 5, 5 * h],
			["hh:mm\nMM-dd", 10, 10 * h],
			["hh:mm\nMM-dd", 15, 15 * h],
			["hh:mm\nMM-dd", 30, 30 * h],
			["hh:mm\nMM-dd", 1, c],
			["hh:mm\nMM-dd", 2, 2 * c],
			["hh:mm\nMM-dd", 6, 6 * c],
			["hh:mm\nMM-dd", 12, 12 * c],
			["MM-dd\nyyyy", 1, g],
			["week", 7, 7 * g],
			["month", 1, 31 * g],
			["quarter", 3, 380 * g / 4],
			["half-year", 6, 380 * g / 2],
			["year", 1, 380 * g]
		];
		f.create = function() {
			return new f
		}, t.exports = f
	}, function(t, e) {
		var n = {},
			i = "\0__throttleOriginMethod",
			o = "\0__throttleRate";
		n.throttle = function(t, e, n, i) {
			function o(o) {
				function g() {
					p = (new Date).getTime(), h = null, (c ? t : t[o]).apply(s, a || [])
				}
				var d = function() {
						l = (new Date).getTime(), s = this, a = arguments, r = l - (i ? u : p) - e, clearTimeout(h), i ? n ? h = setTimeout(g, e) : r >= 0 && g() : r >= 0 ? g() : n && (h = setTimeout(g, -r)), u = l
					};
				return d.clear = function() {
					h && (clearTimeout(h), h = null)
				}, d
			}
			var r, s, a, l = (new Date).getTime(),
				u = 0,
				p = 0,
				h = null,
				c = "function" == typeof t;
			if (e = e || 0, c) return o();
			for (var g = [], d = 0; d < t.length; d++) g[d] = o(d);
			return g
		}, n.fixRate = function(t, e) {
			return null != e ? n.throttle(t, e, !0, !1) : t
		}, n.debounce = function(t, e) {
			return null != e ? n.throttle(t, e, !0, !0) : t
		}, n.createOrUpdate = function(t, e, r, s) {
			var a = t[e];
			if (a && null != r && s) {
				var l = a[i] || a,
					u = a[o];
				u !== r && (a = t[e] = n[s](l, r), a[i] = l, a[o] = r)
			}
		}, n.clear = function(t, e) {
			var n = t[e];
			n && n[i] && (t[e] = n[i])
		}, t.exports = n
	}, function(t, e, n) {
		"use strict";

		function i(t, e, n) {
			return {
				type: t,
				event: n,
				target: e,
				cancelBubble: !1,
				offsetX: n.zrX,
				offsetY: n.zrY,
				gestureEvent: n.gestureEvent,
				pinchX: n.pinchX,
				pinchY: n.pinchY,
				pinchScale: n.pinchScale,
				wheelDelta: n.zrDelta
			}
		}
		function o(t, e, n) {
			var i = t._gestureMgr;
			"start" === n && i.clear();
			var o = i.recognize(e, t.findHover(e.zrX, e.zrY, null));
			if ("end" === n && i.clear(), o) {
				var r = o.type;
				e.gestureEvent = r, t._dispatchProxy(o.target, r, o.event)
			}
		}
		function r(t) {
			function e(t, e) {
				return function() {
					return e._touching ? void 0 : t.apply(e, arguments)
				}
			}
			for (var n = v.concat(x), i = 0; i < n.length; i++) {
				var o = n[i];
				t._handlers[o] = g.bind(S[o], t)
			}
			for (var i = 0; i < y.length; i++) {
				var o = y[i];
				t._handlers[o] = e(S[o], t)
			}
		}
		function s(t, e, n) {
			if (t[t.rectHover ? "rectContain" : "contain"](e, n)) {
				for (var i = t; i;) {
					if (i.silent || i.clipPath && !i.clipPath.contain(e, n)) return !1;
					i = i.parent
				}
				return !0
			}
			return !1
		}
		function a(t) {
			t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function() {
				t._touching = !1
			}, 700)
		}
		function l() {
			return !1
		}
		function u() {
			return h.touchEventsSupported
		}
		function p(t) {
			return "mousewheel" === t && h.browser.firefox ? "DOMMouseScroll" : t
		}
		var h = n(14),
			c = n(34),
			g = n(1),
			d = n(155),
			f = n(138),
			m = n(21),
			y = ["click", "dblclick", "mousewheel", "mouseout"];
		!l() && y.push("mouseup", "mousedown", "mousemove");
		var v = ["touchstart", "touchend", "touchmove"],
			x = ["pointerdown", "pointerup", "pointermove"],
			j = 300,
			E = c.addEventListener,
			I = c.removeEventListener,
			C = c.normalizeEvent,
			S = {
				mousemove: function(t) {
					t = C(this.root, t);
					var e = t.zrX,
						n = t.zrY,
						i = this.findHover(e, n, null),
						o = this._hovered;
					this._hovered = i, this.root.style.cursor = i ? i.cursor : this._defaultCursorStyle, o && i !== o && o.__zr && this._dispatchProxy(o, "mouseout", t), this._dispatchProxy(i, "mousemove", t), i && i !== o && this._dispatchProxy(i, "mouseover", t)
				},
				mouseout: function(t) {
					t = C(this.root, t);
					var e = t.toElement || t.relatedTarget;
					if (e != this.root) for (; e && 9 != e.nodeType;) {
						if (e === this.root) return;
						e = e.parentNode
					}
					this._dispatchProxy(this._hovered, "mouseout", t), this.trigger("globalout", {
						event: t
					})
				},
				touchstart: function(t) {
					t = C(this.root, t), this._lastTouchMoment = new Date, o(this, t, "start"), S.mousemove.call(this, t), S.mousedown.call(this, t), a(this)
				},
				touchmove: function(t) {
					t = C(this.root, t), o(this, t, "change"), S.mousemove.call(this, t), a(this)
				},
				touchend: function(t) {
					t = C(this.root, t), o(this, t, "end"), S.mouseup.call(this, t), +new Date - this._lastTouchMoment < j && S.click.call(this, t), a(this)
				}
			};
		g.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick"], function(t) {
			S[t] = function(e) {
				e = C(this.root, e);
				var n = this.findHover(e.zrX, e.zrY, null);
				if ("mousedown" === t) this._downel = n, this._upel = n;
				else if ("mosueup" === t) this._upel = n;
				else if ("click" === t && this._downel !== this._upel) return;
				this._dispatchProxy(n, t, e)
			}
		});
		var b = function(t, e, n) {
				function i(e, n) {
					g.each(e, function(e) {
						E(t, p(e), n._handlers[e])
					}, n)
				}
				m.call(this), this.root = t, this.storage = e, this.painter = n, this._hovered, this._lastTouchMoment, this._lastX, this._lastY, this._defaultCursorStyle = "default", this._gestureMgr = new f, this._handlers = [], this._touching = !1, this._touchTimer, r(this), l() ? i(x, this) : u() && i(v, this), i(y, this), d.call(this)
			};
		b.prototype = {
			constructor: b,
			resize: function(t) {
				this._hovered = null
			},
			dispatch: function(t, e) {
				var n = this._handlers[t];
				n && n.call(this, e)
			},
			dispose: function() {
				for (var t = this.root, e = y.concat(v), n = 0; n < e.length; n++) {
					var i = e[n];
					I(t, p(i), this._handlers[i])
				}
				this.root = this.storage = this.painter = null
			},
			setDefaultCursorStyle: function(t) {
				this._defaultCursorStyle = t
			},
			_dispatchProxy: function(t, e, n) {
				for (var o = "on" + e, r = i(e, t, n), s = t; s && (s[o] && (r.cancelBubble = s[o].call(s, r)), s.trigger(e, r), s = s.parent, !r.cancelBubble););
				r.cancelBubble || (this.trigger(e, r), this.painter && this.painter.eachOtherLayer(function(t) {
					"function" == typeof t[o] && t[o].call(t, r), t.trigger && t.trigger(e, r)
				}))
			},
			findHover: function(t, e, n) {
				for (var i = this.storage.getDisplayList(), o = i.length - 1; o >= 0; o--) if (!i[o].silent && i[o] !== n && !i[o].ignore && s(i[o], t, e)) return i[o]
			}
		}, g.mixin(b, m), g.mixin(b, d), t.exports = b
	}, function(t, e, n) {
		function i() {
			return !1
		}
		function o(t, e, n, i) {
			var o = document.createElement(e),
				r = n.getWidth(),
				s = n.getHeight(),
				a = o.style;
			return a.position = "absolute", a.left = 0, a.top = 0, a.width = r + "px", a.height = s + "px", o.width = r * i, o.height = s * i, o.setAttribute("data-zr-dom-id", t), o
		}
		var r = n(1),
			s = n(33),
			a = function(t, e, n) {
				var a;
				n = n || s.devicePixelRatio, "string" == typeof t ? a = o(t, "canvas", e, n) : r.isObject(t) && (a = t, t = a.id), this.id = t, this.dom = a;
				var l = a.style;
				l && (a.onselectstart = i, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)"), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = n
			};
		a.prototype = {
			constructor: a,
			elCount: 0,
			__dirty: !0,
			initContext: function() {
				this.ctx = this.dom.getContext("2d");
				var t = this.dpr;
				1 != t && this.ctx.scale(t, t)
			},
			createBackBuffer: function() {
				var t = this.dpr;
				this.domBack = o("back-" + this.id, "canvas", this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 != t && this.ctxBack.scale(t, t)
			},
			resize: function(t, e) {
				var n = this.dpr,
					i = this.dom,
					o = i.style,
					r = this.domBack;
				o.width = t + "px", o.height = e + "px", i.width = t * n, i.height = e * n, 1 != n && this.ctx.scale(n, n), r && (r.width = t * n, r.height = e * n, 1 != n && this.ctxBack.scale(n, n))
			},
			clear: function(t) {
				var e = this.dom,
					n = this.ctx,
					i = e.width,
					o = e.height,
					r = this.clearColor,
					s = this.motionBlur && !t,
					a = this.lastFrameAlpha,
					l = this.dpr;
				if (s && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, i / l, o / l)), n.clearRect(0, 0, i / l, o / l), r && (n.save(), n.fillStyle = this.clearColor, n.fillRect(0, 0, i / l, o / l), n.restore()), s) {
					var u = this.domBack;
					n.save(), n.globalAlpha = a, n.drawImage(u, 0, 0, i / l, o / l), n.restore()
				}
			}
		}, t.exports = a
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			return parseInt(t, 10)
		}
		function o(t) {
			return !!t && ( !! t.isBuildin || "function" == typeof t.resize && "function" == typeof t.refresh)
		}
		function r(t) {
			t.__unusedCount++
		}
		function s(t) {
			t.__dirty = !1, 1 == t.__unusedCount && t.clear()
		}
		function a(t, e, n) {
			return f.copy(t.getBoundingRect()), t.transform && f.applyTransform(t.transform), m.width = e, m.height = n, !f.intersect(m)
		}
		function l(t, e) {
			if (!t || !e || t.length !== e.length) return !0;
			for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !0
		}
		function u(t, e) {
			for (var n = 0; n < t.length; n++) {
				var i, o = t[n];
				o.transform && (i = o.transform, e.transform(i[0], i[1], i[2], i[3], i[4], i[5]));
				var r = o.path;
				r.beginPath(e), o.buildPath(r, o.shape), e.clip(), o.transform && (i = o.invTransform, e.transform(i[0], i[1], i[2], i[3], i[4], i[5]))
			}
		}
		var p = n(33),
			h = n(1),
			c = n(45),
			g = n(8),
			d = n(127),
			f = new g(0, 0, 0, 0),
			m = new g(0, 0, 0, 0),
			y = function(t, e, n) {
				var i = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
				n = n || {}, this.dpr = n.devicePixelRatio || p.devicePixelRatio, this._singleCanvas = i, this.root = t;
				var o = t.style;
				if (o && (o["-webkit-tap-highlight-color"] = "transparent", o["-webkit-user-select"] = "none", o["user-select"] = "none", o["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e, i) {
					var r = t.width,
						s = t.height;
					this._width = r, this._height = s;
					var a = new d(t, this, 1);
					a.initContext(), this._layers = {
						0: a
					}, this._zlevelList = [0]
				} else {
					var r = this._getWidth(),
						s = this._getHeight();
					this._width = r, this._height = s;
					var l = document.createElement("div");
					this._domRoot = l;
					var u = l.style;
					u.position = "relative", u.overflow = "hidden", u.width = this._width + "px", u.height = this._height + "px", t.appendChild(l), this._layers = {}, this._zlevelList = []
				}
				this._layerConfig = {}, this.pathToImage = this._createPathToImage()
			};
		y.prototype = {
			constructor: y,
			isSingleCanvas: function() {
				return this._singleCanvas
			},
			getViewportRoot: function() {
				return this._singleCanvas ? this._layers[0].dom : this._domRoot
			},
			refresh: function(t) {
				var e = this.storage.getDisplayList(!0),
					n = this._zlevelList;
				this._paintList(e, t);
				for (var i = 0; i < n.length; i++) {
					var o = n[i],
						r = this._layers[o];
					!r.isBuildin && r.refresh && r.refresh()
				}
				return this
			},
			_paintList: function(t, e) {
				null == e && (e = !1), this._updateLayerStatus(t);
				var n, i, o, p = this._width,
					h = this._height;
				this.eachBuildinLayer(r);
				for (var g = null, d = 0, f = t.length; f > d; d++) {
					var m = t[d],
						y = this._singleCanvas ? 0 : m.zlevel;
					if (i !== y && (i = y, n = this.getLayer(i), n.isBuildin || c("ZLevel " + i + " has been used by unkown layer " + n.id), o = n.ctx, n.__unusedCount = 0, (n.__dirty || e) && n.clear()), (n.__dirty || e) && !m.invisible && 0 !== m.style.opacity && m.scale[0] && m.scale[1] && (!m.culling || !a(m, p, h))) {
						var v = m.__clipPaths;
						l(v, g) && (g && o.restore(), v && (o.save(), u(v, o)), g = v), m.beforeBrush && m.beforeBrush(o), m.brush(o, !1), m.afterBrush && m.afterBrush(o)
					}
					m.__dirty = !1
				}
				g && o.restore(), this.eachBuildinLayer(s)
			},
			getLayer: function(t) {
				if (this._singleCanvas) return this._layers[0];
				var e = this._layers[t];
				return e || (e = new d("zr_" + t, this, this.dpr), e.isBuildin = !0, this._layerConfig[t] && h.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e
			},
			insertLayer: function(t, e) {
				var n = this._layers,
					i = this._zlevelList,
					r = i.length,
					s = null,
					a = -1,
					l = this._domRoot;
				if (n[t]) return void c("ZLevel " + t + " has been used already");
				if (!o(e)) return void c("Layer of zlevel " + t + " is not valid");
				if (r > 0 && t > i[0]) {
					for (a = 0; r - 1 > a && !(i[a] < t && i[a + 1] > t); a++);
					s = n[i[a]]
				}
				if (i.splice(a + 1, 0, t), s) {
					var u = s.dom;
					u.nextSibling ? l.insertBefore(e.dom, u.nextSibling) : l.appendChild(e.dom)
				} else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
				n[t] = e
			},
			eachLayer: function(t, e) {
				var n, i, o = this._zlevelList;
				for (i = 0; i < o.length; i++) n = o[i], t.call(e, this._layers[n], n)
			},
			eachBuildinLayer: function(t, e) {
				var n, i, o, r = this._zlevelList;
				for (o = 0; o < r.length; o++) i = r[o], n = this._layers[i], n.isBuildin && t.call(e, n, i)
			},
			eachOtherLayer: function(t, e) {
				var n, i, o, r = this._zlevelList;
				for (o = 0; o < r.length; o++) i = r[o], n = this._layers[i], n.isBuildin || t.call(e, n, i)
			},
			getLayers: function() {
				return this._layers
			},
			_updateLayerStatus: function(t) {
				var e = this._layers,
					n = {};
				this.eachBuildinLayer(function(t, e) {
					n[e] = t.elCount, t.elCount = 0
				});
				for (var i = 0, o = t.length; o > i; i++) {
					var r = t[i],
						s = this._singleCanvas ? 0 : r.zlevel,
						a = e[s];
					if (a) {
						if (a.elCount++, a.__dirty) continue;
						a.__dirty = r.__dirty
					}
				}
				this.eachBuildinLayer(function(t, e) {
					n[e] !== t.elCount && (t.__dirty = !0)
				})
			},
			clear: function() {
				return this.eachBuildinLayer(this._clearLayer), this
			},
			_clearLayer: function(t) {
				t.clear()
			},
			configLayer: function(t, e) {
				if (e) {
					var n = this._layerConfig;
					n[t] ? h.merge(n[t], e, !0) : n[t] = e;
					var i = this._layers[t];
					i && h.merge(i, n[t], !0)
				}
			},
			delLayer: function(t) {
				var e = this._layers,
					n = this._zlevelList,
					i = e[t];
				i && (i.dom.parentNode.removeChild(i.dom), delete e[t], n.splice(h.indexOf(n, t), 1))
			},
			resize: function(t, e) {
				var n = this._domRoot;
				if (n.style.display = "none", t = t || this._getWidth(), e = e || this._getHeight(), n.style.display = "", this._width != t || e != this._height) {
					n.style.width = t + "px", n.style.height = e + "px";
					for (var i in this._layers) this._layers[i].resize(t, e);
					this.refresh(!0)
				}
				return this._width = t, this._height = e, this
			},
			clearLayer: function(t) {
				var e = this._layers[t];
				e && e.clear()
			},
			dispose: function() {
				this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
			},
			getRenderedCanvas: function(t) {
				if (t = t || {}, this._singleCanvas) return this._layers[0].dom;
				var e = new d("image", this, t.pixelRatio || this.dpr);
				e.initContext();
				var n = e.ctx;
				e.clearColor = t.backgroundColor, e.clear();
				for (var i = this.storage.getDisplayList(!0), o = 0; o < i.length; o++) {
					var r = i[o];
					r.invisible || (r.beforeBrush && r.beforeBrush(n), r.brush(n, !1), r.afterBrush && r.afterBrush(n))
				}
				return e.dom
			},
			getWidth: function() {
				return this._width
			},
			getHeight: function() {
				return this._height
			},
			_getWidth: function() {
				var t = this.root,
					e = document.defaultView.getComputedStyle(t);
				return (t.clientWidth || i(e.width) || i(t.style.width)) - (i(e.paddingLeft) || 0) - (i(e.paddingRight) || 0) | 0
			},
			_getHeight: function() {
				var t = this.root,
					e = document.defaultView.getComputedStyle(t);
				return (t.clientHeight || i(e.height) || i(t.style.height)) - (i(e.paddingTop) || 0) - (i(e.paddingBottom) || 0) | 0
			},
			_pathToImage: function(t, e, i, o, r) {
				var s = document.createElement("canvas"),
					a = s.getContext("2d");
				s.width = i * r, s.height = o * r, a.clearRect(0, 0, i * r, o * r);
				var l = {
					position: e.position,
					rotation: e.rotation,
					scale: e.scale
				};
				e.position = [0, 0, 0], e.rotation = 0, e.scale = [1, 1], e && e.brush(a);
				var u = n(46),
					p = new u({
						id: t,
						style: {
							x: 0,
							y: 0,
							image: s
						}
					});
				return null != l.position && (p.position = e.position = l.position), null != l.rotation && (p.rotation = e.rotation = l.rotation), null != l.scale && (p.scale = e.scale = l.scale), p
			},
			_createPathToImage: function() {
				var t = this;
				return function(e, n, i, o) {
					return t._pathToImage(e, n, i, o, t.dpr)
				}
			}
		}, t.exports = y
	}, function(t, e, n) {
		"use strict";

		function i(t, e) {
			return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 === e.z2 ? t.__renderidx - e.__renderidx : t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel
		}
		var o = n(1),
			r = n(27),
			s = function() {
				this._elements = {}, this._roots = [], this._displayList = [], this._displayListLen = 0
			};
		s.prototype = {
			constructor: s,
			getDisplayList: function(t, e) {
				return e = e || !1, t && this.updateDisplayList(e), this._displayList
			},
			updateDisplayList: function(t) {
				this._displayListLen = 0;
				for (var e = this._roots, n = this._displayList, o = 0, r = e.length; r > o; o++) this._updateAndAddDisplayable(e[o], null, t);
				n.length = this._displayListLen;
				for (var o = 0, r = n.length; r > o; o++) n[o].__renderidx = o;
				n.sort(i)
			},
			_updateAndAddDisplayable: function(t, e, n) {
				if (!t.ignore || n) {
					t.beforeUpdate(), t.update(), t.afterUpdate();
					var i = t.clipPath;
					if (i && (i.parent = t, i.updateTransform(), e ? (e = e.slice(), e.push(i)) : e = [i]), "group" == t.type) {
						for (var o = t._children, r = 0; r < o.length; r++) {
							var s = o[r];
							s.__dirty = t.__dirty || s.__dirty, this._updateAndAddDisplayable(s, e, n)
						}
						t.__dirty = !1
					} else t.__clipPaths = e, this._displayList[this._displayListLen++] = t
				}
			},
			addRoot: function(t) {
				this._elements[t.id] || (t instanceof r && t.addChildrenToStorage(this), this.addToMap(t), this._roots.push(t))
			},
			delRoot: function(t) {
				if (null == t) {
					for (var e = 0; e < this._roots.length; e++) {
						var n = this._roots[e];
						n instanceof r && n.delChildrenFromStorage(this)
					}
					return this._elements = {}, this._roots = [], this._displayList = [], void(this._displayListLen = 0)
				}
				if (t instanceof Array) for (var e = 0, i = t.length; i > e; e++) this.delRoot(t[e]);
				else {
					var s;
					s = "string" == typeof t ? this._elements[t] : t;
					var a = o.indexOf(this._roots, s);
					a >= 0 && (this.delFromMap(s.id), this._roots.splice(a, 1), s instanceof r && s.delChildrenFromStorage(this))
				}
			},
			addToMap: function(t) {
				return t instanceof r && (t.__storage = this), t.dirty(), this._elements[t.id] = t, this
			},
			get: function(t) {
				return this._elements[t]
			},
			delFromMap: function(t) {
				var e = this._elements,
					n = e[t];
				return n && (delete e[t], n instanceof r && (n.__storage = null)), this
			},
			dispose: function() {
				this._elements = this._renderList = this._roots = null
			}
		}, t.exports = s
	}, function(t, e, n) {
		"use strict";
		var i = n(1),
			o = n(34).Dispatcher,
			r = "undefined" != typeof window && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) ||
		function(t) {
			setTimeout(t, 16)
		}, s = n(56), a = function(t) {
			t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe ||
			function() {}, this._clips = [], this._running = !1, this._time = 0, o.call(this)
		};
		a.prototype = {
			constructor: a,
			addClip: function(t) {
				this._clips.push(t)
			},
			addAnimator: function(t) {
				t.animation = this;
				for (var e = t.getClips(), n = 0; n < e.length; n++) this.addClip(e[n])
			},
			removeClip: function(t) {
				var e = i.indexOf(this._clips, t);
				e >= 0 && this._clips.splice(e, 1)
			},
			removeAnimator: function(t) {
				for (var e = t.getClips(), n = 0; n < e.length; n++) this.removeClip(e[n]);
				t.animation = null
			},
			_update: function() {
				for (var t = (new Date).getTime(), e = t - this._time, n = this._clips, i = n.length, o = [], r = [], s = 0; i > s; s++) {
					var a = n[s],
						l = a.step(t);
					l && (o.push(l), r.push(a))
				}
				for (var s = 0; i > s;) n[s]._needsRemove ? (n[s] = n[i - 1], n.pop(), i--) : s++;
				i = o.length;
				for (var s = 0; i > s; s++) r[s].fire(o[s]);
				this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update()
			},
			start: function() {
				function t() {
					e._running && (r(t), e._update())
				}
				var e = this;
				this._running = !0, this._time = (new Date).getTime(), r(t)
			},
			stop: function() {
				this._running = !1
			},
			clear: function() {
				this._clips = []
			},
			animate: function(t, e) {
				e = e || {};
				var n = new s(t, e.loop, e.getter, e.setter);
				return n
			}
		}, i.mixin(a, o), t.exports = a
	}, function(t, e, n) {
		function i(t) {
			this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null != t.loop && t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart
		}
		var o = n(132);
		i.prototype = {
			constructor: i,
			step: function(t) {
				this._initialized || (this._startTime = (new Date).getTime() + this._delay, this._initialized = !0);
				var e = (t - this._startTime) / this._life;
				if (!(0 > e)) {
					e = Math.min(e, 1);
					var n = this.easing,
						i = "string" == typeof n ? o[n] : n,
						r = "function" == typeof i ? i(e) : e;
					return this.fire("frame", r), 1 == e ? this.loop ? (this.restart(), "restart") : (this._needsRemove = !0, "destroy") : null
				}
			},
			restart: function() {
				var t = (new Date).getTime(),
					e = (t - this._startTime) % this._life;
				this._startTime = (new Date).getTime() - e + this.gap, this._needsRemove = !1
			},
			fire: function(t, e) {
				t = "on" + t, this[t] && this[t](this._target, e)
			}
		}, t.exports = i
	}, function(t, e) {
		var n = {
			linear: function(t) {
				return t
			},
			quadraticIn: function(t) {
				return t * t
			},
			quadraticOut: function(t) {
				return t * (2 - t)
			},
			quadraticInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
			},
			cubicIn: function(t) {
				return t * t * t
			},
			cubicOut: function(t) {
				return --t * t * t + 1
			},
			cubicInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
			},
			quarticIn: function(t) {
				return t * t * t * t
			},
			quarticOut: function(t) {
				return 1 - --t * t * t * t
			},
			quarticInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
			},
			quinticIn: function(t) {
				return t * t * t * t * t
			},
			quinticOut: function(t) {
				return --t * t * t * t * t + 1
			},
			quinticInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
			},
			sinusoidalIn: function(t) {
				return 1 - Math.cos(t * Math.PI / 2)
			},
			sinusoidalOut: function(t) {
				return Math.sin(t * Math.PI / 2)
			},
			sinusoidalInOut: function(t) {
				return .5 * (1 - Math.cos(Math.PI * t))
			},
			exponentialIn: function(t) {
				return 0 === t ? 0 : Math.pow(1024, t - 1)
			},
			exponentialOut: function(t) {
				return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
			},
			exponentialInOut: function(t) {
				return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
			},
			circularIn: function(t) {
				return 1 - Math.sqrt(1 - t * t)
			},
			circularOut: function(t) {
				return Math.sqrt(1 - --t * t)
			},
			circularInOut: function(t) {
				return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
			},
			elasticIn: function(t) {
				var e, n = .1,
					i = .4;
				return 0 === t ? 0 : 1 === t ? 1 : (!n || 1 > n ? (n = 1, e = i / 4) : e = i * Math.asin(1 / n) / (2 * Math.PI), -(n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i)))
			},
			elasticOut: function(t) {
				var e, n = .1,
					i = .4;
				return 0 === t ? 0 : 1 === t ? 1 : (!n || 1 > n ? (n = 1, e = i / 4) : e = i * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / i) + 1)
			},
			elasticInOut: function(t) {
				var e, n = .1,
					i = .4;
				return 0 === t ? 0 : 1 === t ? 1 : (!n || 1 > n ? (n = 1, e = i / 4) : e = i * Math.asin(1 / n) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * (n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i)) : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * .5 + 1)
			},
			backIn: function(t) {
				var e = 1.70158;
				return t * t * ((e + 1) * t - e)
			},
			backOut: function(t) {
				var e = 1.70158;
				return --t * t * ((e + 1) * t + e) + 1
			},
			backInOut: function(t) {
				var e = 2.5949095;
				return (t *= 2) < 1 ? .5 * (t * t * ((e + 1) * t - e)) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
			},
			bounceIn: function(t) {
				return 1 - n.bounceOut(1 - t)
			},
			bounceOut: function(t) {
				return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
			},
			bounceInOut: function(t) {
				return .5 > t ? .5 * n.bounceIn(2 * t) : .5 * n.bounceOut(2 * t - 1) + .5
			}
		};
		t.exports = n
	}, function(t, e, n) {
		var i = n(57).normalizeRadian,
			o = 2 * Math.PI;
		t.exports = {
			containStroke: function(t, e, n, r, s, a, l, u, p) {
				if (0 === l) return !1;
				var h = l;
				u -= t, p -= e;
				var c = Math.sqrt(u * u + p * p);
				if (c - h > n || n > c + h) return !1;
				if (Math.abs(r - s) % o < 1e-4) return !0;
				if (a) {
					var g = r;
					r = i(s), s = i(g)
				} else r = i(r), s = i(s);
				r > s && (s += o);
				var d = Math.atan2(p, u);
				return 0 > d && (d += o), d >= r && s >= d || d + o >= r && s >= d + o
			}
		}
	}, function(t, e, n) {
		var i = n(16);
		t.exports = {
			containStroke: function(t, e, n, o, r, s, a, l, u, p, h) {
				if (0 === u) return !1;
				var c = u;
				if (h > e + c && h > o + c && h > s + c && h > l + c || e - c > h && o - c > h && s - c > h && l - c > h || p > t + c && p > n + c && p > r + c && p > a + c || t - c > p && n - c > p && r - c > p && a - c > p) return !1;
				var g = i.cubicProjectPoint(t, e, n, o, r, s, a, l, p, h, null);
				return c / 2 >= g
			}
		}
	}, function(t, e) {
		t.exports = {
			containStroke: function(t, e, n, i, o, r, s) {
				if (0 === o) return !1;
				var a = o,
					l = 0,
					u = t;
				if (s > e + a && s > i + a || e - a > s && i - a > s || r > t + a && r > n + a || t - a > r && n - a > r) return !1;
				if (t === n) return Math.abs(r - t) <= a / 2;
				l = (e - i) / (t - n), u = (t * i - n * e) / (t - n);
				var p = l * r - s + u,
					h = p * p / (l * l + 1);
				return a / 2 * a / 2 >= h
			}
		}
	}, function(t, e, n) {
		"use strict";

		function i(t, e) {
			return Math.abs(t - e) < x
		}
		function o() {
			var t = E[0];
			E[0] = E[1], E[1] = t
		}
		function r(t, e, n, i, r, s, a, l, u, p) {
			if (p > e && p > i && p > s && p > l || e > p && i > p && s > p && l > p) return 0;
			var h = f.cubicRootAt(e, i, s, l, p, j);
			if (0 === h) return 0;
			for (var c, g, d = 0, m = -1, y = 0; h > y; y++) {
				var v = j[y],
					x = f.cubicAt(t, n, r, a, v);
				u > x || (0 > m && (m = f.cubicExtrema(e, i, s, l, E), E[1] < E[0] && m > 1 && o(), c = f.cubicAt(e, i, s, l, E[0]), m > 1 && (g = f.cubicAt(e, i, s, l, E[1]))), d += 2 == m ? v < E[0] ? e > c ? 1 : -1 : v < E[1] ? c > g ? 1 : -1 : g > l ? 1 : -1 : v < E[0] ? e > c ? 1 : -1 : c > l ? 1 : -1)
			}
			return d
		}
		function s(t, e, n, i, o, r, s, a) {
			if (a > e && a > i && a > r || e > a && i > a && r > a) return 0;
			var l = f.quadraticRootAt(e, i, r, a, j);
			if (0 === l) return 0;
			var u = f.quadraticExtremum(e, i, r);
			if (u >= 0 && 1 >= u) {
				for (var p = 0, h = f.quadraticAt(e, i, r, u), c = 0; l > c; c++) {
					var g = f.quadraticAt(t, n, o, j[c]);
					s > g || (p += j[c] < u ? e > h ? 1 : -1 : h > r ? 1 : -1)
				}
				return p
			}
			var g = f.quadraticAt(t, n, o, j[0]);
			return s > g ? 0 : e > r ? 1 : -1
		}
		function a(t, e, n, i, o, r, s, a) {
			if (a -= e, a > n || -n > a) return 0;
			var l = Math.sqrt(n * n - a * a);
			j[0] = -l, j[1] = l;
			var u = Math.abs(i - o);
			if (1e-4 > u) return 0;
			if (1e-4 > u % v) {
				i = 0, o = v;
				var p = r ? 1 : -1;
				return s >= j[0] + t && s <= j[1] + t ? p : 0
			}
			if (r) {
				var l = i;
				i = d(o), o = d(l)
			} else i = d(i), o = d(o);
			i > o && (o += v);
			for (var h = 0, c = 0; 2 > c; c++) {
				var g = j[c];
				if (g + t > s) {
					var f = Math.atan2(a, g),
						p = r ? 1 : -1;
					0 > f && (f = v + f), (f >= i && o >= f || f + v >= i && o >= f + v) && (f > Math.PI / 2 && f < 1.5 * Math.PI && (p = -p), h += p)
				}
			}
			return h
		}
		function l(t, e, n, o, l) {
			for (var p = 0, d = 0, f = 0, v = 0, x = 0, j = 0; j < t.length;) {
				var E = t[j++];
				if (E === u.M && j > 1 && (n || (p += m(d, f, v, x, o, l)), 0 !== p)) return !0;
				switch (1 == j && (d = t[j], f = t[j + 1], v = d, x = f), E) {
				case u.M:
					v = t[j++], x = t[j++], d = v, f = x;
					break;
				case u.L:
					if (n) {
						if (y(d, f, t[j], t[j + 1], e, o, l)) return !0
					} else p += m(d, f, t[j], t[j + 1], o, l) || 0;
					d = t[j++], f = t[j++];
					break;
				case u.C:
					if (n) {
						if (h.containStroke(d, f, t[j++], t[j++], t[j++], t[j++], t[j], t[j + 1], e, o, l)) return !0
					} else p += r(d, f, t[j++], t[j++], t[j++], t[j++], t[j], t[j + 1], o, l) || 0;
					d = t[j++], f = t[j++];
					break;
				case u.Q:
					if (n) {
						if (c.containStroke(d, f, t[j++], t[j++], t[j], t[j + 1], e, o, l)) return !0
					} else p += s(d, f, t[j++], t[j++], t[j], t[j + 1], o, l) || 0;
					d = t[j++], f = t[j++];
					break;
				case u.A:
					var I = t[j++],
						C = t[j++],
						S = t[j++],
						b = t[j++],
						L = t[j++],
						w = t[j++],
						P = (t[j++], 1 - t[j++]),
						M = Math.cos(L) * S + I,
						_ = Math.sin(L) * b + C;
					j > 1 ? p += m(d, f, M, _, o, l) : (v = M, x = _);
					var N = (o - I) * b / S + I;
					if (n) {
						if (g.containStroke(I, C, b, L, L + w, P, e, N, l)) return !0
					} else p += a(I, C, b, L, L + w, P, N, l);
					d = Math.cos(L + w) * S + I, f = Math.sin(L + w) * b + C;
					break;
				case u.R:
					v = d = t[j++], x = f = t[j++];
					var A = t[j++],
						T = t[j++],
						M = v + A,
						_ = x + T;
					if (n) {
						if (y(v, x, M, x, e, o, l) || y(M, x, M, _, e, o, l) || y(M, _, v, _, e, o, l) || y(v, _, M, _, e, o, l)) return !0
					} else p += m(M, x, M, _, o, l), p += m(v, _, v, x, o, l);
					break;
				case u.Z:
					if (n) {
						if (y(d, f, v, x, e, o, l)) return !0
					} else if (p += m(d, f, v, x, o, l), 0 !== p) return !0;
					d = v, f = x
				}
			}
			return n || i(f, x) || (p += m(d, f, v, x, o, l) || 0), 0 !== p
		}
		var u = n(28).CMD,
			p = n(135),
			h = n(134),
			c = n(137),
			g = n(133),
			d = n(57).normalizeRadian,
			f = n(16),
			m = n(75),
			y = p.containStroke,
			v = 2 * Math.PI,
			x = 1e-4,
			j = [-1, -1, -1],
			E = [-1, -1];
		t.exports = {
			contain: function(t, e, n) {
				return l(t, 0, !1, e, n)
			},
			containStroke: function(t, e, n, i) {
				return l(t, e, !0, n, i)
			}
		}
	}, function(t, e, n) {
		var i = n(16);
		t.exports = {
			containStroke: function(t, e, n, o, r, s, a, l, u) {
				if (0 === a) return !1;
				var p = a;
				if (u > e + p && u > o + p && u > s + p || e - p > u && o - p > u && s - p > u || l > t + p && l > n + p && l > r + p || t - p > l && n - p > l && r - p > l) return !1;
				var h = i.quadraticProjectPoint(t, e, n, o, r, s, l, u, null);
				return p / 2 >= h
			}
		}
	}, function(t, e) {
		"use strict";

		function n(t) {
			var e = t[1][0] - t[0][0],
				n = t[1][1] - t[0][1];
			return Math.sqrt(e * e + n * n)
		}
		function i(t) {
			return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
		}
		var o = function() {
				this._track = []
			};
		o.prototype = {
			constructor: o,
			recognize: function(t, e) {
				return this._doTrack(t, e), this._recognize(t)
			},
			clear: function() {
				return this._track.length = 0, this
			},
			_doTrack: function(t, e) {
				var n = t.touches;
				if (n) {
					for (var i = {
						points: [],
						touches: [],
						target: e,
						event: t
					}, o = 0, r = n.length; r > o; o++) {
						var s = n[o];
						i.points.push([s.clientX, s.clientY]), i.touches.push(s)
					}
					this._track.push(i)
				}
			},
			_recognize: function(t) {
				for (var e in r) if (r.hasOwnProperty(e)) {
					var n = r[e](this._track, t);
					if (n) return n
				}
			}
		};
		var r = {
			pinch: function(t, e) {
				var o = t.length;
				if (o) {
					var r = (t[o - 1] || {}).points,
						s = (t[o - 2] || {}).points || r;
					if (s && s.length > 1 && r && r.length > 1) {
						var a = n(r) / n(s);
						!isFinite(a) && (a = 1), e.pinchScale = a;
						var l = i(r);
						return e.pinchX = l[0], e.pinchY = l[1], {
							type: "pinch",
							target: t[0].target,
							event: e
						}
					}
				}
			}
		};
		t.exports = o
	}, function(t, e) {
		var n = function() {
				this.head = null, this.tail = null, this._len = 0
			},
			i = n.prototype;
		i.insert = function(t) {
			var e = new o(t);
			return this.insertEntry(e), e
		}, i.insertEntry = function(t) {
			this.head ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : this.head = this.tail = t, this._len++
		}, i.remove = function(t) {
			var e = t.prev,
				n = t.next;
			e ? e.next = n : this.head = n, n ? n.prev = e : this.tail = e, t.next = t.prev = null, this._len--
		}, i.len = function() {
			return this._len
		};
		var o = function(t) {
				this.value = t, this.next, this.prev
			},
			r = function(t) {
				this._list = new n, this._map = {}, this._maxSize = t || 10
			},
			s = r.prototype;
		s.put = function(t, e) {
			var n = this._list,
				i = this._map;
			if (null == i[t]) {
				var o = n.len();
				if (o >= this._maxSize && o > 0) {
					var r = n.head;
					n.remove(r), delete i[r.key]
				}
				var s = n.insert(e);
				s.key = t, i[t] = s
			}
		}, s.get = function(t) {
			var e = this._map[t],
				n = this._list;
			return null != e ? (e !== n.tail && (n.remove(e), n.insertEntry(e)), e.value) : void 0
		}, s.clear = function() {
			this._list.clear(), this._map = {}
		}, t.exports = r
	}, function(t, e, n) {
		var i = n(6);
		t.exports = i.extend({
			type: "compound",
			shape: {
				paths: null
			},
			_updatePathDirty: function() {
				for (var t = this.__dirtyPath, e = this.shape.paths, n = 0; n < e.length; n++) t = t || e[n].__dirtyPath;
				this.__dirtyPath = t, this.__dirty = this.__dirty || t
			},
			beforeBrush: function() {
				this._updatePathDirty();
				for (var t = this.shape.paths || [], e = this.getGlobalScale(), n = 0; n < t.length; n++) t[n].path.setScale(e[0], e[1])
			},
			buildPath: function(t, e) {
				for (var n = e.paths || [], i = 0; i < n.length; i++) n[i].buildPath(t, n[i].shape)
			},
			afterBrush: function() {
				for (var t = this.shape.paths, e = 0; e < t.length; e++) t[e].__dirtyPath = !1
			},
			getBoundingRect: function() {
				return this._updatePathDirty(), i.prototype.getBoundingRect.call(this)
			}
		})
	}, function(t, e, n) {
		"use strict";
		var i = n(1),
			o = n(17),
			r = function(t, e, n, i) {
				this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == n ? .5 : n, o.call(this, i)
			};
		r.prototype = {
			constructor: r,
			type: "radial"
		}, i.inherits(r, o), t.exports = r
	}, function(t, e) {
		var n = ["lineCap", "lineJoin", "miterLimit", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "shadowColor"],
			i = function(t) {
				this.extendFrom(t)
			};
		i.prototype = {
			constructor: i,
			fill: "#000000",
			stroke: null,
			opacity: 1,
			lineDash: null,
			lineDashOffset: 0,
			shadowBlur: 0,
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			lineWidth: 1,
			strokeNoScale: !1,
			text: null,
			textFill: "#000",
			textStroke: null,
			textPosition: "inside",
			textBaseline: null,
			textAlign: null,
			textVerticalAlign: null,
			textDistance: 5,
			textShadowBlur: 0,
			textShadowOffsetX: 0,
			textShadowOffsetY: 0,
			bind: function(t, e) {
				for (var i = this.fill, o = this.stroke, r = 0; r < n.length; r++) {
					var s = n[r];
					null != this[s] && (t[s] = this[s])
				}
				if (null != o) {
					var a = this.lineWidth;
					t.lineWidth = a / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1)
				}
				null == i || "none" === i || i.colorStops || (t.fillStyle = i), null == o || "none" === o || o.colorStops || (t.strokeStyle = o), null != this.opacity && (t.globalAlpha = this.opacity)
			},
			extendFrom: function(t, e) {
				if (t) {
					var n = this;
					for (var i in t)!t.hasOwnProperty(i) || !e && n.hasOwnProperty(i) || (n[i] = t[i])
				}
			},
			set: function(t, e) {
				"string" == typeof t ? this[t] = e : this.extendFrom(t, !0)
			},
			clone: function() {
				var t = new this.constructor;
				return t.extendFrom(this, !0), t
			},
			createLinearGradient: function(t, e, n) {
				var i = e.x * n.width + n.x,
					o = e.x2 * n.width + n.x,
					r = e.y * n.height + n.y,
					s = e.y2 * n.height + n.y,
					a = t.createLinearGradient(i, r, o, s);
				return a
			},
			createRadialGradient: function(t, e, n) {
				var i = n.width,
					o = n.height,
					r = Math.min(i, o),
					s = e.x * i + n.x,
					a = e.y * o + n.y,
					l = e.r * r,
					u = t.createRadialGradient(s, a, 0, s, a, l);
				return u
			},
			getGradient: function(t, e, n) {
				for (var i = "radial" === e.type ? "createRadialGradient" : "createLinearGradient", o = this[i](t, e, n), r = e.colorStops, s = 0; s < r.length; s++) o.addColorStop(r[s].offset, r[s].color);
				return o
			}
		};
		var o, r, s = i.prototype;
		for (r = 0; r < n.length; r++) o = n[r], o in s || (s[o] = null);
		t.exports = i
	}, function(t, e, n) {
		var i = n(5),
			o = i.min,
			r = i.max,
			s = i.scale,
			a = i.distance,
			l = i.add;
		t.exports = function(t, e, n, u) {
			var p, h, c, g, d = [],
				f = [],
				m = [],
				y = [];
			if (u) {
				c = [1 / 0, 1 / 0], g = [-(1 / 0), -(1 / 0)];
				for (var v = 0, x = t.length; x > v; v++) o(c, c, t[v]), r(g, g, t[v]);
				o(c, c, u[0]), r(g, g, u[1])
			}
			for (var v = 0, x = t.length; x > v; v++) {
				var j = t[v];
				if (n) p = t[v ? v - 1 : x - 1], h = t[(v + 1) % x];
				else {
					if (0 === v || v === x - 1) {
						d.push(i.clone(t[v]));
						continue
					}
					p = t[v - 1], h = t[v + 1]
				}
				i.sub(f, h, p), s(f, f, e);
				var E = a(j, p),
					I = a(j, h),
					C = E + I;
				0 !== C && (E /= C, I /= C), s(m, f, -E), s(y, f, I);
				var S = l([], j, m),
					b = l([], j, y);
				u && (r(S, S, c), o(S, S, g), r(b, b, c), o(b, b, g)), d.push(S), d.push(b)
			}
			return n && d.push(d.shift()), d
		}
	}, function(t, e, n) {
		function i(t, e, n, i, o, r, s) {
			var a = .5 * (n - t),
				l = .5 * (i - e);
			return (2 * (e - n) + a + l) * s + (-3 * (e - n) - 2 * a - l) * r + a * o + e
		}
		var o = n(5);
		t.exports = function(t, e) {
			for (var n = t.length, r = [], s = 0, a = 1; n > a; a++) s += o.distance(t[a - 1], t[a]);
			var l = s / 2;
			l = n > l ? n : l;
			for (var a = 0; l > a; a++) {
				var u, p, h, c = a / (l - 1) * (e ? n : n - 1),
					g = Math.floor(c),
					d = c - g,
					f = t[g % n];
				e ? (u = t[(g - 1 + n) % n], p = t[(g + 1) % n], h = t[(g + 2) % n]) : (u = t[0 === g ? g : g - 1], p = t[g > n - 2 ? n - 1 : g + 1], h = t[g > n - 3 ? n - 1 : g + 2]);
				var m = d * d,
					y = d * m;
				r.push([i(u[0], f[0], p[0], h[0], d, m, y), i(u[1], f[1], p[1], h[1], d, m, y)])
			}
			return r
		}
	}, function(t, e, n) {
		t.exports = n(6).extend({
			type: "arc",
			shape: {
				cx: 0,
				cy: 0,
				r: 0,
				startAngle: 0,
				endAngle: 2 * Math.PI,
				clockwise: !0
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				var n = e.cx,
					i = e.cy,
					o = Math.max(e.r, 0),
					r = e.startAngle,
					s = e.endAngle,
					a = e.clockwise,
					l = Math.cos(r),
					u = Math.sin(r);
				t.moveTo(l * o + n, u * o + i), t.arc(n, i, o, r, s, !a)
			}
		})
	}, function(t, e, n) {
		"use strict";

		function i(t, e, n) {
			var i = t.cpx2,
				o = t.cpy2;
			return null === i || null === o ? [(n ? h : u)(t.x1, t.cpx1, t.cpx2, t.x2, e), (n ? h : u)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(n ? p : l)(t.x1, t.cpx1, t.x2, e), (n ? p : l)(t.y1, t.cpy1, t.y2, e)]
		}
		var o = n(16),
			r = n(5),
			s = o.quadraticSubdivide,
			a = o.cubicSubdivide,
			l = o.quadraticAt,
			u = o.cubicAt,
			p = o.quadraticDerivativeAt,
			h = o.cubicDerivativeAt,
			c = [];
		t.exports = n(6).extend({
			type: "bezier-curve",
			shape: {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				cpx1: 0,
				cpy1: 0,
				percent: 1
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				var n = e.x1,
					i = e.y1,
					o = e.x2,
					r = e.y2,
					l = e.cpx1,
					u = e.cpy1,
					p = e.cpx2,
					h = e.cpy2,
					g = e.percent;
				0 !== g && (t.moveTo(n, i), null == p || null == h ? (1 > g && (s(n, l, o, g, c), l = c[1], o = c[2], s(i, u, r, g, c), u = c[1], r = c[2]), t.quadraticCurveTo(l, u, o, r)) : (1 > g && (a(n, l, p, o, g, c), l = c[1], p = c[2], o = c[3], a(i, u, h, r, g, c), u = c[1], h = c[2], r = c[3]), t.bezierCurveTo(l, u, p, h, o, r)))
			},
			pointAt: function(t) {
				return i(this.shape, t, !1)
			},
			tangentAt: function(t) {
				var e = i(this.shape, t, !0);
				return r.normalize(e, e)
			}
		})
	}, function(t, e, n) {
		"use strict";
		t.exports = n(6).extend({
			type: "circle",
			shape: {
				cx: 0,
				cy: 0,
				r: 0
			},
			buildPath: function(t, e) {
				t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
			}
		})
	}, function(t, e, n) {
		t.exports = n(6).extend({
			type: "line",
			shape: {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				percent: 1
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				var n = e.x1,
					i = e.y1,
					o = e.x2,
					r = e.y2,
					s = e.percent;
				0 !== s && (t.moveTo(n, i), 1 > s && (o = n * (1 - s) + o * s, r = i * (1 - s) + r * s), t.lineTo(o, r))
			},
			pointAt: function(t) {
				var e = this.shape;
				return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
			}
		})
	}, function(t, e, n) {
		var i = n(59);
		t.exports = n(6).extend({
			type: "polygon",
			shape: {
				points: null,
				smooth: !1,
				smoothConstraint: null
			},
			buildPath: function(t, e) {
				i.buildPath(t, e, !0)
			}
		})
	}, function(t, e, n) {
		var i = n(59);
		t.exports = n(6).extend({
			type: "polyline",
			shape: {
				points: null,
				smooth: !1,
				smoothConstraint: null
			},
			style: {
				stroke: "#000",
				fill: null
			},
			buildPath: function(t, e) {
				i.buildPath(t, e, !1)
			}
		})
	}, function(t, e, n) {
		var i = n(60);
		t.exports = n(6).extend({
			type: "rect",
			shape: {
				r: 0,
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var n = e.x,
					o = e.y,
					r = e.width,
					s = e.height;
				e.r ? i.buildPath(t, e) : t.rect(n, o, r, s), t.closePath()
			}
		})
	}, function(t, e, n) {
		t.exports = n(6).extend({
			type: "ring",
			shape: {
				cx: 0,
				cy: 0,
				r: 0,
				r0: 0
			},
			buildPath: function(t, e) {
				var n = e.cx,
					i = e.cy,
					o = 2 * Math.PI;
				t.moveTo(n + e.r, i), t.arc(n, i, e.r, 0, o, !1), t.moveTo(n + e.r0, i), t.arc(n, i, e.r0, 0, o, !0)
			}
		})
	}, function(t, e, n) {
		t.exports = n(6).extend({
			type: "sector",
			shape: {
				cx: 0,
				cy: 0,
				r0: 0,
				r: 0,
				startAngle: 0,
				endAngle: 2 * Math.PI,
				clockwise: !0
			},
			buildPath: function(t, e) {
				var n = e.cx,
					i = e.cy,
					o = Math.max(e.r0 || 0, 0),
					r = Math.max(e.r, 0),
					s = e.startAngle,
					a = e.endAngle,
					l = e.clockwise,
					u = Math.cos(s),
					p = Math.sin(s);
				t.moveTo(u * o + n, p * o + i), t.lineTo(u * r + n, p * r + i), t.arc(n, i, r, s, a, !l), t.lineTo(Math.cos(a) * o + n, Math.sin(a) * o + i), 0 !== o && t.arc(n, i, o, a, s, l), t.closePath()
			}
		})
	}, function(t, e, n) {
		"use strict";
		var i = n(56),
			o = n(1),
			r = o.isString,
			s = o.isFunction,
			a = o.isObject,
			l = n(45),
			u = function() {
				this.animators = []
			};
		u.prototype = {
			constructor: u,
			animate: function(t, e) {
				var n, r = !1,
					s = this,
					a = this.__zr;
				if (t) {
					var u = t.split("."),
						p = s;
					r = "shape" === u[0];
					for (var h = 0, c = u.length; c > h; h++) p && (p = p[u[h]]);
					p && (n = p)
				} else n = s;
				if (!n) return void l('Property "' + t + '" is not existed in element ' + s.id);
				var g = s.animators,
					d = new i(n, e);
				return d.during(function(t) {
					s.dirty(r)
				}).done(function() {
					g.splice(o.indexOf(g, d), 1)
				}), g.push(d), a && a.animation.addAnimator(d), d
			},
			stopAnimation: function(t) {
				for (var e = this.animators, n = e.length, i = 0; n > i; i++) e[i].stop(t);
				return e.length = 0, this
			},
			animateTo: function(t, e, n, i, o) {
				function a() {
					u--, u || o && o()
				}
				r(n) ? (o = i, i = n, n = 0) : s(i) ? (o = i, i = "linear", n = 0) : s(n) ? (o = n, n = 0) : s(e) ? (o = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, n, i, o);
				var l = this.animators.slice(),
					u = l.length;
				u || o && o();
				for (var p = 0; p < l.length; p++) l[p].done(a).start(i)
			},
			_animateToShallow: function(t, e, n, i, r) {
				var s = {},
					l = 0;
				for (var u in n) if (null != e[u]) a(n[u]) && !o.isArrayLike(n[u]) ? this._animateToShallow(t ? t + "." + u : u, e[u], n[u], i, r) : (s[u] = n[u], l++);
				else if (null != n[u]) if (t) {
					var p = {};
					p[t] = {}, p[t][u] = n[u], this.attr(p)
				} else this.attr(u, n[u]);
				return l > 0 && this.animate(t, !1).when(null == i ? 500 : i, s).delay(r || 0), this
			}
		}, t.exports = u
	}, function(t, e) {
		function n() {
			this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this)
		}
		n.prototype = {
			constructor: n,
			_dragStart: function(t) {
				var e = t.target;
				e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this._dispatchProxy(e, "dragstart", t.event))
			},
			_drag: function(t) {
				var e = this._draggingTarget;
				if (e) {
					var n = t.offsetX,
						i = t.offsetY,
						o = n - this._x,
						r = i - this._y;
					this._x = n, this._y = i, e.drift(o, r, t), this._dispatchProxy(e, "drag", t.event);
					var s = this.findHover(n, i, e),
						a = this._dropTarget;
					this._dropTarget = s, e !== s && (a && s !== a && this._dispatchProxy(a, "dragleave", t.event), s && s !== a && this._dispatchProxy(s, "dragenter", t.event))
				}
			},
			_dragEnd: function(t) {
				var e = this._draggingTarget;
				e && (e.dragging = !1), this._dispatchProxy(e, "dragend", t.event), this._dropTarget && this._dispatchProxy(this._dropTarget, "drop", t.event), this._draggingTarget = null, this._dropTarget = null
			}
		}, t.exports = n
	}, function(t, e, n) {
		function i(t, e, n, i, o, r, s, a, l, u, p) {
			var f = l * (d / 180),
				v = g(f) * (t - n) / 2 + c(f) * (e - i) / 2,
				x = -1 * c(f) * (t - n) / 2 + g(f) * (e - i) / 2,
				j = v * v / (s * s) + x * x / (a * a);
			j > 1 && (s *= h(j), a *= h(j));
			var E = (o === r ? -1 : 1) * h((s * s * (a * a) - s * s * (x * x) - a * a * (v * v)) / (s * s * (x * x) + a * a * (v * v))) || 0,
				I = E * s * x / a,
				C = E * -a * v / s,
				S = (t + n) / 2 + g(f) * I - c(f) * C,
				b = (e + i) / 2 + c(f) * I + g(f) * C,
				L = y([1, 0], [(v - I) / s, (x - C) / a]),
				w = [(v - I) / s, (x - C) / a],
				P = [(-1 * v - I) / s, (-1 * x - C) / a],
				M = y(w, P);
			m(w, P) <= -1 && (M = d), m(w, P) >= 1 && (M = 0), 0 === r && M > 0 && (M -= 2 * d), 1 === r && 0 > M && (M += 2 * d), p.addData(u, S, b, s, a, L, M, f, r)
		}
		function o(t) {
			if (!t) return [];
			var e, n = t.replace(/-/g, " -").replace(/  /g, " ").replace(/ /g, ",").replace(/,,/g, ",");
			for (e = 0; e < p.length; e++) n = n.replace(new RegExp(p[e], "g"), "|" + p[e]);
			var o, r = n.split("|"),
				s = 0,
				l = 0,
				u = new a,
				h = a.CMD;
			for (e = 1; e < r.length; e++) {
				var c, g = r[e],
					d = g.charAt(0),
					f = 0,
					m = g.slice(1).replace(/e,-/g, "e-").split(",");
				m.length > 0 && "" === m[0] && m.shift();
				for (var y = 0; y < m.length; y++) m[y] = parseFloat(m[y]);
				for (; f < m.length && !isNaN(m[f]) && !isNaN(m[0]);) {
					var v, x, j, E, I, C, S, b = s,
						L = l;
					switch (d) {
					case "l":
						s += m[f++], l += m[f++], c = h.L, u.addData(c, s, l);
						break;
					case "L":
						s = m[f++], l = m[f++], c = h.L, u.addData(c, s, l);
						break;
					case "m":
						s += m[f++], l += m[f++], c = h.M, u.addData(c, s, l), d = "l";
						break;
					case "M":
						s = m[f++], l = m[f++], c = h.M, u.addData(c, s, l), d = "L";
						break;
					case "h":
						s += m[f++], c = h.L, u.addData(c, s, l);
						break;
					case "H":
						s = m[f++], c = h.L, u.addData(c, s, l);
						break;
					case "v":
						l += m[f++], c = h.L, u.addData(c, s, l);
						break;
					case "V":
						l = m[f++], c = h.L, u.addData(c, s, l);
						break;
					case "C":
						c = h.C, u.addData(c, m[f++], m[f++], m[f++], m[f++], m[f++], m[f++]), s = m[f - 2], l = m[f - 1];
						break;
					case "c":
						c = h.C, u.addData(c, m[f++] + s, m[f++] + l, m[f++] + s, m[f++] + l, m[f++] + s, m[f++] + l), s += m[f - 2], l += m[f - 1];
						break;
					case "S":
						v = s, x = l;
						var w = u.len(),
							P = u.data;
						o === h.C && (v += s - P[w - 4], x += l - P[w - 3]), c = h.C, b = m[f++], L = m[f++], s = m[f++], l = m[f++], u.addData(c, v, x, b, L, s, l);
						break;
					case "s":
						v = s, x = l;
						var w = u.len(),
							P = u.data;
						o === h.C && (v += s - P[w - 4], x += l - P[w - 3]), c = h.C, b = s + m[f++], L = l + m[f++], s += m[f++], l += m[f++], u.addData(c, v, x, b, L, s, l);
						break;
					case "Q":
						b = m[f++], L = m[f++], s = m[f++], l = m[f++], c = h.Q, u.addData(c, b, L, s, l);
						break;
					case "q":
						b = m[f++] + s, L = m[f++] + l, s += m[f++], l += m[f++], c = h.Q, u.addData(c, b, L, s, l);
						break;
					case "T":
						v = s, x = l;
						var w = u.len(),
							P = u.data;
						o === h.Q && (v += s - P[w - 4], x += l - P[w - 3]), s = m[f++], l = m[f++], c = h.Q, u.addData(c, v, x, s, l);
						break;
					case "t":
						v = s, x = l;
						var w = u.len(),
							P = u.data;
						o === h.Q && (v += s - P[w - 4], x += l - P[w - 3]), s += m[f++], l += m[f++], c = h.Q, u.addData(c, v, x, s, l);
						break;
					case "A":
						j = m[f++], E = m[f++], I = m[f++], C = m[f++], S = m[f++], b = s, L = l, s = m[f++], l = m[f++], c = h.A, i(b, L, s, l, C, S, j, E, I, c, u);
						break;
					case "a":
						j = m[f++], E = m[f++], I = m[f++], C = m[f++], S = m[f++], b = s, L = l, s += m[f++], l += m[f++], c = h.A, i(b, L, s, l, C, S, j, E, I, c, u)
					}
				}
				"z" !== d && "Z" !== d || (c = h.Z, u.addData(c)), o = c
			}
			return u.toStatic(), u
		}
		function r(t, e) {
			var n, i = o(t);
			return e = e || {}, e.buildPath = function(t) {
				t.setData(i.data), n && l(t, n);
				var e = t.getContext();
				e && t.rebuildPath(e)
			}, e.applyTransform = function(t) {
				n || (n = u.create()), u.mul(n, t, n)
			}, e
		}
		var s = n(6),
			a = n(28),
			l = n(157),
			u = n(19),
			p = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"],
			h = Math.sqrt,
			c = Math.sin,
			g = Math.cos,
			d = Math.PI,
			f = function(t) {
				return Math.sqrt(t[0] * t[0] + t[1] * t[1])
			},
			m = function(t, e) {
				return (t[0] * e[0] + t[1] * e[1]) / (f(t) * f(e))
			},
			y = function(t, e) {
				return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(m(t, e))
			};
		t.exports = {
			createFromString: function(t, e) {
				return new s(r(t, e))
			},
			extendFromString: function(t, e) {
				return s.extend(r(t, e))
			},
			mergePath: function(t, e) {
				var n, i, o = [],
					r = t.length;
				for (i = 0; r > i; i++) n = t[i], n.__dirty && n.buildPath(n.path, n.shape), o.push(n.path);
				var a = new s(e);
				return a.buildPath = function(t) {
					t.appendPath(o);
					var e = t.getContext();
					e && t.rebuildPath(e)
				}, a
			}
		}
	}, function(t, e, n) {
		function i(t, e) {
			var n, i, r, p, h, c, g = t.data,
				d = o.M,
				f = o.C,
				m = o.L,
				y = o.R,
				v = o.A,
				x = o.Q;
			for (r = 0, p = 0; r < g.length;) {
				switch (n = g[r++], p = r, i = 0, n) {
				case d:
					i = 1;
					break;
				case m:
					i = 1;
					break;
				case f:
					i = 3;
					break;
				case x:
					i = 2;
					break;
				case v:
					var j = e[4],
						E = e[5],
						I = l(e[0] * e[0] + e[1] * e[1]),
						C = l(e[2] * e[2] + e[3] * e[3]),
						S = u(-e[1] / C, e[0] / I);
					g[r++] += j, g[r++] += E, g[r++] *= I, g[r++] *= C, g[r++] += S, g[r++] += S, r += 2, p = r;
					break;
				case y:
					c[0] = g[r++], c[1] = g[r++], s(c, c, e), g[p++] = c[0], g[p++] = c[1], c[0] += g[r++], c[1] += g[r++], s(c, c, e), g[p++] = c[0], g[p++] = c[1]
				}
				for (h = 0; i > h; h++) {
					var c = a[h];
					c[0] = g[r++], c[1] = g[r++], s(c, c, e), g[p++] = c[0], g[p++] = c[1]
				}
			}
		}
		var o = n(28).CMD,
			r = n(5),
			s = r.applyTransform,
			a = [
				[],
				[],
				[]
			],
			l = Math.sqrt,
			u = Math.atan2;
		t.exports = i
	}, function(t, e, n) {
		if (!n(14).canvasSupported) {
			var i, o = "urn:schemas-microsoft-com:vml",
				r = window,
				s = r.document,
				a = !1;
			try {
				!s.namespaces.zrvml && s.namespaces.add("zrvml", o), i = function(t) {
					return s.createElement("<zrvml:" + t + ' class="zrvml">')
				}
			} catch (l) {
				i = function(t) {
					return s.createElement("<" + t + ' xmlns="' + o + '" class="zrvml">')
				}
			}
			var u = function() {
					if (!a) {
						a = !0;
						var t = s.styleSheets;
						t.length < 31 ? s.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)")
					}
				};
			t.exports = {
				doc: s,
				initVML: u,
				createNode: i
			}
		}
	}, , , function(t, e, n) {
		function i(t, e, n) {
			y.call(this), this.type = t, this.zr = e, this.opt = v.clone(n), this.group = new x.Group, this._containerRect = null, this._track = [], this._dragging, this._cover, this._disabled = !0, this._handlers = {
				mousedown: j(a, this),
				mousemove: j(l, this),
				mouseup: j(u, this)
			}, E(w, function(t) {
				this.zr.on(t, this._handlers[t])
			}, this)
		}
		function o(t) {
			t.traverse(function(t) {
				t.z = b
			})
		}
		function r(t, e) {
			var n = this.group.transformCoordToLocal(t, e);
			return !this._containerRect || this._containerRect.contain(n[0], n[1])
		}
		function s(t) {
			var e = t.event;
			e.preventDefault && e.preventDefault()
		}
		function a(t) {
			if (!(this._disabled || t.target && t.target.draggable)) {
				s(t);
				var e = t.offsetX,
					n = t.offsetY;
				r.call(this, e, n) && (this._dragging = !0, this._track = [
					[e, n]
				])
			}
		}
		function l(t) {
			this._dragging && !this._disabled && (s(t), p.call(this, t))
		}
		function u(t) {
			this._dragging && !this._disabled && (s(t), p.call(this, t, !0), this._dragging = !1, this._track = [])
		}
		function p(t, e) {
			var n = t.offsetX,
				i = t.offsetY;
			if (r.call(this, n, i)) {
				this._track.push([n, i]);
				var o = h.call(this) ? P[this.type].getRanges.call(this) : [];
				c.call(this, o), this.trigger("selected", v.clone(o)), e && this.trigger("selectEnd", v.clone(o))
			}
		}
		function h() {
			var t = this._track;
			if (!t.length) return !1;
			var e = t[t.length - 1],
				n = t[0],
				i = e[0] - n[0],
				o = e[1] - n[1],
				r = S(i * i + o * o, .5);
			return r > L
		}
		function c(t) {
			var e = P[this.type];
			t && t.length ? (this._cover || (this._cover = e.create.call(this), this.group.add(this._cover)), e.update.call(this, t)) : (this.group.remove(this._cover), this._cover = null), o(this.group)
		}
		function g() {
			var t = this.group,
				e = t.parent;
			e && e.remove(t)
		}
		function d() {
			var t = this.opt;
			return new x.Rect({
				style: {
					stroke: t.stroke,
					fill: t.fill,
					lineWidth: t.lineWidth,
					opacity: t.opacity
				}
			})
		}
		function f() {
			return v.map(this._track, function(t) {
				return this.group.transformCoordToLocal(t[0], t[1])
			}, this)
		}
		function m() {
			var t = f.call(this),
				e = t.length - 1;
			return 0 > e && (e = 0), [t[0], t[e]]
		}
		var y = n(21),
			v = n(1),
			x = n(3),
			j = v.bind,
			E = v.each,
			I = Math.min,
			C = Math.max,
			S = Math.pow,
			b = 1e4,
			L = 2,
			w = ["mousedown", "mousemove", "mouseup"];
		i.prototype = {
			constructor: i,
			enable: function(t, e) {
				this._disabled = !1, g.call(this), this._containerRect = e !== !1 ? e || t.getBoundingRect() : null, t.add(this.group)
			},
			update: function(t) {
				c.call(this, t && v.clone(t))
			},
			disable: function() {
				this._disabled = !0, g.call(this)
			},
			dispose: function() {
				this.disable(), E(w, function(t) {
					this.zr.off(t, this._handlers[t])
				}, this)
			}
		}, v.mixin(i, y);
		var P = {
			line: {
				create: d,
				getRanges: function() {
					var t = m.call(this),
						e = I(t[0][0], t[1][0]),
						n = C(t[0][0], t[1][0]);
					return [[e, n]]
				},
				update: function(t) {
					var e = t[0],
						n = this.opt.width;
					this._cover.setShape({
						x: e[0],
						y: -n / 2,
						width: e[1] - e[0],
						height: n
					})
				}
			},
			rect: {
				create: d,
				getRanges: function() {
					var t = m.call(this),
						e = [I(t[1][0], t[0][0]), I(t[1][1], t[0][1])],
						n = [C(t[1][0], t[0][0]), C(t[1][1], t[0][1])];
					return [[
						[e[0], n[0]],
						[e[1], n[1]]
					]]
				},
				update: function(t) {
					var e = t[0];
					this._cover.setShape({
						x: e[0][0],
						y: e[1][0],
						width: e[0][1] - e[0][0],
						height: e[1][1] - e[1][0]
					})
				}
			}
		};
		t.exports = i
	}, , function(t, e, n) {
		function i() {
			this.group = new o.Group, this._symbolEl = new a({
				silent: !0
			})
		}
		var o = n(3),
			r = n(25),
			s = n(1),
			a = o.extendShape({
				shape: {
					points: null,
					sizes: null
				},
				symbolProxy: null,
				buildPath: function(t, e) {
					for (var n = e.points, i = e.sizes, o = this.symbolProxy, r = o.shape, s = 0; s < n.length; s++) {
						var a = n[s],
							l = i[s];
						l[0] < 4 ? t.rect(a[0] - l[0] / 2, a[1] - l[1] / 2, l[0], l[1]) : (r.x = a[0] - l[0] / 2, r.y = a[1] - l[1] / 2, r.width = l[0], r.height = l[1], o.buildPath(t, r))
					}
				}
			}),
			l = i.prototype;
		l.updateData = function(t) {
			this.group.removeAll();
			var e = this._symbolEl,
				n = t.hostModel;
			e.setShape({
				points: t.mapArray(t.getItemLayout),
				sizes: t.mapArray(function(e) {
					var n = t.getItemVisual(e, "symbolSize");
					return s.isArray(n) || (n = [n, n]), n
				})
			}), e.symbolProxy = r.createSymbol(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor, e.useStyle(n.getModel("itemStyle.normal").getItemStyle(["color"]));
			var i = t.getVisual("color");
			i && e.setColor(i), this.group.add(this._symbolEl)
		}, l.updateLayout = function(t) {
			var e = t.getData();
			this._symbolEl.setShape({
				points: e.mapArray(e.getItemLayout)
			})
		}, l.remove = function() {
			this.group.removeAll()
		}, t.exports = i
	}, function(t, e, n) {
		function i(t) {
			return null == t.cpx1 || null == t.cpy1
		}
		var o = n(3),
			r = n(5),
			s = o.Line.prototype,
			a = o.BezierCurve.prototype;
		t.exports = o.extendShape({
			type: "ec-line",
			style: {
				stroke: "#000",
				fill: null
			},
			shape: {
				x1: 0,
				y1: 0,
				x2: 0,
				y2: 0,
				percent: 1,
				cpx1: null,
				cpy1: null
			},
			buildPath: function(t, e) {
				(i(e) ? s : a).buildPath(t, e)
			},
			pointAt: function(t) {
				return i(this.shape) ? s.pointAt.call(this, t) : a.pointAt.call(this, t)
			},
			tangentAt: function(t) {
				var e = this.shape,
					n = i(e) ? [e.x2 - e.x1, e.y2 - e.y1] : a.tangentAt.call(this, t);
				return r.normalize(n, n)
			}
		})
	}, function(t, e, n) {
		var i = n(1),
			o = n(2);
		n(166), n(167), o.registerVisualCoding("chart", i.curry(n(44), "scatter", "circle", null)), o.registerLayout(i.curry(n(53), "scatter")), n(36)
	}, function(t, e, n) {
		"use strict";
		var i = n(35),
			o = n(13);
		t.exports = o.extend({
			type: "series.scatter",
			dependencies: ["grid", "polar"],
			getInitialData: function(t, e) {
				var n = i(t.data, this, e);
				return n
			},
			defaultOption: {
				coordinateSystem: "cartesian2d",
				zlevel: 0,
				z: 2,
				legendHoverLink: !0,
				hoverAnimation: !0,
				xAxisIndex: 0,
				yAxisIndex: 0,
				polarIndex: 0,
				geoIndex: 0,
				symbolSize: 10,
				large: !1,
				largeThreshold: 2e3,
				itemStyle: {
					normal: {
						opacity: .8
					}
				}
			}
		})
	}, function(t, e, n) {
		var i = n(39),
			o = n(163);
		n(2).extendChartView({
			type: "scatter",
			init: function() {
				this._normalSymbolDraw = new i, this._largeSymbolDraw = new o
			},
			render: function(t, e, n) {
				var i = t.getData(),
					o = this._largeSymbolDraw,
					r = this._normalSymbolDraw,
					s = this.group,
					a = t.get("large") && i.count() > t.get("largeThreshold") ? o : r;
				this._symbolDraw = a, a.updateData(i), s.add(a.group), s.remove(a === o ? r.group : o.group)
			},
			updateLayout: function(t) {
				this._symbolDraw.updateLayout(t)
			},
			remove: function(t, e) {
				this._symbolDraw && this._symbolDraw.remove(e, !0)
			}
		})
	}, function(t, e, n) {
		n(100), n(40), n(41), n(174), n(175), n(170), n(171), n(98), n(97)
	}, function(t, e, n) {
		function i(t, e) {
			var n = [1 / 0, -(1 / 0)];
			return u(e, function(e) {
				var i = e.getData();
				i && u(e.coordDimToDataDim(t), function(t) {
					var e = i.getDataExtent(t);
					e[0] < n[0] && (n[0] = e[0]), e[1] > n[1] && (n[1] = e[1])
				})
			}, this), n
		}
		function o(t, e, n) {
			var i = n.getAxisModel(),
				o = i.axis.scale,
				s = [0, 100],
				a = [t.start, t.end],
				h = [];
			return e = e.slice(), r(e, i, o), u(["startValue", "endValue"], function(e) {
				h.push(null != t[e] ? o.parse(t[e]) : null)
			}), u([0, 1], function(t) {
				var n = h[t],
					i = a[t];
				null != i || null == n ? (null == i && (i = s[t]), n = o.parse(l.linearMap(i, s, e, !0))) : i = l.linearMap(n, e, s, !0), h[t] = n, a[t] = i
			}), {
				valueWindow: p(h),
				percentWindow: p(a)
			}
		}
		function r(t, e, n) {
			return u(["min", "max"], function(i, o) {
				var r = e.get(i, !0);
				null != r && (r + "").toLowerCase() !== "data" + i && (t[o] = n.parse(r))
			}), e.get("scale", !0) || (t[0] > 0 && (t[0] = 0), t[1] < 0 && (t[1] = 0)), t
		}
		function s(t, e) {
			var n = t.getAxisModel(),
				i = t._percentWindow,
				o = t._valueWindow;
			if (i) {
				var r = e || 0 === i[0] && 100 === i[1],
					s = !e && l.getPixelPrecision(o, [0, 500]),
					a = !(e || 20 > s && s >= 0),
					u = e || r || a;
				n.setRange && n.setRange(u ? null : +o[0].toFixed(s), u ? null : +o[1].toFixed(s))
			}
		}
		var a = n(1),
			l = n(4),
			u = a.each,
			p = l.asc,
			h = function(t, e, n, i) {
				this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this.ecModel = i, this._dataZoomModel = n
			};
		h.prototype = {
			constructor: h,
			hostedBy: function(t) {
				return this._dataZoomModel === t
			},
			getDataExtent: function() {
				return this._dataExtent.slice()
			},
			getDataValueWindow: function() {
				return this._valueWindow.slice()
			},
			getDataPercentWindow: function() {
				return this._percentWindow.slice()
			},
			getTargetSeriesModels: function() {
				var t = [];
				return this.ecModel.eachSeries(function(e) {
					this._axisIndex === e.get(this._dimName + "AxisIndex") && t.push(e)
				}, this), t
			},
			getAxisModel: function() {
				return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex)
			},
			getOtherAxisModel: function() {
				var t, e, n = this._dimName,
					i = this.ecModel,
					o = this.getAxisModel(),
					r = "x" === n || "y" === n;
				r ? (e = "gridIndex", t = "x" === n ? "y" : "x") : (e = "polarIndex", t = "angle" === n ? "radius" : "angle");
				var s;
				return i.eachComponent(t + "Axis", function(t) {
					(t.get(e) || 0) === (o.get(e) || 0) && (s = t)
				}), s
			},
			reset: function(t) {
				if (t === this._dataZoomModel) {
					var e = this._dataExtent = i(this._dimName, this.getTargetSeriesModels()),
						n = o(t.option, e, this);
					this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, s(this)
				}
			},
			restore: function(t) {
				t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, s(this, !0))
			},
			filterData: function(t) {
				function e(t) {
					return t >= r[0] && t <= r[1]
				}
				if (t === this._dataZoomModel) {
					var n = this._dimName,
						i = this.getTargetSeriesModels(),
						o = t.get("filterMode"),
						r = this._valueWindow,
						s = this.getOtherAxisModel();
					t.get("$fromToolbox") && s && "category" === s.get("type") && (o = "empty"), u(i, function(t) {
						var i = t.getData();
						i && u(t.coordDimToDataDim(n), function(n) {
							"empty" === o ? t.setData(i.map(n, function(t) {
								return e(t) ? t : NaN
							})) : i.filterSelf(n, e)
						})
					})
				}
			}
		}, t.exports = h
	}, function(t, e, n) {
		t.exports = n(40).extend({
			type: "dataZoom.inside",
			defaultOption: {
				zoomLock: !1
			}
		})
	}, function(t, e, n) {
		function i(t, e, n, i) {
			e = e.slice();
			var o = i.axisModels[0];
			if (o) {
				var s = r(t, o, n),
					a = s.signal * (e[1] - e[0]) * s.pixel / s.pixelLength;
				return u(a, e, [0, 100], "rigid"), e
			}
		}
		function o(t, e, n, i, o, a) {
			n = n.slice();
			var l = o.axisModels[0];
			if (l) {
				var u = r(e, l, i),
					p = u.pixel - u.pixelStart,
					h = p / u.pixelLength * (n[1] - n[0]) + n[0];
				return t = Math.max(t, 0), n[0] = (n[0] - h) * t + h, n[1] = (n[1] - h) * t + h, s(n)
			}
		}
		function r(t, e, n) {
			var i = e.axis,
				o = n.rectProvider(),
				r = {};
			return "x" === i.dim ? (r.pixel = t[0], r.pixelLength = o.width, r.pixelStart = o.x, r.signal = i.inverse ? 1 : -1) : (r.pixel = t[1], r.pixelLength = o.height, r.pixelStart = o.y, r.signal = i.inverse ? -1 : 1), r
		}
		function s(t) {
			var e = [0, 100];
			return !(t[0] <= e[1]) && (t[0] = e[1]), !(t[1] <= e[1]) && (t[1] = e[1]), !(t[0] >= e[0]) && (t[0] = e[0]), !(t[1] >= e[0]) && (t[1] = e[0]), t
		}
		var a = n(41),
			l = n(1),
			u = n(71),
			p = n(176),
			h = l.bind,
			c = a.extend({
				type: "dataZoom.inside",
				init: function(t, e) {
					this._range
				},
				render: function(t, e, n, i) {
					c.superApply(this, "render", arguments), p.shouldRecordRange(i, t.id) && (this._range = t.getPercentRange());
					var o = this.getTargetInfo().cartesians,
						r = l.map(o, function(t) {
							return p.generateCoordId(t.model)
						});
					l.each(o, function(e) {
						var i = e.model;
						p.register(n, {
							coordId: p.generateCoordId(i),
							allCoordIds: r,
							coordinateSystem: i.coordinateSystem,
							dataZoomId: t.id,
							throttleRage: t.get("throttle", !0),
							panGetRange: h(this._onPan, this, e),
							zoomGetRange: h(this._onZoom, this, e)
						})
					}, this)
				},
				remove: function() {
					p.unregister(this.api, this.dataZoomModel.id), c.superApply(this, "remove", arguments), this._range = null
				},
				dispose: function() {
					p.unregister(this.api, this.dataZoomModel.id), c.superApply(this, "dispose", arguments), this._range = null
				},
				_onPan: function(t, e, n, o) {
					return this._range = i([n, o], this._range, e, t)
				},
				_onZoom: function(t, e, n, i, r) {
					var s = this.dataZoomModel;
					return s.option.zoomLock ? this._range : this._range = o(1 / n, [i, r], this._range, e, t, s)
				}
			});
		t.exports = c
	}, function(t, e, n) {
		var i = n(40);
		t.exports = i.extend({
			type: "dataZoom.select"
		})
	}, function(t, e, n) {
		t.exports = n(41).extend({
			type: "dataZoom.select"
		})
	}, function(t, e, n) {
		var i = n(40),
			o = i.extend({
				type: "dataZoom.slider",
				layoutMode: "box",
				defaultOption: {
					show: !0,
					right: "ph",
					top: "ph",
					width: "ph",
					height: "ph",
					left: null,
					bottom: null,
					backgroundColor: "rgba(47,69,84,0)",
					dataBackgroundColor: "#ddd",
					fillerColor: "rgba(47,69,84,0.15)",
					handleColor: "rgba(148,164,165,0.95)",
					handleSize: 10,
					labelPrecision: null,
					labelFormatter: null,
					showDetail: !0,
					showDataShadow: "auto",
					realtime: !0,
					zoomLock: !1,
					textStyle: {
						color: "#333"
					}
				},
				mergeOption: function(t) {
					o.superApply(this, "mergeOption", arguments)
				}
			});
		t.exports = o
	}, function(t, e, n) {
		function i(t) {
			return "x" === t ? "y" : "x"
		}
		var o = n(1),
			r = n(3),
			s = n(125),
			a = n(41),
			l = r.Rect,
			u = n(4),
			p = u.linearMap,
			h = n(11),
			c = n(71),
			g = u.asc,
			d = o.bind,
			f = Math.round,
			m = Math.max,
			y = o.each,
			v = 7,
			x = 1,
			j = 30,
			E = "horizontal",
			I = "vertical",
			C = 5,
			S = ["line", "bar", "candlestick", "scatter"],
			b = a.extend({
				type: "dataZoom.slider",
				init: function(t, e) {
					this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._halfHandleSize, this._location, this._dragging, this._dataShadowInfo, this.api = e
				},
				render: function(t, e, n, i) {
					return b.superApply(this, "render", arguments), s.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), this._orient = t.get("orient"), this._halfHandleSize = f(t.get("handleSize") / 2), this.dataZoomModel.get("show") === !1 ? void this.group.removeAll() : (i && "dataZoom" === i.type && i.from === this.uid || this._buildView(), void this._updateView())
				},
				remove: function() {
					b.superApply(this, "remove", arguments), s.clear(this, "_dispatchZoomAction")
				},
				dispose: function() {
					b.superApply(this, "dispose", arguments), s.clear(this, "_dispatchZoomAction")
				},
				_buildView: function() {
					var t = this.group;
					t.removeAll(), this._resetLocation(), this._resetInterval();
					var e = this._displayables.barGroup = new r.Group;
					this._renderBackground(), this._renderDataShadow(), this._renderHandle(), t.add(e), this._positionGroup()
				},
				_resetLocation: function() {
					var t = this.dataZoomModel,
						e = this.api,
						n = this._findCoordRect(),
						i = {
							width: e.getWidth(),
							height: e.getHeight()
						},
						r = this._orient === E ? {
							right: i.width - n.x - n.width,
							top: i.height - j - v,
							width: n.width,
							height: j
						} : {
							right: v,
							top: n.y,
							width: j,
							height: n.height
						},
						s = h.getLayoutParams(t.option);
					o.each(["right", "top", "width", "height"], function(t) {
						"ph" === s[t] && (s[t] = r[t])
					});
					var a = h.getLayoutRect(s, i, t.padding);
					this._location = {
						x: a.x,
						y: a.y
					}, this._size = [a.width, a.height], this._orient === I && this._size.reverse()
				},
				_positionGroup: function() {
					var t = this.group,
						e = this._location,
						n = this._orient,
						i = this.dataZoomModel.getFirstTargetAxisModel(),
						o = i && i.get("inverse"),
						r = this._displayables.barGroup,
						s = (this._dataShadowInfo || {}).otherAxisInverse;
					r.attr(n !== E || o ? n === E && o ? {
						scale: s ? [-1, 1] : [-1, -1]
					} : n !== I || o ? {
						scale: s ? [-1, -1] : [-1, 1],
						rotation: Math.PI / 2
					} : {
						scale: s ? [1, -1] : [1, 1],
						rotation: Math.PI / 2
					} : {
						scale: s ? [1, 1] : [1, -1]
					});
					var a = t.getBoundingRect([r]);
					t.position[0] = e.x - a.x, t.position[1] = e.y - a.y
				},
				_getViewExtent: function() {
					var t = this._halfHandleSize,
						e = m(this._size[0], 4 * t),
						n = [t, e - t];
					return n
				},
				_renderBackground: function() {
					var t = this.dataZoomModel,
						e = this._size;
					this._displayables.barGroup.add(new l({
						silent: !0,
						shape: {
							x: 0,
							y: 0,
							width: e[0],
							height: e[1]
						},
						style: {
							fill: t.get("backgroundColor")
						}
					}))
				},
				_renderDataShadow: function() {
					var t = this._dataShadowInfo = this._prepareDataShadowInfo();
					if (t) {
						var e = this._size,
							n = t.series,
							i = n.getRawData(),
							o = n.getShadowDim ? n.getShadowDim() : t.otherDim,
							s = i.getDataExtent(o),
							a = .3 * (s[1] - s[0]);
						s = [s[0] - a, s[1] + a];
						var l = [0, e[1]],
							u = [0, e[0]],
							h = [
								[e[0], 0],
								[0, 0]
							],
							c = u[1] / (i.count() - 1),
							g = 0,
							d = Math.round(i.count() / e[0]);
						i.each([o], function(t, e) {
							if (d > 0 && e % d) return void(g += c);
							var n = null == t || isNaN(t) || "" === t ? null : p(t, s, l, !0);
							null != n && h.push([g, n]), g += c
						}), this._displayables.barGroup.add(new r.Polyline({
							shape: {
								points: h
							},
							style: {
								fill: this.dataZoomModel.get("dataBackgroundColor"),
								lineWidth: 0
							},
							silent: !0,
							z2: -20
						}))
					}
				},
				_prepareDataShadowInfo: function() {
					var t = this.dataZoomModel,
						e = t.get("showDataShadow");
					if (e !== !1) {
						var n, r = this.ecModel;
						return t.eachTargetAxis(function(s, a) {
							var l = t.getAxisProxy(s.name, a).getTargetSeriesModels();
							o.each(l, function(t) {
								if (!(n || e !== !0 && o.indexOf(S, t.get("type")) < 0)) {
									var l = i(s.name),
										u = r.getComponent(s.axis, a).axis;
									n = {
										thisAxis: u,
										series: t,
										thisDim: s.name,
										otherDim: l,
										otherAxisInverse: t.coordinateSystem.getOtherAxis(u).inverse
									}
								}
							}, this)
						}, this), n
					}
				},
				_renderHandle: function() {
					var t = this._displayables,
						e = t.handles = [],
						n = t.handleLabels = [],
						i = this._displayables.barGroup,
						o = this._size;
					i.add(t.filler = new l({
						draggable: !0,
						cursor: "move",
						drift: d(this._onDragMove, this, "all"),
						ondragend: d(this._onDragEnd, this),
						onmouseover: d(this._showDataInfo, this, !0),
						onmouseout: d(this._showDataInfo, this, !1),
						style: {
							fill: this.dataZoomModel.get("fillerColor"),
							textPosition: "inside"
						}
					})), i.add(new l(r.subPixelOptimizeRect({
						silent: !0,
						shape: {
							x: 0,
							y: 0,
							width: o[0],
							height: o[1]
						},
						style: {
							stroke: this.dataZoomModel.get("dataBackgroundColor"),
							lineWidth: x,
							fill: "rgba(0,0,0,0)"
						}
					}))), y([0, 1], function(t) {
						i.add(e[t] = new l({
							style: {
								fill: this.dataZoomModel.get("handleColor")
							},
							cursor: "move",
							draggable: !0,
							drift: d(this._onDragMove, this, t),
							ondragend: d(this._onDragEnd, this),
							onmouseover: d(this._showDataInfo, this, !0),
							onmouseout: d(this._showDataInfo, this, !1)
						}));
						var o = this.dataZoomModel.textStyleModel;
						this.group.add(n[t] = new r.Text({
							silent: !0,
							invisible: !0,
							style: {
								x: 0,
								y: 0,
								text: "",
								textVerticalAlign: "middle",
								textAlign: "center",
								fill: o.getTextColor(),
								textFont: o.getFont()
							}
						}))
					}, this)
				},
				_resetInterval: function() {
					var t = this._range = this.dataZoomModel.getPercentRange(),
						e = this._getViewExtent();
					this._handleEnds = [p(t[0], [0, 100], e, !0), p(t[1], [0, 100], e, !0)]
				},
				_updateInterval: function(t, e) {
					var n = this._handleEnds,
						i = this._getViewExtent();
					c(e, n, i, "all" === t || this.dataZoomModel.get("zoomLock") ? "rigid" : "cross", t), this._range = g([p(n[0], i, [0, 100], !0), p(n[1], i, [0, 100], !0)])
				},
				_updateView: function() {
					var t = this._displayables,
						e = this._handleEnds,
						n = g(e.slice()),
						i = this._size,
						o = this._halfHandleSize;
					y([0, 1], function(n) {
						var r = t.handles[n];
						r.setShape({
							x: e[n] - o,
							y: -1,
							width: 2 * o,
							height: i[1] + 2,
							r: 1
						})
					}, this), t.filler.setShape({
						x: n[0],
						y: 0,
						width: n[1] - n[0],
						height: this._size[1]
					}), this._updateDataInfo()
				},
				_updateDataInfo: function() {
					function t(t) {
						var e = r.getTransform(n.handles[t], this.group),
							a = r.transformDirection(0 === t ? "right" : "left", e),
							l = this._halfHandleSize + C,
							p = r.applyTransform([u[t] + (0 === t ? -l : l), this._size[1] / 2], e);
						i[t].setStyle({
							x: p[0],
							y: p[1],
							textVerticalAlign: o === E ? "middle" : a,
							textAlign: o === E ? a : "center",
							text: s[t]
						})
					}
					var e = this.dataZoomModel,
						n = this._displayables,
						i = n.handleLabels,
						o = this._orient,
						s = ["", ""];
					if (e.get("showDetail")) {
						var a, l;
						e.eachTargetAxis(function(t, n) {
							a || (a = e.getAxisProxy(t.name, n).getDataValueWindow(), l = this.ecModel.getComponent(t.axis, n).axis)
						}, this), a && (s = [this._formatLabel(a[0], l), this._formatLabel(a[1], l)])
					}
					var u = g(this._handleEnds.slice());
					t.call(this, 0), t.call(this, 1)
				},
				_formatLabel: function(t, e) {
					var n = this.dataZoomModel,
						i = n.get("labelFormatter");
					if (o.isFunction(i)) return i(t);
					var r = n.get("labelPrecision");
					return null != r && "auto" !== r || (r = e.getPixelPrecision()), t = null == t && isNaN(t) ? "" : "category" === e.type || "time" === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(r, 20)), o.isString(i) && (t = i.replace("{value}", t)), t
				},
				_showDataInfo: function(t) {
					t = this._dragging || t;
					var e = this._displayables.handleLabels;
					e[0].attr("invisible", !t), e[1].attr("invisible", !t)
				},
				_onDragMove: function(t, e, n) {
					this._dragging = !0;
					var i = this._applyBarTransform([e, n], !0);
					this._updateInterval(t, i[0]), this._updateView(), this.dataZoomModel.get("realtime") && this._dispatchZoomAction()
				},
				_onDragEnd: function() {
					this._dragging = !1, this._showDataInfo(!1), this._dispatchZoomAction()
				},
				_dispatchZoomAction: function() {
					var t = this._range;
					this.api.dispatchAction({
						type: "dataZoom",
						from: this.uid,
						dataZoomId: this.dataZoomModel.id,
						start: t[0],
						end: t[1]
					})
				},
				_applyBarTransform: function(t, e) {
					var n = this._displayables.barGroup.getLocalTransform();
					return r.applyTransform(t, n, e)
				},
				_findCoordRect: function() {
					var t, e = this.getTargetInfo();
					if (e.cartesians.length) t = e.cartesians[0].model.coordinateSystem.getRect();
					else {
						var n = this.api.getWidth(),
							i = this.api.getHeight();
						t = {
							x: .2 * n,
							y: .2 * i,
							width: .6 * n,
							height: .6 * i
						}
					}
					return t
				}
			});
		t.exports = b
	}, function(t, e, n) {
		function i(t) {
			var e = t.getZr();
			return e[d] || (e[d] = {})
		}
		function o(t, e, n) {
			var i = new h(t.getZr());
			return i.enable(), i.on("pan", g(s, n)), i.on("zoom", g(a, n)), i
		}
		function r(t) {
			p.each(t, function(e, n) {
				e.count || (e.controller.off("pan").off("zoom"), delete t[n])
			})
		}
		function s(t, e, n) {
			l(t, function(i) {
				return i.panGetRange(t.controller, e, n)
			})
		}
		function a(t, e, n, i) {
			l(t, function(o) {
				return o.zoomGetRange(t.controller, e, n, i)
			})
		}
		function l(t, e) {
			var n = [];
			p.each(t.dataZoomInfos, function(t) {
				var i = e(t);
				i && n.push({
					dataZoomId: t.dataZoomId,
					start: i[0],
					end: i[1]
				})
			}), t.dispatchAction(n)
		}
		function u(t, e) {
			t.dispatchAction({
				type: "dataZoom",
				batch: e
			})
		}
		var p = n(1),
			h = n(70),
			c = n(125),
			g = p.curry,
			d = "\0_ec_dataZoom_roams",
			f = {
				register: function(t, e) {
					var n = i(t),
						s = e.dataZoomId,
						a = e.coordId;
					p.each(n, function(t, n) {
						var i = t.dataZoomInfos;
						i[s] && p.indexOf(e.allCoordIds, a) < 0 && (delete i[s], t.count--)
					}), r(n);
					var l = n[a];
					l || (l = n[a] = {
						coordId: a,
						dataZoomInfos: {},
						count: 0
					}, l.controller = o(t, e, l), l.dispatchAction = p.curry(u, t));
					var h = e.coordinateSystem.getRect().clone();
					l.controller.rectProvider = function() {
						return h
					}, c.createOrUpdate(l, "dispatchAction", e.throttleRate, "fixRate"), !l.dataZoomInfos[s] && l.count++, l.dataZoomInfos[s] = e
				},
				unregister: function(t, e) {
					var n = i(t);
					p.each(n, function(t) {
						var n = t.dataZoomInfos;
						n[e] && (delete n[e], t.count--)
					}), r(n)
				},
				shouldRecordRange: function(t, e) {
					if (t && "dataZoom" === t.type && t.batch) for (var n = 0, i = t.batch.length; i > n; n++) if (t.batch[n].dataZoomId === e) return !1;
					return !0
				},
				generateCoordId: function(t) {
					return t.type + "\0_" + t.id
				}
			};
		t.exports = f
	}, function(t, e, n) {
		n(100), n(40), n(41), n(172), n(173), n(98), n(97)
	}, function(t, e, n) {
		n(179), n(181), n(180);
		var i = n(2);
		i.registerProcessor("filter", n(182))
	}, function(t, e, n) {
		"use strict";
		var i = n(1),
			o = n(12),
			r = n(2).extendComponentModel({
				type: "legend",
				dependencies: ["series"],
				layoutMode: {
					type: "box",
					ignoreSize: !0
				},
				init: function(t, e, n) {
					this.mergeDefaultAndTheme(t, n), t.selected = t.selected || {}, this._updateData(n);
					var i = this._data,
						o = this.option.selected;
					if (i[0] && "single" === this.get("selectedMode")) {
						var r = !1;
						for (var s in o) o[s] && (this.select(s), r = !0);
						!r && this.select(i[0].get("name"))
					}
				},
				mergeOption: function(t) {
					r.superCall(this, "mergeOption", t), this._updateData(this.ecModel)
				},
				_updateData: function(t) {
					var e = i.map(this.get("data") || [], function(t) {
						return "string" == typeof t && (t = {
							name: t
						}), new o(t, this, this.ecModel)
					}, this);
					this._data = e;
					var n = i.map(t.getSeries(), function(t) {
						return t.name
					});
					t.eachSeries(function(t) {
						if (t.legendDataProvider) {
							var e = t.legendDataProvider();
							n = n.concat(e.mapArray(e.getName))
						}
					}), this._availableNames = n
				},
				getData: function() {
					return this._data
				},
				select: function(t) {
					var e = this.option.selected,
						n = this.get("selectedMode");
					if ("single" === n) {
						var o = this._data;
						i.each(o, function(t) {
							e[t.get("name")] = !1
						})
					}
					e[t] = !0
				},
				unSelect: function(t) {
					"single" !== this.get("selectedMode") && (this.option.selected[t] = !1)
				},
				toggleSelected: function(t) {
					var e = this.option.selected;
					t in e || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
				},
				isSelected: function(t) {
					var e = this.option.selected;
					return !(t in e && !e[t]) && i.indexOf(this._availableNames, t) >= 0
				},
				defaultOption: {
					zlevel: 0,
					z: 4,
					show: !0,
					orient: "horizontal",
					left: "center",
					top: "top",
					align: "auto",
					backgroundColor: "rgba(0,0,0,0)",
					borderColor: "#ccc",
					borderWidth: 0,
					padding: 5,
					itemGap: 10,
					itemWidth: 25,
					itemHeight: 14,
					textStyle: {
						color: "#333"
					},
					selectedMode: !0
				}
			});
		t.exports = r
	}, function(t, e, n) {
		function i(t, e) {
			e.dispatchAction({
				type: "legendToggleSelect",
				name: t
			})
		}
		function o(t, e, n) {
			t.get("legendHoverLink") && n.dispatchAction({
				type: "highlight",
				seriesName: t.name,
				name: e
			})
		}
		function r(t, e, n) {
			t.get("legendHoverLink") && n.dispatchAction({
				type: "downplay",
				seriesName: t.name,
				name: e
			})
		}
		var s = n(1),
			a = n(25),
			l = n(3),
			u = n(102),
			p = s.curry,
			h = "#ccc";
		t.exports = n(2).extendComponentView({
			type: "legend",
			init: function() {
				this._symbolTypeStore = {}
			},
			render: function(t, e, n) {
				var a = this.group;
				if (a.removeAll(), t.get("show")) {
					var h = t.get("selectedMode"),
						c = t.get("align");
					"auto" === c && (c = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left");
					var g = {};
					s.each(t.getData(), function(s) {
						var u = s.get("name");
						if ("" === u || "\n" === u) return void a.add(new l.Group({
							newline: !0
						}));
						var d = e.getSeriesByName(u)[0];
						if (!g[u]) if (d) {
							var f = d.getData(),
								m = f.getVisual("color");
							"function" == typeof m && (m = m(d.getDataParams(0)));
							var y = f.getVisual("legendSymbol") || "roundRect",
								v = f.getVisual("symbol"),
								x = this._createItem(u, s, t, y, v, c, m, h);
							x.on("click", p(i, u, n)).on("mouseover", p(o, d, "", n)).on("mouseout", p(r, d, "", n)), g[u] = !0
						} else e.eachRawSeries(function(e) {
							if (!g[u] && e.legendDataProvider) {
								var a = e.legendDataProvider(),
									l = a.indexOfName(u);
								if (0 > l) return;
								var d = a.getItemVisual(l, "color"),
									f = "roundRect",
									m = this._createItem(u, s, t, f, null, c, d, h);
								m.on("click", p(i, u, n)).on("mouseover", p(o, e, u, n)).on("mouseout", p(r, e, u, n)), g[u] = !0
							}
						}, this)
					}, this), u.layout(a, t, n), u.addBackground(a, t)
				}
			},
			_createItem: function(t, e, n, i, o, r, s, u) {
				var p = n.get("itemWidth"),
					c = n.get("itemHeight"),
					g = n.isSelected(t),
					d = new l.Group,
					f = e.getModel("textStyle"),
					m = e.get("icon");
				if (i = m || i, d.add(a.createSymbol(i, 0, 0, p, c, g ? s : h)), !m && o && (o !== i || "none" == o)) {
					var y = .8 * c;
					"none" === o && (o = "circle"), d.add(a.createSymbol(o, (p - y) / 2, (c - y) / 2, y, y, g ? s : h))
				}
				var v = "left" === r ? p + 5 : -5,
					x = r,
					j = n.get("formatter");
				"string" == typeof j && j ? t = j.replace("{name}", t) : "function" == typeof j && (t = j(t));
				var E = new l.Text({
					style: {
						text: t,
						x: v,
						y: c / 2,
						fill: g ? f.getTextColor() : h,
						textFont: f.getFont(),
						textAlign: x,
						textVerticalAlign: "middle"
					}
				});
				return d.add(E), d.add(new l.Rect({
					shape: d.getBoundingRect(),
					invisible: !0
				})), d.eachChild(function(t) {
					t.silent = !u
				}), this.group.add(d), l.setHoverStyle(d), d
			}
		})
	}, function(t, e, n) {
		function i(t, e, n) {
			var i, o = {},
				s = "toggleSelected" === t;
			return n.eachComponent("legend", function(n) {
				s && null != i ? n[i ? "select" : "unSelect"](e.name) : (n[t](e.name), i = n.isSelected(e.name));
				var a = n.getData();
				r.each(a, function(t) {
					var e = t.get("name");
					if ("\n" !== e && "" !== e) {
						var i = n.isSelected(e);
						e in o ? o[e] = o[e] && i : o[e] = i
					}
				})
			}), {
				name: e.name,
				selected: o
			}
		}
		var o = n(2),
			r = n(1);
		o.registerAction("legendToggleSelect", "legendselectchanged", r.curry(i, "toggleSelected")), o.registerAction("legendSelect", "legendselected", r.curry(i, "select")), o.registerAction("legendUnSelect", "legendunselected", r.curry(i, "unSelect"))
	}, function(t, e) {
		t.exports = function(t) {
			var e = t.findComponents({
				mainType: "legend"
			});
			e && e.length && t.filterSeries(function(t) {
				for (var n = 0; n < e.length; n++) if (!e[n].isSelected(t.name)) return !1;
				return !0
			})
		}
	}, function(t, e, n) {
		n(185), n(186), n(2).registerPreprocessor(function(t) {
			t.markLine = t.markLine || {}
		})
	}, function(t, e, n) {
		n(187), n(188), n(2).registerPreprocessor(function(t) {
			t.markPoint = t.markPoint || {}
		})
	}, function(t, e, n) {
		function i(t) {
			o.defaultEmphasis(t.label, o.LABEL_OPTIONS)
		}
		var o = n(7),
			r = n(1),
			s = n(2).extendComponentModel({
				type: "markLine",
				dependencies: ["series", "grid", "polar", "geo"],
				init: function(t, e, n, i) {
					this.mergeDefaultAndTheme(t, n), this.mergeOption(t, n, i.createdBySelf, !0)
				},
				mergeOption: function(t, e, n, o) {
					n || e.eachSeries(function(t) {
						var n = t.get("markLine"),
							a = t.markLineModel;
						if (!n || !n.data) return void(t.markLineModel = null);
						if (a) a.mergeOption(n, e, !0);
						else {
							o && i(n), r.each(n.data, function(t) {
								t instanceof Array ? (i(t[0]), i(t[1])) : i(t)
							});
							var l = {
								mainType: "markLine",
								seriesIndex: t.seriesIndex,
								name: t.name,
								createdBySelf: !0
							};
							a = new s(n, this, e, l)
						}
						t.markLineModel = a
					}, this)
				},
				defaultOption: {
					zlevel: 0,
					z: 5,
					symbol: ["circle", "arrow"],
					symbolSize: [8, 16],
					precision: 2,
					tooltip: {
						trigger: "item"
					},
					label: {
						normal: {
							show: !0,
							position: "end"
						},
						emphasis: {
							show: !0
						}
					},
					lineStyle: {
						normal: {
							type: "dashed"
						},
						emphasis: {
							width: 3
						}
					},
					animationEasing: "linear"
				}
			});
		t.exports = s
	}, function(t, e, n) {
		function i(t) {
			return !isNaN(t) && !isFinite(t)
		}
		function o(t, e, n, o) {
			var r = 1 - t,
				s = o.dimensions[t];
			return i(e[r]) && i(n[r]) && e[t] === n[t] && o.getAxis(s).containData(e[t])
		}
		function r(t, e) {
			if ("cartesian2d" === t.type) {
				var n = e[0].coord,
					i = e[1].coord;
				if (n && i && (o(1, n, i, t) || o(0, n, i, t))) return !0
			}
			return f.dataFilter(t, e[0]) && f.dataFilter(t, e[1])
		}
		function s(t, e, n, o, r, s, a) {
			var l, u = s.coordinateSystem,
				p = t.getItemModel(e),
				h = p.get("x"),
				g = p.get("y");
			if (null != h && null != g) l = [c.parsePercent(h, a.getWidth()), c.parsePercent(g, a.getHeight())];
			else {
				if (s.getMarkerPosition) l = s.getMarkerPosition(t.getValues(t.dimensions, e));
				else {
					var d = u.dimensions,
						f = t.get(d[0], e),
						m = t.get(d[1], e);
					l = u.dataToPoint([f, m])
				}
				if ("cartesian2d" === u.type) {
					var y = u.getAxis("x"),
						v = u.getAxis("y"),
						d = u.dimensions;
					i(t.get(d[0], e)) ? l[0] = y.toGlobalCoord(y.getExtent()[n ? 0 : 1]) : i(t.get(d[1], e)) && (l[1] = v.toGlobalCoord(v.getExtent()[n ? 0 : 1]))
				}
			}
			t.setItemLayout(e, l)
		}
		function a(t, e, n) {
			var i;
			i = t ? l.map(t && t.dimensions, function(t) {
				var n = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};
				return n.name = t, n
			}) : [{
				name: "value",
				type: "float"
			}];
			var o = new u(i, n),
				s = new u(i, n),
				a = new u([], n),
				p = l.map(n.get("data"), l.curry(y, e, t, n));
			t && (p = l.filter(p, l.curry(r, t)));
			var h = t ? f.dimValueGetter : function(t) {
					return t.value
				};
			return o.initData(l.map(p, function(t) {
				return t[0]
			}), null, h), s.initData(l.map(p, function(t) {
				return t[1]
			}), null, h), a.initData(l.map(p, function(t) {
				return t[2]
			})), {
				from: o,
				to: s,
				line: a
			}
		}
		var l = n(1),
			u = n(15),
			p = n(9),
			h = n(7),
			c = n(4),
			g = p.addCommas,
			d = p.encodeHTML,
			f = n(103),
			m = n(84),
			y = function(t, e, n, i) {
				var o = t.getData(),
					r = i.type;
				if (!l.isArray(i) && ("min" === r || "max" === r || "average" === r || null != i.xAxis || null != i.yAxis)) {
					var s, a, u;
					if (null != i.yAxis || null != i.xAxis) a = null != i.yAxis ? "y" : "x", s = e.getAxis(a), u = l.retrieve(i.yAxis, i.xAxis);
					else {
						var p = f.getAxisInfo(i, o, e, t);
						a = p.valueDataDim, s = p.valueAxis, u = f.numCalculate(o, a, r)
					}
					var h = "x" === a ? 0 : 1,
						c = 1 - h,
						g = l.clone(i),
						d = {};
					g.type = null, g.coord = [], d.coord = [], g.coord[c] = -(1 / 0), d.coord[c] = 1 / 0;
					var m = n.get("precision");
					m >= 0 && (u = +u.toFixed(m)), g.coord[h] = d.coord[h] = u, i = [g, d,
					{
						type: r,
						valueIndex: i.valueIndex,
						value: u
					}]
				}
				return i = [f.dataTransform(t, i[0]), f.dataTransform(t, i[1]), l.extend({}, i[2])], i[2].type = i[2].type || "", l.merge(i[2], i[0]), l.merge(i[2], i[1]), i
			},
			v = {
				formatTooltip: function(t) {
					var e = this._data,
						n = this.getRawValue(t),
						i = l.isArray(n) ? l.map(n, g).join(", ") : g(n),
						o = e.getName(t);
					return this.name + "<br />" + ((o ? d(o) + " : " : "") + i)
				},
				getData: function() {
					return this._data
				},
				setData: function(t) {
					this._data = t
				}
			};
		l.defaults(v, h.dataFormatMixin), n(2).extendComponentView({
			type: "markLine",
			init: function() {
				this._markLineMap = {}
			},
			render: function(t, e, n) {
				var i = this._markLineMap;
				for (var o in i) i[o].__keep = !1;
				e.eachSeries(function(t) {
					var i = t.markLineModel;
					i && this._renderSeriesML(t, i, e, n)
				}, this);
				for (var o in i) i[o].__keep || this.group.remove(i[o].group)
			},
			updateLayout: function(t, e, n) {
				e.eachSeries(function(t) {
					var e = t.markLineModel;
					if (e) {
						var i = e.getData(),
							o = e.__from,
							r = e.__to;
						o.each(function(e) {
							var a = i.getItemModel(e),
								l = a.get("type"),
								u = a.get("valueIndex");
							s(o, e, !0, l, u, t, n), s(r, e, !1, l, u, t, n)
						}), i.each(function(t) {
							i.setItemLayout(t, [o.getItemLayout(t), r.getItemLayout(t)])
						}), this._markLineMap[t.name].updateLayout()
					}
				}, this)
			},
			_renderSeriesML: function(t, e, n, i) {
				function o(e, n, o, r, a) {
					var l = e.getItemModel(n);
					s(e, n, o, r, a, t, i), e.setItemVisual(n, {
						symbolSize: l.get("symbolSize") || j[o ? 0 : 1],
						symbol: l.get("symbol", !0) || x[o ? 0 : 1],
						color: l.get("itemStyle.normal.color") || p.getVisual("color")
					})
				}
				var r = t.coordinateSystem,
					u = t.name,
					p = t.getData(),
					h = this._markLineMap,
					c = h[u];
				c || (c = h[u] = new m), this.group.add(c.group);
				var g = a(r, t, e),
					d = g.from,
					f = g.to,
					y = g.line;
				e.__from = d, e.__to = f, l.extend(e, v), e.setData(y);
				var x = e.get("symbol"),
					j = e.get("symbolSize");
				l.isArray(x) || (x = [x, x]), "number" == typeof j && (j = [j, j]), g.from.each(function(t) {
					var e = y.getItemModel(t),
						n = e.get("type"),
						i = e.get("valueIndex");
					o(d, t, !0, n, i), o(f, t, !1, n, i)
				}), y.each(function(t) {
					var e = y.getItemModel(t).get("lineStyle.normal.color");
					y.setItemVisual(t, {
						color: e || d.getItemVisual(t, "color")
					}), y.setItemLayout(t, [d.getItemLayout(t), f.getItemLayout(t)]), y.setItemVisual(t, {
						fromSymbolSize: d.getItemVisual(t, "symbolSize"),
						fromSymbol: d.getItemVisual(t, "symbol"),
						toSymbolSize: f.getItemVisual(t, "symbolSize"),
						toSymbol: f.getItemVisual(t, "symbol")
					})
				}), c.updateData(y), g.line.eachItemGraphicEl(function(t, n) {
					t.traverse(function(t) {
						t.dataModel = e
					})
				}), c.__keep = !0
			}
		})
	}, function(t, e, n) {
		function i(t) {
			o.defaultEmphasis(t.label, o.LABEL_OPTIONS)
		}
		var o = n(7),
			r = n(1),
			s = n(2).extendComponentModel({
				type: "markPoint",
				dependencies: ["series", "grid", "polar"],
				init: function(t, e, n, i) {
					this.mergeDefaultAndTheme(t, n), this.mergeOption(t, n, i.createdBySelf, !0)
				},
				mergeOption: function(t, e, n, o) {
					n || e.eachSeries(function(t) {
						var n = t.get("markPoint"),
							a = t.markPointModel;
						if (!n || !n.data) return void(t.markPointModel = null);
						if (a) a.mergeOption(n, e, !0);
						else {
							o && i(n), r.each(n.data, i);
							var l = {
								mainType: "markPoint",
								seriesIndex: t.seriesIndex,
								name: t.name,
								createdBySelf: !0
							};
							a = new s(n, this, e, l)
						}
						t.markPointModel = a
					}, this)
				},
				defaultOption: {
					zlevel: 0,
					z: 5,
					symbol: "pin",
					symbolSize: 50,
					tooltip: {
						trigger: "item"
					},
					label: {
						normal: {
							show: !0,
							position: "inside"
						},
						emphasis: {
							show: !0
						}
					},
					itemStyle: {
						normal: {
							borderWidth: 2
						}
					}
				}
			});
		t.exports = s
	}, function(t, e, n) {
		function i(t, e, n) {
			var i = e.coordinateSystem;
			t.each(function(o) {
				var r, s = t.getItemModel(o),
					a = s.getShallow("x"),
					l = s.getShallow("y");
				if (null != a && null != l) r = [u.parsePercent(a, n.getWidth()), u.parsePercent(l, n.getHeight())];
				else if (e.getMarkerPosition) r = e.getMarkerPosition(t.getValues(t.dimensions, o));
				else if (i) {
					var p = t.get(i.dimensions[0], o),
						h = t.get(i.dimensions[1], o);
					r = i.dataToPoint([p, h])
				}
				t.setItemLayout(o, r)
			})
		}
		function o(t, e, n) {
			var i;
			i = t ? s.map(t && t.dimensions, function(t) {
				var n = e.getData().getDimensionInfo(e.coordDimToDataDim(t)[0]) || {};
				return n.name = t, n
			}) : [{
				name: "value",
				type: "float"
			}];
			var o = new c(i, n),
				r = s.map(n.get("data"), s.curry(g.dataTransform, e));
			return t && (r = s.filter(r, s.curry(g.dataFilter, t))), o.initData(r, null, t ? g.dimValueGetter : function(t) {
				return t.value
			}), o
		}
		var r = n(39),
			s = n(1),
			a = n(9),
			l = n(7),
			u = n(4),
			p = a.addCommas,
			h = a.encodeHTML,
			c = n(15),
			g = n(103),
			d = {
				formatTooltip: function(t) {
					var e = this.getData(),
						n = this.getRawValue(t),
						i = s.isArray(n) ? s.map(n, p).join(", ") : p(n),
						o = e.getName(t);
					return this.name + "<br />" + ((o ? h(o) + " : " : "") + i)
				},
				getData: function() {
					return this._data
				},
				setData: function(t) {
					this._data = t
				}
			};
		s.defaults(d, l.dataFormatMixin), n(2).extendComponentView({
			type: "markPoint",
			init: function() {
				this._symbolDrawMap = {}
			},
			render: function(t, e, n) {
				var i = this._symbolDrawMap;
				for (var o in i) i[o].__keep = !1;
				e.eachSeries(function(t) {
					var e = t.markPointModel;
					e && this._renderSeriesMP(t, e, n)
				}, this);
				for (var o in i) i[o].__keep || (i[o].remove(), this.group.remove(i[o].group))
			},
			updateLayout: function(t, e, n) {
				e.eachSeries(function(t) {
					var e = t.markPointModel;
					e && (i(e.getData(), t, n), this._symbolDrawMap[t.name].updateLayout(e))
				}, this)
			},
			_renderSeriesMP: function(t, e, n) {
				var a = t.coordinateSystem,
					l = t.name,
					u = t.getData(),
					p = this._symbolDrawMap,
					h = p[l];
				h || (h = p[l] = new r);
				var c = o(a, t, e);
				s.mixin(e, d), e.setData(c), i(e.getData(), t, n), c.each(function(t) {
					var n = c.getItemModel(t),
						i = n.getShallow("symbolSize");
					"function" == typeof i && (i = i(e.getRawValue(t), e.getDataParams(t))), c.setItemVisual(t, {
						symbolSize: i,
						color: n.get("itemStyle.normal.color") || u.getVisual("color"),
						symbol: n.getShallow("symbol")
					})
				}), h.updateData(c), this.group.add(h.group), c.eachItemGraphicEl(function(t) {
					t.traverse(function(t) {
						t.dataModel = e
					})
				}), h.__keep = !0
			}
		})
	}, function(t, e, n) {
		"use strict";
		var i = n(2),
			o = n(3),
			r = n(11);
		i.extendComponentModel({
			type: "title",
			layoutMode: {
				type: "box",
				ignoreSize: !0
			},
			defaultOption: {
				zlevel: 0,
				z: 6,
				show: !0,
				text: "",
				target: "blank",
				subtext: "",
				subtarget: "blank",
				left: 0,
				top: 0,
				backgroundColor: "rgba(0,0,0,0)",
				borderColor: "#ccc",
				borderWidth: 0,
				padding: 5,
				itemGap: 10,
				textStyle: {
					fontSize: 18,
					fontWeight: "bolder",
					color: "#333"
				},
				subtextStyle: {
					color: "#aaa"
				}
			}
		}), i.extendComponentView({
			type: "title",
			render: function(t, e, n) {
				if (this.group.removeAll(), t.get("show")) {
					var i = this.group,
						s = t.getModel("textStyle"),
						a = t.getModel("subtextStyle"),
						l = t.get("textAlign"),
						u = new o.Text({
							style: {
								text: t.get("text"),
								textFont: s.getFont(),
								fill: s.getTextColor(),
								textBaseline: "top"
							},
							z2: 10
						}),
						p = u.getBoundingRect(),
						h = t.get("subtext"),
						c = new o.Text({
							style: {
								text: h,
								textFont: a.getFont(),
								fill: a.getTextColor(),
								y: p.height + t.get("itemGap"),
								textBaseline: "top"
							},
							z2: 10
						}),
						g = t.get("link"),
						d = t.get("sublink");
					u.silent = !g, c.silent = !d, g && u.on("click", function() {
						window.open(g, "_" + t.get("target"))
					}), d && c.on("click", function() {
						window.open(d, "_" + t.get("subtarget"))
					}), i.add(u), h && i.add(c);
					var f = i.getBoundingRect(),
						m = t.getBoxLayoutParams();
					m.width = f.width, m.height = f.height;
					var y = r.getLayoutRect(m, {
						width: n.getWidth(),
						height: n.getHeight()
					}, t.get("padding"));
					l || (l = t.get("left") || t.get("right"), "middle" === l && (l = "center"), "right" === l ? y.x += y.width : "center" === l && (y.x += y.width / 2)), i.position = [y.x, y.y], u.setStyle("textAlign", l), c.setStyle("textAlign", l), f = i.getBoundingRect();
					var v = y.margin,
						x = t.getItemStyle(["color", "opacity"]);
					x.fill = t.get("backgroundColor");
					var j = new o.Rect({
						shape: {
							x: f.x - v[3],
							y: f.y - v[0],
							width: f.width + v[1] + v[3],
							height: f.height + v[0] + v[2]
						},
						style: x,
						silent: !0
					});
					o.subPixelOptimizeRect(j), i.add(j)
				}
			}
		})
	}, function(t, e, n) {
		n(191), n(192), n(197), n(195), n(193), n(194), n(196)
	}, function(t, e, n) {
		var i = n(29),
			o = n(1),
			r = n(2).extendComponentModel({
				type: "toolbox",
				layoutMode: {
					type: "box",
					ignoreSize: !0
				},
				mergeDefaultAndTheme: function(t) {
					r.superApply(this, "mergeDefaultAndTheme", arguments), o.each(this.option.feature, function(t, e) {
						var n = i.get(e);
						n && o.merge(t, n.defaultOption)
					})
				},
				defaultOption: {
					show: !0,
					z: 6,
					zlevel: 0,
					orient: "horizontal",
					left: "right",
					top: "top",
					backgroundColor: "transparent",
					borderColor: "#ccc",
					borderWidth: 0,
					padding: 5,
					itemSize: 15,
					itemGap: 8,
					showTitle: !0,
					iconStyle: {
						normal: {
							borderColor: "#666",
							color: "none"
						},
						emphasis: {
							borderColor: "#3E98C5"
						}
					}
				}
			});
		t.exports = r
	}, function(t, e, n) {
		(function(e) {
			function i(t) {
				return 0 === t.indexOf("my")
			}
			var o = n(29),
				r = n(1),
				s = n(3),
				a = n(12),
				l = n(48),
				u = n(102),
				p = n(18);
			t.exports = n(2).extendComponentView({
				type: "toolbox",
				render: function(t, e, n) {
					function h(r, s) {
						var l, u = y[r],
							p = y[s],
							h = f[u],
							g = new a(h, t, t.ecModel);
						if (u && !p) {
							if (i(u)) l = {
								model: g,
								onclick: g.option.onclick,
								featureName: u
							};
							else {
								var d = o.get(u);
								if (!d) return;
								l = new d(g)
							}
							m[u] = l
						} else {
							if (l = m[p], !l) return;
							l.model = g
						}
						return !u && p ? void(l.dispose && l.dispose(e, n)) : !g.get("show") || l.unusable ? void(l.remove && l.remove(e, n)) : (c(g, l, u), g.setIconStatus = function(t, e) {
							var n = this.option,
								i = this.iconPaths;
							n.iconStatus = n.iconStatus || {}, n.iconStatus[t] = e, i[t] && i[t].trigger(e)
						}, void(l.render && l.render(g, e, n)))
					}
					function c(i, o, a) {
						var l = i.getModel("iconStyle"),
							u = o.getIcons ? o.getIcons() : i.get("icon"),
							p = i.get("title") || {};
						if ("string" == typeof u) {
							var h = u,
								c = p;
							u = {}, p = {}, u[a] = h, p[a] = c
						}
						var f = i.iconPaths = {};
						r.each(u, function(a, u) {
							var h = l.getModel("normal").getItemStyle(),
								c = l.getModel("emphasis").getItemStyle(),
								m = {
									x: -d / 2,
									y: -d / 2,
									width: d,
									height: d
								},
								y = 0 === a.indexOf("image://") ? (m.image = a.slice(8), new s.Image({
									style: m
								})) : s.makePath(a.replace("path://", ""), {
									style: h,
									hoverStyle: c,
									rectHover: !0
								}, m, "center");
							s.setHoverStyle(y), t.get("showTitle") && (y.__title = p[u], y.on("mouseover", function() {
								y.setStyle({
									text: p[u],
									textPosition: c.textPosition || "bottom",
									textFill: c.fill || c.stroke || "#000",
									textAlign: c.textAlign || "center"
								})
							}).on("mouseout", function() {
								y.setStyle({
									textFill: null
								})
							})), y.trigger(i.get("iconStatus." + u) || "normal"), g.add(y), y.on("click", r.bind(o.onclick, o, e, n, u)), f[u] = y
						})
					}
					var g = this.group;
					if (g.removeAll(), t.get("show")) {
						var d = +t.get("itemSize"),
							f = t.get("feature") || {},
							m = this._features || (this._features = {}),
							y = [];
						r.each(f, function(t, e) {
							y.push(e)
						}), new l(this._featureNames || [], y).add(h).update(h).remove(r.curry(h, null)).execute(), this._featureNames = y, u.layout(g, t, n), u.addBackground(g, t), g.eachChild(function(t) {
							var e = t.__title,
								i = t.hoverStyle;
							if (i && e) {
								var o = p.getBoundingRect(e, i.font),
									r = t.position[0] + g.position[0],
									s = t.position[1] + g.position[1] + d,
									a = !1;
								s + o.height > n.getHeight() && (i.textPosition = "top", a = !0);
								var l = a ? -5 - o.height : d + 8;
								r + o.width / 2 > n.getWidth() ? (i.textPosition = ["100%", l], i.textAlign = "right") : r - o.width / 2 < 0 && (i.textPosition = [0, l], i.textAlign = "left")
							}
						})
					}
				},
				remove: function(t, e) {
					r.each(this._features, function(n) {
						n.remove && n.remove(t, e)
					}), this.group.removeAll()
				},
				dispose: function(t, e) {
					r.each(this._features, function(n) {
						n.dispose && n.dispose(t, e)
					})
				}
			})
		}).call(e, n(203))
	}, function(t, e, n) {
		function i(t) {
			var e = {},
				n = [],
				i = [];
			return t.eachRawSeries(function(t) {
				var o = t.coordinateSystem;
				if (!o || "cartesian2d" !== o.type && "polar" !== o.type) n.push(t);
				else {
					var r = o.getBaseAxis();
					if ("category" === r.type) {
						var s = r.dim + "_" + r.index;
						e[s] || (e[s] = {
							categoryAxis: r,
							valueAxis: o.getOtherAxis(r),
							series: []
						}, i.push({
							axisDim: r.dim,
							axisIndex: r.index
						})), e[s].series.push(t)
					} else n.push(t)
				}
			}), {
				seriesGroupByCategoryAxis: e,
				other: n,
				meta: i
			}
		}
		function o(t) {
			var e = [];
			return d.each(t, function(t, n) {
				var i = t.categoryAxis,
					o = t.valueAxis,
					r = o.dim,
					s = [" "].concat(d.map(t.series, function(t) {
						return t.name
					})),
					a = [i.model.getCategories()];
				d.each(t.series, function(t) {
					a.push(t.getRawData().mapArray(r, function(t) {
						return t
					}))
				});
				for (var l = [s.join(y)], u = 0; u < a[0].length; u++) {
					for (var p = [], h = 0; h < a.length; h++) p.push(a[h][u]);
					l.push(p.join(y))
				}
				e.push(l.join("\n"))
			}), e.join("\n\n" + m + "\n\n")
		}
		function r(t) {
			return d.map(t, function(t) {
				var e = t.getRawData(),
					n = [t.name],
					i = [];
				return e.each(e.dimensions, function() {
					for (var t = arguments.length, o = arguments[t - 1], r = e.getName(o), s = 0; t - 1 > s; s++) i[s] = arguments[s];
					n.push((r ? r + y : "") + i.join(y))
				}), n.join("\n")
			}).join("\n\n" + m + "\n\n")
		}
		function s(t) {
			var e = i(t);
			return {
				value: d.filter([o(e.seriesGroupByCategoryAxis), r(e.other)], function(t) {
					return t.replace(/[\n\t\s]/g, "")
				}).join("\n\n" + m + "\n\n"),
				meta: e.meta
			}
		}
		function a(t) {
			return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
		}
		function l(t) {
			var e = t.slice(0, t.indexOf("\n"));
			return e.indexOf(y) >= 0 || void 0
		}
		function u(t) {
			for (var e = t.split(/\n+/g), n = a(e.shift()).split(v), i = [], o = d.map(n, function(t) {
				return {
					name: t,
					data: []
				}
			}), r = 0; r < e.length; r++) {
				var s = a(e[r]).split(v);
				i.push(s.shift());
				for (var l = 0; l < s.length; l++) o[l] && (o[l].data[r] = s[l])
			}
			return {
				series: o,
				categories: i
			}
		}
		function p(t) {
			for (var e = t.split(/\n+/g), n = a(e.shift()), i = [], o = 0; o < e.length; o++) {
				var r, s = a(e[o]).split(v),
					l = "",
					u = !1;
				isNaN(s[0]) ? (u = !0, l = s[0], s = s.slice(1), i[o] = {
					name: l,
					value: []
				}, r = i[o].value) : r = i[o] = [];
				for (var p = 0; p < s.length; p++) r.push(+s[p]);
				1 === r.length && (u ? i[o].value = r[0] : i[o] = r[0])
			}
			return {
				name: n,
				data: i
			}
		}
		function h(t, e) {
			var n = t.split(new RegExp("\n*" + m + "\n*", "g")),
				i = {
					series: []
				};
			return d.each(n, function(t, n) {
				if (l(t)) {
					var o = u(t),
						r = e[n],
						s = r.axisDim + "Axis";
					r && (i[s] = i[s] || [], i[s][r.axisIndex] = {
						data: o.categories
					}, i.series = i.series.concat(o.series))
				} else {
					var o = p(t);
					i.series.push(o)
				}
			}), i
		}
		function c(t) {
			this._dom = null, this.model = t
		}
		function g(t, e) {
			return d.map(t, function(t, n) {
				var i = e && e[n];
				return d.isObject(i) && !d.isArray(i) ? (d.isObject(t) && !d.isArray(t) && (t = t.value), d.defaults({
					value: t
				}, i)) : t
			})
		}
		var d = n(1),
			f = n(34),
			m = new Array(60).join("-"),
			y = "\t",
			v = new RegExp("[" + y + "]+", "g");
		c.defaultOption = {
			show: !0,
			readOnly: !1,
			optionToContent: null,
			contentToOption: null,
			icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
			title: "数据视图",
			lang: ["数据视图", "关闭", "刷新"],
			backgroundColor: "#fff",
			textColor: "#000",
			textareaColor: "#fff",
			textareaBorderColor: "#333",
			buttonColor: "#c23531",
			buttonTextColor: "#fff"
		}, c.prototype.onclick = function(t, e) {
			function n() {
				i.removeChild(r), S._dom = null
			}
			var i = e.getDom(),
				o = this.model;
			this._dom && i.removeChild(this._dom);
			var r = document.createElement("div");
			r.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", r.style.backgroundColor = o.get("backgroundColor") || "#fff";
			var a = document.createElement("h4"),
				l = o.get("lang") || [];
			a.innerHTML = l[0] || o.get("title"), a.style.cssText = "margin: 10px 20px;", a.style.color = o.get("textColor");
			var u = document.createElement("div"),
				p = document.createElement("textarea");
			u.style.cssText = "display:block;width:100%;overflow:hidden;";
			var c = o.get("optionToContent"),
				g = o.get("contentToOption"),
				m = s(t);
			if ("function" == typeof c) {
				var v = c(e.getOption());
				"string" == typeof v ? u.innerHTML = v : d.isDom(v) && u.appendChild(v)
			} else u.appendChild(p), p.readOnly = o.get("readOnly"), p.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", p.style.color = o.get("textColor"), p.style.borderColor = o.get("textareaBorderColor"), p.style.backgroundColor = o.get("textareaColor"), p.value = m.value;
			var x = m.meta,
				j = document.createElement("div");
			j.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
			var E = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",
				I = document.createElement("div"),
				C = document.createElement("div");
			E += ";background-color:" + o.get("buttonColor"), E += ";color:" + o.get("buttonTextColor");
			var S = this;
			f.addEventListener(I, "click", n), f.addEventListener(C, "click", function() {
				var t;
				try {
					t = "function" == typeof g ? g(u, e.getOption()) : h(p.value, x)
				} catch (i) {
					throw n(), new Error("Data view format error " + i)
				}
				t && e.dispatchAction({
					type: "changeDataView",
					newOption: t
				}), n()
			}), I.innerHTML = l[1], C.innerHTML = l[2], C.style.cssText = E, I.style.cssText = E, !o.get("readOnly") && j.appendChild(C), j.appendChild(I), f.addEventListener(p, "keydown", function(t) {
				if (9 === (t.keyCode || t.which)) {
					var e = this.value,
						n = this.selectionStart,
						i = this.selectionEnd;
					this.value = e.substring(0, n) + y + e.substring(i), this.selectionStart = this.selectionEnd = n + 1, f.stop(t)
				}
			}), r.appendChild(a), r.appendChild(u), r.appendChild(j), u.style.height = i.clientHeight - 80 + "px", i.appendChild(r), this._dom = r
		}, c.prototype.remove = function(t, e) {
			this._dom && e.getDom().removeChild(this._dom)
		}, c.prototype.dispose = function(t, e) {
			this.remove(t, e)
		}, n(29).register("dataView", c), n(2).registerAction({
			type: "changeDataView",
			event: "dataViewChanged",
			update: "prepareAndUpdate"
		}, function(t, e) {
			var n = [];
			d.each(t.newOption.series, function(t) {
				var i = e.getSeriesByName(t.name)[0];
				if (i) {
					var o = i.get("data");
					n.push({
						name: t.name,
						data: g(t.data, o)
					})
				} else n.push(d.extend({
					type: "scatter"
				}, t))
			}), e.mergeOption(d.defaults({
				series: n
			}, t.newOption))
		}), t.exports = c
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			this.model = t, this._controllerGroup, this._controller, this._isZoomActive
		}
		function o(t, e) {
			var n = [{
				axisModel: t.getAxis("x").model,
				axisIndex: 0
			}, {
				axisModel: t.getAxis("y").model,
				axisIndex: 0
			}];
			return n.grid = t, e.eachComponent({
				mainType: "dataZoom",
				subType: "select"
			}, function(t, i) {
				r("xAxis", n[0].axisModel, t, e) && (n[0].dataZoomModel = t), r("yAxis", n[1].axisModel, t, e) && (n[1].dataZoomModel = t)
			}), n
		}
		function r(t, e, n, i) {
			var o = n.get(t + "Index");
			return null != o && i.getComponent(t, o) === e
		}
		function s(t, e) {
			var n = e.grid,
				i = new c(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]);
			if (i.intersect(n.getRect())) {
				var o = n.getCartesian(e[0].axisIndex, e[1].axisIndex),
					r = o.pointToData([t[0][0], t[1][0]], !0),
					s = o.pointToData([t[0][1], t[1][1]], !0);
				return [y([r[0], s[0]]), y([r[1], s[1]])]
			}
		}
		function a(t, e, n, i) {
			var o = e[n],
				r = o.dataZoomModel;
			return r ? {
				dataZoomId: r.id,
				startValue: t[n][0],
				endValue: t[n][1]
			} : void 0
		}
		function l(t, e) {
			t.setIconStatus("back", d.count(e) > 1 ? "emphasis" : "normal")
		}
		var u = n(1),
			p = n(4),
			h = n(161),
			c = n(8),
			g = n(27),
			d = n(99),
			f = n(101),
			m = u.each,
			y = p.asc;
		n(177);
		var v = "\0_ec_\0toolbox-dataZoom_";
		i.defaultOption = {
			show: !0,
			icon: {
				zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
				back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
			},
			title: {
				zoom: "区域缩放",
				back: "区域缩放还原"
			}
		};
		var x = i.prototype;
		x.render = function(t, e, n) {
			l(t, e)
		}, x.onclick = function(t, e, n) {
			var i = this._controllerGroup;
			this._controllerGroup || (i = this._controllerGroup = new g, e.getZr().add(i)), j[n].call(this, i, this.model, t, e)
		}, x.remove = function(t, e) {
			this._disposeController(), f.release("globalPan", e.getZr())
		}, x.dispose = function(t, e) {
			var n = e.getZr();
			f.release("globalPan", n), this._disposeController(), this._controllerGroup && n.remove(this._controllerGroup)
		};
		var j = {
			zoom: function(t, e, n, i) {
				var o = this._isZoomActive = !this._isZoomActive,
					r = i.getZr();
				f[o ? "take" : "release"]("globalPan", r), e.setIconStatus("zoom", o ? "emphasis" : "normal"), o ? (r.setDefaultCursorStyle("crosshair"), this._createController(t, e, n, i)) : (r.setDefaultCursorStyle("default"), this._disposeController())
			},
			back: function(t, e, n, i) {
				this._dispatchAction(d.pop(n), i)
			}
		};
		x._createController = function(t, e, n, i) {
			var o = this._controller = new h("rect", i.getZr(), {
				lineWidth: 3,
				stroke: "#333",
				fill: "rgba(0,0,0,0.2)"
			});
			o.on("selectEnd", u.bind(this._onSelected, this, o, e, n, i)), o.enable(t, !1)
		}, x._disposeController = function() {
			var t = this._controller;
			t && (t.off("selected"), t.dispose())
		}, x._onSelected = function(t, e, n, i, r) {
			if (r.length) {
				var l = r[0];
				t.update();
				var u = {};
				n.eachComponent("grid", function(t, e) {
					var i = t.coordinateSystem,
						r = o(i, n),
						p = s(l, r);
					if (p) {
						var h = a(p, r, 0, "x"),
							c = a(p, r, 1, "y");
						h && (u[h.dataZoomId] = h), c && (u[c.dataZoomId] = c)
					}
				}, this), d.push(n, u), this._dispatchAction(u, i)
			}
		}, x._dispatchAction = function(t, e) {
			var n = [];
			m(t, function(t) {
				n.push(t)
			}), n.length && e.dispatchAction({
				type: "dataZoom",
				from: this.uid,
				batch: u.clone(n, !0)
			})
		}, n(29).register("dataZoom", i), n(2).registerPreprocessor(function(t) {
			function e(t, e) {
				if (e) {
					var o = t + "Index",
						r = e[o];
					null == r || u.isArray(r) || (r = r === !1 ? [] : [r]), n(t, function(e, n) {
						if (null == r || -1 !== u.indexOf(r, n)) {
							var s = {
								type: "select",
								$fromToolbox: !0,
								id: v + t + n
							};
							s[o] = n, i.push(s)
						}
					})
				}
			}
			function n(e, n) {
				var i = t[e];
				u.isArray(i) || (i = i ? [i] : []), m(i, n)
			}
			if (t) {
				var i = t.dataZoom || (t.dataZoom = []);
				u.isArray(i) || (t.dataZoom = i = [i]);
				var o = t.toolbox;
				if (o && (u.isArray(o) && (o = o[0]), o && o.feature)) {
					var r = o.feature.dataZoom;
					e("xAxis", r), e("yAxis", r)
				}
			}
		}), t.exports = i
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			this.model = t
		}
		var o = n(1);
		i.defaultOption = {
			show: !0,
			type: [],
			icon: {
				line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
				bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
				stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z",
				tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z"
			},
			title: {
				line: "切换为折线图",
				bar: "切换为柱状图",
				stack: "切换为堆叠",
				tiled: "切换为平铺"
			},
			option: {},
			seriesIndex: {}
		};
		var r = i.prototype;
		r.getIcons = function() {
			var t = this.model,
				e = t.get("icon"),
				n = {};
			return o.each(t.get("type"), function(t) {
				e[t] && (n[t] = e[t])
			}), n
		};
		var s = {
			line: function(t, e, n, i) {
				return "bar" === t ? o.merge({
					id: e,
					type: "line",
					data: n.get("data"),
					stack: n.get("stack"),
					markPoint: n.get("markPoint"),
					markLine: n.get("markLine")
				}, i.get("option.line") || {}, !0) : void 0
			},
			bar: function(t, e, n, i) {
				return "line" === t ? o.merge({
					id: e,
					type: "bar",
					data: n.get("data"),
					stack: n.get("stack"),
					markPoint: n.get("markPoint"),
					markLine: n.get("markLine")
				}, i.get("option.bar") || {}, !0) : void 0
			},
			stack: function(t, e, n, i) {
				return "line" === t || "bar" === t ? o.merge({
					id: e,
					stack: "__ec_magicType_stack__"
				}, i.get("option.stack") || {}, !0) : void 0
			},
			tiled: function(t, e, n, i) {
				return "line" === t || "bar" === t ? o.merge({
					id: e,
					stack: ""
				}, i.get("option.tiled") || {}, !0) : void 0
			}
		},
			a = [
				["line", "bar"],
				["stack", "tiled"]
			];
		r.onclick = function(t, e, n) {
			var i = this.model,
				r = i.get("seriesIndex." + n);
			if (s[n]) {
				var l = {
					series: []
				},
					u = function(t) {
						var e = t.subType,
							r = t.id,
							a = s[n](e, r, t, i);
						a && (o.defaults(a, t.option), l.series.push(a));
						var u = t.coordinateSystem;
						if (u && "cartesian2d" === u.type && ("line" === n || "bar" === n)) {
							var p = u.getAxesByScale("ordinal")[0];
							if (p) {
								var h = p.dim,
									c = t.get(h + "AxisIndex"),
									g = h + "Axis";
								l[g] = l[g] || [];
								for (var d = 0; c >= d; d++) l[g][c] = l[g][c] || {};
								l[g][c].boundaryGap = "bar" === n
							}
						}
					};
				o.each(a, function(t) {
					o.indexOf(t, n) >= 0 && o.each(t, function(t) {
						i.setIconStatus(t, "normal")
					})
				}), i.setIconStatus(n, "emphasis"), t.eachComponent({
					mainType: "series",
					query: null == r ? null : {
						seriesIndex: r
					}
				}, u), e.dispatchAction({
					type: "changeMagicType",
					currentType: n,
					newOption: l
				})
			}
		};
		var l = n(2);
		l.registerAction({
			type: "changeMagicType",
			event: "magicTypeChanged",
			update: "prepareAndUpdate"
		}, function(t, e) {
			e.mergeOption(t.newOption)
		}), n(29).register("magicType", i), t.exports = i
	}, function(t, e, n) {
		"use strict";

		function i(t) {
			this.model = t
		}
		var o = n(99);
		i.defaultOption = {
			show: !0,
			icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
			title: "还原"
		};
		var r = i.prototype;
		r.onclick = function(t, e, n) {
			o.clear(t), e.dispatchAction({
				type: "restore",
				from: this.uid
			})
		}, n(29).register("restore", i), n(2).registerAction({
			type: "restore",
			event: "restore",
			update: "prepareAndUpdate"
		}, function(t, e) {
			e.resetOption("recreate")
		}), t.exports = i
	}, function(t, e, n) {
		function i(t) {
			this.model = t
		}
		var o = n(14);
		i.defaultOption = {
			show: !0,
			icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
			title: "保存为图片",
			type: "png",
			name: "",
			excludeComponents: ["toolbox"],
			pixelRatio: 1,
			lang: ["右键另存为图片"]
		}, i.prototype.unusable = !o.canvasSupported;
		var r = i.prototype;
		r.onclick = function(t, e) {
			var n = this.model,
				i = n.get("name") || t.get("title.0.text") || "echarts",
				o = document.createElement("a"),
				r = n.get("type", !0) || "png";
			o.download = i + "." + r, o.target = "_blank";
			var s = e.getConnectedDataURL({
				type: r,
				backgroundColor: n.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
				excludeComponents: n.get("excludeComponents"),
				pixelRatio: n.get("pixelRatio")
			});
			if (o.href = s, "function" == typeof MouseEvent) {
				var a = new MouseEvent("click", {
					view: window,
					bubbles: !0,
					cancelable: !1
				});
				o.dispatchEvent(a)
			} else {
				var l = n.get("lang"),
					u = '<body style="margin:0;"><img src="' + s + '" style="max-width:100%;" title="' + (l && l[0] || "") + '" /></body>',
					p = window.open();
				p.document.write(u)
			}
		}, n(29).register("saveAsImage", i), t.exports = i
	}, function(t, e, n) {
		n(200), n(201), n(2).registerAction({
			type: "showTip",
			event: "showTip",
			update: "none"
		}, function() {}), n(2).registerAction({
			type: "hideTip",
			event: "hideTip",
			update: "none"
		}, function() {})
	}, function(t, e, n) {
		function i(t) {
			var e = "cubic-bezier(0.23, 1, 0.32, 1)",
				n = "left " + t + "s " + e + ",top " + t + "s " + e;
			return l.map(f, function(t) {
				return t + "transition:" + n
			}).join(";")
		}
		function o(t) {
			var e = [],
				n = t.get("fontSize"),
				i = t.getTextColor();
			return i && e.push("color:" + i), e.push("font:" + t.getFont()), n && e.push("line-height:" + Math.round(3 * n / 2) + "px"), c(["decoration", "align"], function(n) {
				var i = t.get(n);
				i && e.push("text-" + n + ":" + i)
			}), e.join(";")
		}
		function r(t) {
			t = t;
			var e = [],
				n = t.get("transitionDuration"),
				r = t.get("backgroundColor"),
				s = t.getModel("textStyle"),
				a = t.get("padding");
			return n && e.push(i(n)), r && (d.canvasSupported ? e.push("background-Color:" + r) : (e.push("background-Color:#" + u.toHex(r)), e.push("filter:alpha(opacity=70)"))), c(["width", "color", "radius"], function(n) {
				var i = "border-" + n,
					o = g(i),
					r = t.get(o);
				null != r && e.push(i + ":" + r + ("color" === n ? "" : "px"))
			}), e.push(o(s)), null != a && e.push("padding:" + h.normalizeCssArray(a).join("px ") + "px"), e.join(";") + ";"
		}
		function s(t, e) {
			var n = document.createElement("div"),
				i = e.getZr();
			this.el = n, this._x = e.getWidth() / 2, this._y = e.getHeight() / 2, t.appendChild(n), this._container = t, this._show = !1, this._hideTimeout;
			var o = this;
			n.onmouseenter = function() {
				o.enterable && (clearTimeout(o._hideTimeout), o._show = !0), o._inContent = !0
			}, n.onmousemove = function(e) {
				if (!o.enterable) {
					var n = i.handler;
					p.normalizeEvent(t, e), n.dispatch("mousemove", e)
				}
			}, n.onmouseleave = function() {
				o.enterable && o._show && o.hideLater(o._hideDelay), o._inContent = !1
			}, a(n, t)
		}
		function a(t, e) {
			function n(t) {
				i(t.target) && t.preventDefault()
			}
			function i(n) {
				for (; n && n !== e;) {
					if (n === t) return !0;
					n = n.parentNode
				}
			}
			p.addEventListener(e, "touchstart", n), p.addEventListener(e, "touchmove", n), p.addEventListener(e, "touchend", n)
		}
		var l = n(1),
			u = n(22),
			p = n(34),
			h = n(9),
			c = l.each,
			g = h.toCamelCase,
			d = n(14),
			f = ["", "-webkit-", "-moz-", "-o-"],
			m = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
		s.prototype = {
			constructor: s,
			enterable: !0,
			update: function() {
				var t = this._container,
					e = t.currentStyle || document.defaultView.getComputedStyle(t),
					n = t.style;
				"absolute" !== n.position && "absolute" !== e.position && (n.position = "relative")
			},
			show: function(t) {
				clearTimeout(this._hideTimeout), this.el.style.cssText = m + r(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), this._show = !0
			},
			setContent: function(t) {
				var e = this.el;
				e.innerHTML = t, e.style.display = t ? "block" : "none"
			},
			moveTo: function(t, e) {
				var n = this.el.style;
				n.left = t + "px", n.top = e + "px", this._x = t, this._y = e
			},
			hide: function() {
				this.el.style.display = "none", this._show = !1
			},
			hideLater: function(t) {
				!this._show || this._inContent && this.enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(l.bind(this.hide, this), t)) : this.hide())
			},
			isShow: function() {
				return this._show
			}
		}, t.exports = s
	}, function(t, e, n) {
		n(2).extendComponentModel({
			type: "tooltip",
			defaultOption: {
				zlevel: 0,
				z: 8,
				show: !0,
				showContent: !0,
				trigger: "item",
				triggerOn: "mousemove",
				alwaysShowContent: !1,
				showDelay: 0,
				hideDelay: 100,
				transitionDuration: .4,
				enterable: !1,
				backgroundColor: "rgba(50,50,50,0.7)",
				borderColor: "#333",
				borderRadius: 4,
				borderWidth: 0,
				padding: 5,
				extraCssText: "",
				axisPointer: {
					type: "line",
					axis: "auto",
					animation: !0,
					animationDurationUpdate: 200,
					animationEasingUpdate: "exponentialOut",
					lineStyle: {
						color: "#555",
						width: 1,
						type: "solid"
					},
					crossStyle: {
						color: "#555",
						width: 1,
						type: "dashed",
						textStyle: {}
					},
					shadowStyle: {
						color: "rgba(150,150,150,0.3)"
					}
				},
				textStyle: {
					color: "#fff",
					fontSize: 14
				}
			}
		})
	}, function(t, e, n) {
		function i(t, e) {
			if (!t || !e) return !1;
			var n = f.round;
			return n(t[0]) === n(e[0]) && n(t[1]) === n(e[1])
		}
		function o(t, e, n, i) {
			return {
				x1: t,
				y1: e,
				x2: n,
				y2: i
			}
		}
		function r(t, e, n, i) {
			return {
				x: t,
				y: e,
				width: n,
				height: i
			}
		}
		function s(t, e, n, i, o, r) {
			return {
				cx: t,
				cy: e,
				r0: n,
				r: i,
				startAngle: o,
				endAngle: r,
				clockwise: !0
			}
		}
		function a(t, e, n, i, o) {
			var r = n.clientWidth,
				s = n.clientHeight,
				a = 20;
			return t + r + a > i ? t -= r + a : t += a, e + s + a > o ? e -= s + a : e += a, [t, e]
		}
		function l(t, e, n) {
			var i = n.clientWidth,
				o = n.clientHeight,
				r = 5,
				s = 0,
				a = 0,
				l = e.width,
				u = e.height;
			switch (t) {
			case "inside":
				s = e.x + l / 2 - i / 2, a = e.y + u / 2 - o / 2;
				break;
			case "top":
				s = e.x + l / 2 - i / 2, a = e.y - o - r;
				break;
			case "bottom":
				s = e.x + l / 2 - i / 2, a = e.y + u + r;
				break;
			case "left":
				s = e.x - i - r, a = e.y + u / 2 - o / 2;
				break;
			case "right":
				s = e.x + l + r, a = e.y + u / 2 - o / 2
			}
			return [s, a]
		}
		function u(t, e, n, i, o, r, s) {
			var u = s.getWidth(),
				p = s.getHeight(),
				h = r && r.getBoundingRect().clone();
			if (r && h.applyTransform(r.transform), "function" == typeof t && (t = t([e, n], o, i.el, h)), g.isArray(t)) e = m(t[0], u), n = m(t[1], p);
			else if ("string" == typeof t && r) {
				var c = l(t, h, i.el);
				e = c[0], n = c[1]
			} else {
				var c = a(e, n, i.el, u, p);
				e = c[0], n = c[1]
			}
			i.moveTo(e, n)
		}
		function p(t) {
			var e = t.coordinateSystem,
				n = t.get("tooltip.trigger", !0);
			return !(!e || "cartesian2d" !== e.type && "polar" !== e.type && "single" !== e.type || "item" === n)
		}
		var h = n(199),
			c = n(3),
			g = n(1),
			d = n(9),
			f = n(4),
			m = f.parsePercent,
			y = n(14);
		n(2).extendComponentView({
			type: "tooltip",
			_axisPointers: {},
			init: function(t, e) {
				if (!y.node) {
					var n = new h(e.getDom(), e);
					this._tooltipContent = n, e.on("showTip", this._manuallyShowTip, this), e.on("hideTip", this._manuallyHideTip, this)
				}
			},
			render: function(t, e, n) {
				if (!y.node) {
					this.group.removeAll(), this._axisPointers = {}, this._tooltipModel = t, this._ecModel = e, this._api = n, this._lastHover = {};
					var i = this._tooltipContent;
					i.update(), i.enterable = t.get("enterable"), this._alwaysShowContent = t.get("alwaysShowContent"), this._seriesGroupByAxis = this._prepareAxisTriggerData(t, e);
					var o = this._crossText;
					if (o && this.group.add(o), null != this._lastX && null != this._lastY) {
						var r = this;
						clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
							r._manuallyShowTip({
								x: r._lastX,
								y: r._lastY
							})
						})
					}
					var s = this._api.getZr();
					s.off("click", this._tryShow), s.off("mousemove", this._mousemove), s.off("mouseout", this._hide), s.off("globalout", this._hide), "click" === t.get("triggerOn") ? s.on("click", this._tryShow, this) : (s.on("mousemove", this._mousemove, this), s.on("mouseout", this._hide, this), s.on("globalout", this._hide, this))
				}
			},
			_mousemove: function(t) {
				var e = this._tooltipModel.get("showDelay"),
					n = this;
				clearTimeout(this._showTimeout), e > 0 ? this._showTimeout = setTimeout(function() {
					n._tryShow(t)
				}, e) : this._tryShow(t)
			},
			_manuallyShowTip: function(t) {
				if (t.from !== this.uid) {
					var e = this._ecModel,
						n = t.seriesIndex,
						i = t.dataIndex,
						o = e.getSeriesByIndex(n),
						r = this._api;
					if (null == t.x || null == t.y) {
						if (o || e.eachSeries(function(t) {
							p(t) && !o && (o = t)
						}), o) {
							var s = o.getData();
							null == i && (i = s.indexOfName(t.name));
							var a, l, u = s.getItemGraphicEl(i),
								h = o.coordinateSystem;
							if (h && h.dataToPoint) {
								var c = h.dataToPoint(s.getValues(g.map(h.dimensions, function(t) {
									return o.coordDimToDataDim(t)[0]
								}), i, !0));
								a = c && c[0], l = c && c[1]
							} else if (u) {
								var d = u.getBoundingRect().clone();
								d.applyTransform(u.transform), a = d.x + d.width / 2, l = d.y + d.height / 2
							}
							null != a && null != l && this._tryShow({
								offsetX: a,
								offsetY: l,
								target: u,
								event: {}
							})
						}
					} else {
						var u = r.getZr().handler.findHover(t.x, t.y);
						this._tryShow({
							offsetX: t.x,
							offsetY: t.y,
							target: u,
							event: {}
						})
					}
				}
			},
			_manuallyHideTip: function(t) {
				t.from !== this.uid && this._hide()
			},
			_prepareAxisTriggerData: function(t, e) {
				var n = {};
				return e.eachSeries(function(t) {
					if (p(t)) {
						var e, i, o = t.coordinateSystem;
						"cartesian2d" === o.type ? (e = o.getBaseAxis(), i = e.dim + e.index) : "single" === o.type ? (e = o.getAxis(), i = e.dim + e.type) : (e = o.getBaseAxis(), i = e.dim + o.name), n[i] = n[i] || {
							coordSys: [],
							series: []
						}, n[i].coordSys.push(o), n[i].series.push(t)
					}
				}, this), n
			},
			_tryShow: function(t) {
				var e = t.target,
					n = this._tooltipModel,
					i = n.get("trigger"),
					o = this._ecModel,
					r = this._api;
				if (n) if (this._lastX = t.offsetX, this._lastY = t.offsetY, e && null != e.dataIndex) {
					var s = e.dataModel || o.getSeriesByIndex(e.seriesIndex),
						a = e.dataIndex,
						l = s.getData().getItemModel(a);
					"axis" === (l.get("tooltip.trigger") || i) ? this._showAxisTooltip(n, o, t) : (this._ticket = "", this._hideAxisPointer(), this._resetLastHover(), this._showItemTooltipContent(s, a, e.dataType, t)), r.dispatchAction({
						type: "showTip",
						from: this.uid,
						dataIndex: e.dataIndex,
						seriesIndex: e.seriesIndex
					})
				} else "item" === i ? this._hide() : this._showAxisTooltip(n, o, t), "cross" === n.get("axisPointer.type") && r.dispatchAction({
					type: "showTip",
					from: this.uid,
					x: t.offsetX,
					y: t.offsetY
				})
			},
			_showAxisTooltip: function(t, e, n) {
				var o = t.getModel("axisPointer"),
					r = o.get("type");
				if ("cross" === r) {
					var s = n.target;
					if (s && null != s.dataIndex) {
						var a = e.getSeriesByIndex(s.seriesIndex),
							l = s.dataIndex;
						this._showItemTooltipContent(a, l, s.dataType, n)
					}
				}
				this._showAxisPointer();
				var u = !0;
				g.each(this._seriesGroupByAxis, function(t) {
					var e = t.coordSys,
						s = e[0],
						a = [n.offsetX, n.offsetY];
					if (!s.containPoint(a)) return void this._hideAxisPointer(s.name);
					u = !1;
					var l = s.dimensions,
						p = s.pointToData(a, !0);
					a = s.dataToPoint(p);
					var h = s.getBaseAxis(),
						c = o.get("axis");
					"auto" === c && (c = h.dim);
					var d = !1,
						f = this._lastHover;
					if ("cross" === r) i(f.data, p) && (d = !0), f.data = p;
					else {
						var m = g.indexOf(l, c);
						f.data === p[m] && (d = !0), f.data = p[m]
					}
					"cartesian2d" !== s.type || d ? "polar" !== s.type || d ? "single" !== s.type || d || this._showSinglePointer(o, s, c, a) : this._showPolarPointer(o, s, c, a) : this._showCartesianPointer(o, s, c, a), "cross" !== r && this._dispatchAndShowSeriesTooltipContent(s, t.series, a, p, d)
				}, this), this._tooltipModel.get("show") || this._hideAxisPointer(), u && this._hide()
			},
			_showCartesianPointer: function(t, e, n, i) {
				function s(n, i, r) {
					var s = "x" === n ? o(i[0], r[0], i[0], r[1]) : o(r[0], i[1], r[1], i[1]),
						a = l._getPointerElement(e, t, n, s);
					p ? c.updateProps(a, {
						shape: s
					}, t) : a.attr({
						shape: s
					})
				}
				function a(n, i, o) {
					var s = e.getAxis(n),
						a = s.getBandWidth(),
						u = o[1] - o[0],
						h = "x" === n ? r(i[0] - a / 2, o[0], a, u) : r(o[0], i[1] - a / 2, u, a),
						g = l._getPointerElement(e, t, n, h);
					p ? c.updateProps(g, {
						shape: h
					}, t) : g.attr({
						shape: h
					})
				}
				var l = this,
					u = t.get("type"),
					p = "cross" !== u;
				if ("cross" === u) s("x", i, e.getAxis("y").getGlobalExtent()), s("y", i, e.getAxis("x").getGlobalExtent()), this._updateCrossText(e, i, t);
				else {
					var h = e.getAxis("x" === n ? "y" : "x"),
						g = h.getGlobalExtent();
					"cartesian2d" === e.type && ("line" === u ? s : a)(n, i, g)
				}
			},
			_showSinglePointer: function(t, e, n, i) {
				function r(n, i, r) {
					var a = e.getAxis(),
						u = a.orient,
						p = "horizontal" === u ? o(i[0], r[0], i[0], r[1]) : o(r[0], i[1], r[1], i[1]),
						h = s._getPointerElement(e, t, n, p);
					l ? c.updateProps(h, {
						shape: p
					}, t) : h.attr({
						shape: p
					})
				}
				var s = this,
					a = t.get("type"),
					l = "cross" !== a,
					u = e.getRect(),
					p = [u.y, u.y + u.height];
				r(n, i, p)
			},
			_showPolarPointer: function(t, e, n, i) {
				function r(n, i, r) {
					var s, a = e.pointToCoord(i);
					if ("angle" === n) {
						var u = e.coordToPoint([r[0], a[1]]),
							p = e.coordToPoint([r[1], a[1]]);
						s = o(u[0], u[1], p[0], p[1])
					} else s = {
						cx: e.cx,
						cy: e.cy,
						r: a[0]
					};
					var h = l._getPointerElement(e, t, n, s);
					g ? c.updateProps(h, {
						shape: s
					}, t) : h.attr({
						shape: s
					})
				}
				function a(n, i, o) {
					var r, a = e.getAxis(n),
						u = a.getBandWidth(),
						p = e.pointToCoord(i),
						h = Math.PI / 180;
					r = "angle" === n ? s(e.cx, e.cy, o[0], o[1], (-p[1] - u / 2) * h, (-p[1] + u / 2) * h) : s(e.cx, e.cy, p[0] - u / 2, p[0] + u / 2, 0, 2 * Math.PI);
					var d = l._getPointerElement(e, t, n, r);
					g ? c.updateProps(d, {
						shape: r
					}, t) : d.attr({
						shape: r
					})
				}
				var l = this,
					u = t.get("type"),
					p = e.getAngleAxis(),
					h = e.getRadiusAxis(),
					g = "cross" !== u;
				if ("cross" === u) r("angle", i, h.getExtent()), r("radius", i, p.getExtent()), this._updateCrossText(e, i, t);
				else {
					var d = e.getAxis("radius" === n ? "angle" : "radius"),
						f = d.getExtent();
					("line" === u ? r : a)(n, i, f)
				}
			},
			_updateCrossText: function(t, e, n) {
				var i = n.getModel("crossStyle"),
					o = i.getModel("textStyle"),
					r = this._tooltipModel,
					s = this._crossText;
				s || (s = this._crossText = new c.Text({
					style: {
						textAlign: "left",
						textVerticalAlign: "bottom"
					}
				}), this.group.add(s));
				var a = t.pointToData(e),
					l = t.dimensions;
				a = g.map(a, function(e, n) {
					var i = t.getAxis(l[n]);
					return e = "category" === i.type || "time" === i.type ? i.scale.getLabel(e) : d.addCommas(e.toFixed(i.getPixelPrecision()))
				}), s.setStyle({
					fill: o.getTextColor() || i.get("color"),
					textFont: o.getFont(),
					text: a.join(", "),
					x: e[0] + 5,
					y: e[1] - 5
				}), s.z = r.get("z"), s.zlevel = r.get("zlevel")
			},
			_getPointerElement: function(t, e, n, i) {
				var o = this._tooltipModel,
					r = o.get("z"),
					s = o.get("zlevel"),
					a = this._axisPointers,
					l = t.name;
				if (a[l] = a[l] || {}, a[l][n]) return a[l][n];
				var u = e.get("type"),
					p = e.getModel(u + "Style"),
					h = "shadow" === u,
					g = p[h ? "getAreaStyle" : "getLineStyle"](),
					d = "polar" === t.type ? h ? "Sector" : "radius" === n ? "Circle" : "Line" : h ? "Rect" : "Line";
				h ? g.stroke = null : g.fill = null;
				var f = a[l][n] = new c[d]({
					style: g,
					z: r,
					zlevel: s,
					silent: !0,
					shape: i
				});
				return this.group.add(f), f
			},
			_dispatchAndShowSeriesTooltipContent: function(t, e, n, i, o) {
				var r = this._tooltipModel,
					s = this._tooltipContent,
					a = t.getBaseAxis(),
					l = g.map(e, function(t) {
						return {
							seriesIndex: t.seriesIndex,
							dataIndex: t.getAxisTooltipDataIndex ? t.getAxisTooltipDataIndex(t.coordDimToDataDim(a.dim), i, a) : t.getData().indexOfNearest(t.coordDimToDataDim(a.dim)[0], i["x" === a.dim || "radius" === a.dim ? 0 : 1])
						}
					}),
					p = this._lastHover,
					h = this._api;
				if (p.payloadBatch && !o && h.dispatchAction({
					type: "downplay",
					batch: p.payloadBatch
				}), o || (h.dispatchAction({
					type: "highlight",
					batch: l
				}), p.payloadBatch = l), h.dispatchAction({
					type: "showTip",
					dataIndex: l[0].dataIndex,
					seriesIndex: l[0].seriesIndex,
					from: this.uid
				}), a && r.get("showContent") && r.get("show")) {
					var c, f = r.get("formatter"),
						m = r.get("position"),
						y = g.map(e, function(t, e) {
							return t.getDataParams(l[e].dataIndex)
						});
					s.show(r);
					var v = l[0].dataIndex;
					if (!o) {
						if (this._ticket = "", f) {
							if ("string" == typeof f) c = d.formatTpl(f, y);
							else if ("function" == typeof f) {
								var x = this,
									j = "axis_" + t.name + "_" + v,
									E = function(t, e) {
										t === x._ticket && (s.setContent(e), u(m, n[0], n[1], s, y, null, h))
									};
								x._ticket = j, c = f(y, j, E)
							}
						} else {
							var I = e[0].getData().getName(v);
							c = (I ? I + "<br />" : "") + g.map(e, function(t, e) {
								return t.formatTooltip(l[e].dataIndex, !0)
							}).join("<br />")
						}
						s.setContent(c)
					}
					u(m, n[0], n[1], s, y, null, h)
				}
			},
			_showItemTooltipContent: function(t, e, n, i) {
				var o = this._api,
					r = t.getData(n),
					s = r.getItemModel(e),
					a = this._tooltipModel,
					l = this._tooltipContent,
					p = s.getModel("tooltip");
				if (p.parentModel ? p.parentModel.parentModel = a : p.parentModel = this._tooltipModel, p.get("showContent") && p.get("show")) {
					var h, c = p.get("formatter"),
						g = p.get("position"),
						f = t.getDataParams(e, n);
					if (c) {
						if ("string" == typeof c) h = d.formatTpl(c, f);
						else if ("function" == typeof c) {
							var m = this,
								y = "item_" + t.name + "_" + e,
								v = function(t, e) {
									t === m._ticket && (l.setContent(e), u(g, i.offsetX, i.offsetY, l, f, i.target, o))
								};
							m._ticket = y, h = c(f, y, v)
						}
					} else h = t.formatTooltip(e, !1, n);
					l.show(p), l.setContent(h), u(g, i.offsetX, i.offsetY, l, f, i.target, o)
				}
			},
			_showAxisPointer: function(t) {
				if (t) {
					var e = this._axisPointers[t];
					e && g.each(e, function(t) {
						t.show()
					})
				} else this.group.eachChild(function(t) {
					t.show()
				}), this.group.show()
			},
			_resetLastHover: function() {
				var t = this._lastHover;
				t.payloadBatch && this._api.dispatchAction({
					type: "downplay",
					batch: t.payloadBatch
				}), this._lastHover = {}
			},
			_hideAxisPointer: function(t) {
				if (t) {
					var e = this._axisPointers[t];
					e && g.each(e, function(t) {
						t.hide()
					})
				} else this.group.hide()
			},
			_hide: function() {
				clearTimeout(this._showTimeout), this._hideAxisPointer(), this._resetLastHover(), this._alwaysShowContent || this._tooltipContent.hideLater(this._tooltipModel.get("hideDelay")), this._api.dispatchAction({
					type: "hideTip",
					from: this.uid
				}), this._lastX = this._lastY = null
			},
			dispose: function(t, e) {
				if (!y.node) {
					var n = e.getZr();
					this._tooltipContent.hide(), n.off("click", this._tryShow), n.off("mousemove", this._mousemove), n.off("mouseout", this._hide), n.off("globalout", this._hide), e.off("showTip", this._manuallyShowTip), e.off("hideTip", this._manuallyHideTip)
				}
			}
		})
	}, , function(t, e) {
		function n() {
			u = !1, s.length ? l = s.concat(l) : p = -1, l.length && i()
		}
		function i() {
			if (!u) {
				var t = setTimeout(n);
				u = !0;
				for (var e = l.length; e;) {
					for (s = l, l = []; ++p < e;) s && s[p].run();
					p = -1, e = l.length
				}
				s = null, u = !1, clearTimeout(t)
			}
		}
		function o(t, e) {
			this.fun = t, this.array = e
		}
		function r() {}
		var s, a = t.exports = {},
			l = [],
			u = !1,
			p = -1;
		a.nextTick = function(t) {
			var e = new Array(arguments.length - 1);
			if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
			l.push(new o(t, e)), 1 !== l.length || u || setTimeout(i, 0)
		}, o.prototype.run = function() {
			this.fun.apply(null, this.array)
		}, a.title = "browser", a.browser = !0, a.env = {}, a.argv = [], a.version = "", a.versions = {}, a.on = r, a.addListener = r, a.once = r, a.off = r, a.removeListener = r, a.removeAllListeners = r, a.emit = r, a.binding = function(t) {
			throw new Error("process.binding is not supported")
		}, a.cwd = function() {
			return "/"
		}, a.chdir = function(t) {
			throw new Error("process.chdir is not supported")
		}, a.umask = function() {
			return 0
		}
	}, function(t, e, n) {
		function i(t) {
			return parseInt(t, 10)
		}
		function o(t, e) {
			a.initVML(), this.root = t, this.storage = e;
			var n = document.createElement("div"),
				i = document.createElement("div");
			n.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", i.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(n), this._vmlRoot = i, this._vmlViewport = n, this.resize();
			var o = e.delFromMap,
				r = e.addToMap;
			e.delFromMap = function(t) {
				var n = e.get(t);
				o.call(e, t), n && n.onRemove && n.onRemove(i)
			}, e.addToMap = function(t) {
				t.onAdd && t.onAdd(i), r.call(e, t)
			}, this._firstPaint = !0
		}
		function r(t) {
			return function() {
				s('In IE8.0 VML mode painter not support method "' + t + '"')
			}
		}
		var s = n(45),
			a = n(158);
		o.prototype = {
			constructor: o,
			getViewportRoot: function() {
				return this._vmlViewport
			},
			refresh: function() {
				var t = this.storage.getDisplayList(!0, !0);
				this._paintList(t)
			},
			_paintList: function(t) {
				for (var e = this._vmlRoot, n = 0; n < t.length; n++) {
					var i = t[n];
					i.invisible || i.ignore ? (i.__alreadyNotVisible || i.onRemove(e), i.__alreadyNotVisible = !0) : (i.__alreadyNotVisible && i.onAdd(e), i.__alreadyNotVisible = !1, i.__dirty && (i.beforeBrush && i.beforeBrush(), (i.brushVML || i.brush).call(i, e), i.afterBrush && i.afterBrush())), i.__dirty = !1
				}
				this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1)
			},
			resize: function() {
				var t = this._getWidth(),
					e = this._getHeight();
				if (this._width != t && this._height != e) {
					this._width = t, this._height = e;
					var n = this._vmlViewport.style;
					n.width = t + "px", n.height = e + "px"
				}
			},
			dispose: function() {
				this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null
			},
			getWidth: function() {
				return this._width
			},
			getHeight: function() {
				return this._height
			},
			_getWidth: function() {
				var t = this.root,
					e = t.currentStyle;
				return (t.clientWidth || i(e.width)) - i(e.paddingLeft) - i(e.paddingRight) | 0
			},
			_getHeight: function() {
				var t = this.root,
					e = t.currentStyle;
				return (t.clientHeight || i(e.height)) - i(e.paddingTop) - i(e.paddingBottom) | 0
			}
		};
		for (var l = ["getLayer", "insertLayer", "eachLayer", "eachBuildinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], u = 0; u < l.length; u++) {
			var p = l[u];
			o.prototype[p] = r(p)
		}
		t.exports = o
	}, function(t, e, n) {
		if (!n(14).canvasSupported) {
			var i = n(5),
				o = n(8),
				r = n(28).CMD,
				s = n(22),
				a = n(18),
				l = n(67),
				u = n(37),
				p = n(46),
				h = n(66),
				c = n(6),
				g = n(17),
				d = n(158),
				f = Math.round,
				m = Math.sqrt,
				y = Math.abs,
				v = Math.cos,
				x = Math.sin,
				j = Math.max,
				E = i.applyTransform,
				I = ",",
				C = "progid:DXImageTransform.Microsoft",
				S = 21600,
				b = S / 2,
				L = 1e5,
				w = 1e3,
				P = function(t) {
					t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = S + "," + S, t.coordorigin = "0,0"
				},
				M = function(t) {
					return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
				},
				_ = function(t, e, n) {
					return "rgb(" + [t, e, n].join(",") + ")"
				},
				N = function(t, e) {
					e && t && e.parentNode !== t && t.appendChild(e)
				},
				A = function(t, e) {
					e && t && e.parentNode === t && t.removeChild(e)
				},
				T = function(t, e, n) {
					return (parseFloat(t) || 0) * L + (parseFloat(e) || 0) * w + n
				},
				R = function(t, e) {
					return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
				},
				O = function(t, e, n) {
					var i = s.parse(e);
					n = +n, isNaN(n) && (n = 1), i && (t.color = _(i[0], i[1], i[2]), t.opacity = n * i[3])
				},
				D = function(t) {
					var e = s.parse(t);
					return [_(e[0], e[1], e[2]), e[3]]
				},
				B = function(t, e, n) {
					var i = e.fill;
					if (null != i) if (i instanceof g) {
						var o, r = 0,
							s = [0, 0],
							a = 0,
							l = 1,
							u = n.getBoundingRect(),
							p = u.width,
							h = u.height;
						if ("linear" === i.type) {
							o = "gradient";
							var c = n.transform,
								d = [i.x * p, i.y * h],
								f = [i.x2 * p, i.y2 * h];
							c && (E(d, d, c), E(f, f, c));
							var m = f[0] - d[0],
								y = f[1] - d[1];
							r = 180 * Math.atan2(m, y) / Math.PI, 0 > r && (r += 360), 1e-6 > r && (r = 0)
						} else {
							o = "gradientradial";
							var d = [i.x * p, i.y * h],
								c = n.transform,
								v = n.scale,
								x = p,
								I = h;
							s = [(d[0] - u.x) / x, (d[1] - u.y) / I], c && E(d, d, c), x /= v[0] * S, I /= v[1] * S;
							var C = j(x, I);
							a = 0 / C, l = 2 * i.r / C - a
						}
						var b = i.colorStops.slice();
						b.sort(function(t, e) {
							return t.offset - e.offset
						});
						for (var L = b.length, w = [], P = [], M = 0; L > M; M++) {
							var _ = b[M],
								N = D(_.color);
							P.push(_.offset * l + a + " " + N[0]), 0 !== M && M !== L - 1 || w.push(N)
						}
						if (L >= 2) {
							var A = w[0][0],
								T = w[1][0],
								R = w[0][1] * e.opacity,
								B = w[1][1] * e.opacity;
							t.type = o, t.method = "none", t.focus = "100%", t.angle = r, t.color = A, t.color2 = T, t.colors = P.join(","), t.opacity = B, t.opacity2 = R
						}
						"radial" === o && (t.focusposition = s.join(","))
					} else O(t, i, e.opacity)
				},
				G = function(t, e) {
					null != e.lineJoin && (t.joinstyle = e.lineJoin), null != e.miterLimit && (t.miterlimit = e.miterLimit * S), null != e.lineCap && (t.endcap = e.lineCap), null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e.stroke || e.stroke instanceof g || O(t, e.stroke, e.opacity)
				},
				F = function(t, e, n, i) {
					var o = "fill" == e,
						r = t.getElementsByTagName(e)[0];
					null != n[e] && "none" !== n[e] && (o || !o && n.lineWidth) ? (t[o ? "filled" : "stroked"] = "true", n[e] instanceof g && A(t, r), r || (r = d.createNode(e)), o ? B(r, n, i) : G(r, n), N(t, r)) : (t[o ? "filled" : "stroked"] = "false", A(t, r))
				},
				k = [
					[],
					[],
					[]
				],
				q = function(t, e) {
					var n, i, o, s, a, l, u = r.M,
						p = r.C,
						h = r.L,
						c = r.A,
						g = r.Q,
						d = [];
					for (s = 0; s < t.length;) {
						switch (o = t[s++], i = "", n = 0, o) {
						case u:
							i = " m ", n = 1, a = t[s++], l = t[s++], k[0][0] = a, k[0][1] = l;
							break;
						case h:
							i = " l ", n = 1, a = t[s++], l = t[s++], k[0][0] = a, k[0][1] = l;
							break;
						case g:
						case p:
							i = " c ", n = 3;
							var y, j, C = t[s++],
								L = t[s++],
								w = t[s++],
								P = t[s++];
							o === g ? (y = w, j = P, w = (w + 2 * C) / 3, P = (P + 2 * L) / 3, C = (a + 2 * C) / 3, L = (l + 2 * L) / 3) : (y = t[s++], j = t[s++]), k[0][0] = C, k[0][1] = L, k[1][0] = w, k[1][1] = P, k[2][0] = y, k[2][1] = j, a = y, l = j;
							break;
						case c:
							var M = 0,
								_ = 0,
								N = 1,
								A = 1,
								T = 0;
							e && (M = e[4], _ = e[5], N = m(e[0] * e[0] + e[1] * e[1]), A = m(e[2] * e[2] + e[3] * e[3]), T = Math.atan2(-e[1] / A, e[0] / N));
							var R = t[s++],
								O = t[s++],
								D = t[s++],
								B = t[s++],
								G = t[s++] + T,
								F = t[s++] + G + T;
							s++;
							var q = t[s++],
								V = R + v(G) * D,
								z = O + x(G) * B,
								C = R + v(F) * D,
								L = O + x(F) * B,
								H = q ? " wa " : " at ";
							Math.abs(V - C) < 1e-10 && (Math.abs(F - G) > .01 ? q && (V += 270 / S) : Math.abs(z - O) < 1e-10 ? q && R > V || !q && V > R ? L -= 270 / S : L += 270 / S : q && O > z || !q && z > O ? C += 270 / S : C -= 270 / S), d.push(H, f(((R - D) * N + M) * S - b), I, f(((O - B) * A + _) * S - b), I, f(((R + D) * N + M) * S - b), I, f(((O + B) * A + _) * S - b), I, f((V * N + M) * S - b), I, f((z * A + _) * S - b), I, f((C * N + M) * S - b), I, f((L * A + _) * S - b)), a = C, l = L;
							break;
						case r.R:
							var U = k[0],
								W = k[1];
							U[0] = t[s++], U[1] = t[s++], W[0] = U[0] + t[s++], W[1] = U[1] + t[s++], e && (E(U, U, e), E(W, W, e)), U[0] = f(U[0] * S - b), W[0] = f(W[0] * S - b), U[1] = f(U[1] * S - b), W[1] = f(W[1] * S - b), d.push(" m ", U[0], I, U[1], " l ", W[0], I, U[1], " l ", W[0], I, W[1], " l ", U[0], I, W[1]);
							break;
						case r.Z:
							d.push(" x ")
						}
						if (n > 0) {
							d.push(i);
							for (var Y = 0; n > Y; Y++) {
								var X = k[Y];
								e && E(X, X, e), d.push(f(X[0] * S - b), I, f(X[1] * S - b), n - 1 > Y ? I : "")
							}
						}
					}
					return d.join("")
				};
			c.prototype.brushVML = function(t) {
				var e = this.style,
					n = this._vmlEl;
				n || (n = d.createNode("shape"), P(n), this._vmlEl = n), F(n, "fill", e, this), F(n, "stroke", e, this);
				var i = this.transform,
					o = null != i,
					r = n.getElementsByTagName("stroke")[0];
				if (r) {
					var s = e.lineWidth;
					if (o && !e.strokeNoScale) {
						var a = i[0] * i[3] - i[1] * i[2];
						s *= m(y(a))
					}
					r.weight = s + "px"
				}
				var l = this.path;
				this.__dirtyPath && (l.beginPath(), this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1), n.path = q(l.data, this.transform), n.style.zIndex = T(this.zlevel, this.z, this.z2), N(t, n), e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t)
			}, c.prototype.onRemove = function(t) {
				A(t, this._vmlEl), this.removeRectText(t)
			}, c.prototype.onAdd = function(t) {
				N(t, this._vmlEl), this.appendRectText(t)
			};
			var V = function(t) {
					return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase()
				};
			p.prototype.brushVML = function(t) {
				var e, n, i = this.style,
					o = i.image;
				if (V(o)) {
					var r = o.src;
					if (r === this._imageSrc) e = this._imageWidth, n = this._imageHeight;
					else {
						var s = o.runtimeStyle,
							a = s.width,
							l = s.height;
						s.width = "auto", s.height = "auto", e = o.width, n = o.height, s.width = a, s.height = l, this._imageSrc = r, this._imageWidth = e, this._imageHeight = n
					}
					o = r
				} else o === this._imageSrc && (e = this._imageWidth, n = this._imageHeight);
				if (o) {
					var u = i.x || 0,
						p = i.y || 0,
						h = i.width,
						c = i.height,
						g = i.sWidth,
						y = i.sHeight,
						v = i.sx || 0,
						x = i.sy || 0,
						S = g && y,
						b = this._vmlEl;
					b || (b = d.doc.createElement("div"), P(b), this._vmlEl = b);
					var L, w = b.style,
						M = !1,
						_ = 1,
						A = 1;
					if (this.transform && (L = this.transform, _ = m(L[0] * L[0] + L[1] * L[1]), A = m(L[2] * L[2] + L[3] * L[3]), M = L[1] || L[2]), M) {
						var R = [u, p],
							O = [u + h, p],
							D = [u, p + c],
							B = [u + h, p + c];
						E(R, R, L), E(O, O, L), E(D, D, L), E(B, B, L);
						var G = j(R[0], O[0], D[0], B[0]),
							F = j(R[1], O[1], D[1], B[1]),
							k = [];
						k.push("M11=", L[0] / _, I, "M12=", L[2] / A, I, "M21=", L[1] / _, I, "M22=", L[3] / A, I, "Dx=", f(u * _ + L[4]), I, "Dy=", f(p * A + L[5])), w.padding = "0 " + f(G) + "px " + f(F) + "px 0", w.filter = C + ".Matrix(" + k.join("") + ", SizingMethod=clip)"
					} else L && (u = u * _ + L[4], p = p * A + L[5]), w.filter = "", w.left = f(u) + "px", w.top = f(p) + "px";
					var q = this._imageEl,
						z = this._cropEl;
					q || (q = d.doc.createElement("div"), this._imageEl = q);
					var H = q.style;
					if (S) {
						if (e && n) H.width = f(_ * e * h / g) + "px", H.height = f(A * n * c / y) + "px";
						else {
							var U = new Image,
								W = this;
							U.onload = function() {
								U.onload = null, e = U.width, n = U.height, H.width = f(_ * e * h / g) + "px", H.height = f(A * n * c / y) + "px", W._imageWidth = e, W._imageHeight = n, W._imageSrc = o
							}, U.src = o
						}
						z || (z = d.doc.createElement("div"), z.style.overflow = "hidden", this._cropEl = z);
						var Y = z.style;
						Y.width = f((h + v * h / g) * _), Y.height = f((c + x * c / y) * A), Y.filter = C + ".Matrix(Dx=" + -v * h / g * _ + ",Dy=" + -x * c / y * A + ")", z.parentNode || b.appendChild(z), q.parentNode != z && z.appendChild(q)
					} else H.width = f(_ * h) + "px", H.height = f(A * c) + "px", b.appendChild(q), z && z.parentNode && (b.removeChild(z), this._cropEl = null);
					var X = "",
						Q = i.opacity;
					1 > Q && (X += ".Alpha(opacity=" + f(100 * Q) + ") "), X += C + ".AlphaImageLoader(src=" + o + ", SizingMethod=scale)", H.filter = X, b.style.zIndex = T(this.zlevel, this.z, this.z2), N(t, b), i.text && this.drawRectText(t, this.getBoundingRect())
				}
			}, p.prototype.onRemove = function(t) {
				A(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t)
			}, p.prototype.onAdd = function(t) {
				N(t, this._vmlEl), this.appendRectText(t)
			};
			var z, H = "normal",
				U = {},
				W = 0,
				Y = 100,
				X = document.createElement("div"),
				Q = function(t) {
					var e = U[t];
					if (!e) {
						W > Y && (W = 0, U = {});
						var n, i = X.style;
						try {
							i.font = t, n = i.fontFamily.split(",")[0]
						} catch (o) {}
						e = {
							style: i.fontStyle || H,
							variant: i.fontVariant || H,
							weight: i.fontWeight || H,
							size: 0 | parseFloat(i.fontSize || 12),
							family: n || "Microsoft YaHei"
						}, U[t] = e, W++
					}
					return e
				};
			a.measureText = function(t, e) {
				var n = d.doc;
				z || (z = n.createElement("div"), z.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", d.doc.body.appendChild(z));
				try {
					z.style.font = e
				} catch (i) {}
				return z.innerHTML = "", z.appendChild(n.createTextNode(t)), {
					width: z.offsetWidth
				}
			};
			for (var Z = new o, K = function(t, e, n, i) {
					var o = this.style,
						r = o.text;
					if (r) {
						var s, l, u = o.textAlign,
							p = Q(o.textFont),
							h = p.style + " " + p.variant + " " + p.weight + " " + p.size + 'px "' + p.family + '"',
							c = o.textBaseline,
							g = o.textVerticalAlign;
						n = n || a.getBoundingRect(r, h, u, c);
						var m = this.transform;
						if (m && !i && (Z.copy(e), Z.applyTransform(m), e = Z), i) s = e.x, l = e.y;
						else {
							var y = o.textPosition,
								v = o.textDistance;
							if (y instanceof Array) s = e.x + R(y[0], e.width), l = e.y + R(y[1], e.height), u = u || "left", c = c || "top";
							else {
								var x = a.adjustTextPositionOnRect(y, e, n, v);
								s = x.x, l = x.y, u = u || x.textAlign, c = c || x.textBaseline
							}
						}
						if (g) {
							switch (g) {
							case "middle":
								l -= n.height / 2;
								break;
							case "bottom":
								l -= n.height
							}
							c = "top"
						}
						var j = p.size;
						switch (c) {
						case "hanging":
						case "top":
							l += j / 1.75;
							break;
						case "middle":
							break;
						default:
							l -= j / 2.25
						}
						switch (u) {
						case "left":
							break;
						case "center":
							s -= n.width / 2;
							break;
						case "right":
							s -= n.width
						}
						var C, S, b, L = d.createNode,
							w = this._textVmlEl;
						w ? (b = w.firstChild, C = b.nextSibling, S = C.nextSibling) : (w = L("line"), C = L("path"), S = L("textpath"), b = L("skew"), S.style["v-text-align"] = "left", P(w), C.textpathok = !0, S.on = !0, w.from = "0 0", w.to = "1000 0.05", N(w, b), N(w, C), N(w, S), this._textVmlEl = w);
						var _ = [s, l],
							A = w.style;
						m && i ? (E(_, _, m), b.on = !0, b.matrix = m[0].toFixed(3) + I + m[2].toFixed(3) + I + m[1].toFixed(3) + I + m[3].toFixed(3) + ",0,0", b.offset = (f(_[0]) || 0) + "," + (f(_[1]) || 0), b.origin = "0 0", A.left = "0px", A.top = "0px") : (b.on = !1, A.left = f(s) + "px", A.top = f(l) + "px"), S.string = M(r);
						try {
							S.style.font = h
						} catch (O) {}
						F(w, "fill", {
							fill: i ? o.fill : o.textFill,
							opacity: o.opacity
						}, this), F(w, "stroke", {
							stroke: i ? o.stroke : o.textStroke,
							opacity: o.opacity,
							lineDash: o.lineDash
						}, this), w.style.zIndex = T(this.zlevel, this.z, this.z2), N(t, w)
					}
				}, J = function(t) {
					A(t, this._textVmlEl), this._textVmlEl = null
				}, $ = function(t) {
					N(t, this._textVmlEl)
				}, tt = [l, u, p, c, h], et = 0; et < tt.length; et++) {
				var nt = tt[et].prototype;
				nt.drawRectText = K, nt.removeRectText = J, nt.appendRectText = $
			}
			h.prototype.brushVML = function(t) {
				var e = this.style;
				e.text ? this.drawRectText(t, {
					x: e.x || 0,
					y: e.y || 0,
					width: 0,
					height: 0
				}, this.getBoundingRect(), !0) : this.removeRectText(t)
			}, h.prototype.onRemove = function(t) {
				this.removeRectText(t)
			}, h.prototype.onAdd = function(t) {
				this.appendRectText(t)
			}
		}
	}, function(t, e, n) {
		n(205), n(68).registerPainter("vml", n(204))
	}])
});
var geoProj = new Cesium.GeographicProjection,
	webMercatorProj = new Cesium.WebMercatorProjection,
	scene = viewer.scene,
	globe = scene.globe,
	ellipsoid = globe.ellipsoid,
	camera = viewer.camera,
	d_polyline, d_polyline2, d_polygon, billboard, pointCollection = new Cesium.PointPrimitiveCollection;
scene.primitives.add(pointCollection);
var movingPolyline = new Cesium.PolylineCollection;
scene.primitives.add(movingPolyline);
var polygonPolyline = new Cesium.PolylineCollection;
scene.primitives.add(polygonPolyline);
var drawing = !1,
	editing = !1,
	vertexMoving = !1,
	movingindex = -1,
	positions = [],
	startPoint, leftClick, dbClick, handler = new Cesium.ScreenSpaceEventHandler(scene.canvas),
	draggingbox = !1,
	startX, startY, startLeft, startTop, startSceneMode, R = 6371e3,
	terrainSamplePositions = [],
	terrainProvider = new Cesium.CesiumTerrainProvider({
		url: "//assets.agi.com/stk-terrain/world"
	}),
	show = !0,
	btn = document.createElement("button");
btn.setAttribute("type", "button"), btn.setAttribute("title", "MeasureBox"), btn.setAttribute("onclick", "toggleMeasureBox()"), btn.setAttribute("class", "cesium-button cesium-toolbar-button"), btn.innerHTML = '<img style="padding:1px;" src="img/ruler.png">', document.getElementsByClassName("cesium-viewer-toolbar")[0].appendChild(btn);
var measureBox = document.createElement("div");
measureBox.setAttribute("id", "measureBox"), measureBox.setAttribute("style", "left:32px;top:32px;"), document.body.appendChild(measureBox);
var boxBody = document.createElement("div");
boxBody.setAttribute("id", "boxBody"), measureBox.appendChild(boxBody);
var boxBody_tit = document.createElement("div");
boxBody_tit.setAttribute("id", "boxBody_tit"), boxBody_tit.setAttribute("onmousedown", "mousedown(event)"), document.body.setAttribute("onmousemove", "mousemove(event)"), boxBody_tit.setAttribute("onmouseup", "mouseup()"), boxBody.appendChild(boxBody_tit);
var closebtn = document.createElement("span");
closebtn.setAttribute("style", "float:left;"), closebtn.innerHTML = '<button type="button" class="cesium-infoBox-close" onclick="toggleMeasureBox()" style="position:relative;top:0;left:10px;">×</button>', boxBody_tit.appendChild(closebtn);
var topTit = document.createElement("p");
topTit.setAttribute("class", "topTit"), topTit.innerHTML = "测量工具", boxBody_tit.appendChild(topTit);
for (var topC0s = ["线条", "路径", "面积", "3D路径", "3D面积"], i = 0; i < topC0s.length; i++) {
	var topC0 = document.createElement("p");
	topC0.setAttribute("class", "topC0"), topC0.innerHTML = topC0s[i], boxBody_tit.appendChild(topC0)
}
var boxBody_cnt = document.createElement("div");
boxBody_cnt.setAttribute("id", "boxBody_cnt"), boxBody.appendChild(boxBody_cnt);
var contents = [
	[{
		id: "lineTip",
		type: "tip",
		description: "鼠标单击开始绘制，再次单击结束绘制"
	}, {
		id: "lineDes",
		type: "description",
		description: "测量地面上两点之间的距离"
	}, {
		id: "gclength",
		type: "a",
		name: "地球长度：",
		unit: ["米", "公里"]
	}, {
		id: "geoplength",
		type: "a",
		name: "地图投影长度：",
		unit: ["米", "公里"]
	}, {
		id: "headingangle",
		type: "a",
		name: "方位角：",
		unit: ["度"]
	}],
	[{
		id: "pathTip",
		type: "tip",
		description: "鼠标单击绘制，双击结束绘制"
	}, {
		id: "pathDes",
		type: "description",
		description: "测量地面上多个点之间的距离"
	}, {
		id: "pathlength",
		type: "a",
		name: "路径长度：",
		unit: ["米", "公里"]
	}, {
		id: "profile",
		type: "checkbox",
		name: "显示海拔剖面图"
	}],
	[{
		id: "areaTip",
		type: "tip",
		description: "鼠标单击绘制，双击结束绘制"
	}, {
		id: "areaDes",
		type: "description",
		description: "测量地面上几何形状的周长和面积"
	}, {
		id: "globeA",
		type: "a",
		name: "面积：",
		unit: ["平方米", "平方公里"]
	}, {
		id: "perimeter",
		type: "a",
		name: "周长：",
		unit: ["米", "公里"]
	}],
	[{
		id: "3DLineTip",
		type: "tip",
		description: "鼠标单击绘制，双击结束绘制"
	}, {
		id: "3DLineDes",
		type: "description",
		description: "测量三维建筑物的高度和宽度，以及从建筑物上的点到地面的距离"
	}, {
		id: "3DLength",
		type: "a",
		name: "长度：",
		unit: ["厘米", "米", "公里"]
	}],
	[{
		id: "3DAreaTip",
		type: "tip",
		description: "鼠标单击绘制，双击结束绘制"
	}, {
		id: "3DAreaDes",
		type: "description",
		description: "测量三维建筑物上几何形状的面积"
	}, {
		id: "3DArea",
		type: "a",
		name: "面积：",
		unit: ["平方厘米", "平方米", "平方公里"]
	}, {
		id: "3DPerimeter",
		type: "a",
		name: "周长：",
		unit: ["厘米", "米", "公里"]
	}]
],
	emptytag = document.createElement("SPAN");
for (boxBody_cnt.appendChild(emptytag), i = 0; i < contents.length; i++) {
	var content = contents[i],
		tag = document.createElement("SPAN");
	boxBody_cnt.appendChild(tag);
	for (var j = 0; j < content.length; j++) {
		if ("a" == content[j].type) {
			tag.innerHTML += "<A>" + content[j].name + '</A><A id="' + content[j].id + '"> </A>';
			var units = content[j].unit,
				selectbox = document.createElement("select");
			selectbox.setAttribute("id", "sb_" + content[j].id), selectbox.setAttribute("onchange", "calc_" + (i + 1) + "(positions)"), selectbox.setAttribute("class", "selectbox"), tag.appendChild(selectbox);
			for (var k = 0; k < units.length; k++) {
				var option = document.createElement("option");
				option.setAttribute("value", units[k]), option.innerHTML = units[k], selectbox.appendChild(option)
			}
		} else "checkbox" == content[j].type ? tag.innerHTML += '<label style="vertical-align:middle;"><input type="checkbox" style="vertical-align:middle;" id="cb_' + content[j].id + '" /> ' + content[j].name + "</label>" : "description" == content[j].type ? tag.innerHTML += '<P><strong style="color:yellow">' + content[j].description + "<strong></P>" : "tip" == content[j].type && (tag.innerHTML += '<P><strong style="color:yellow">提示: ' + content[j].description + "<strong></P>");
		tag.innerHTML += "<BR>"
	}
}
var footer = document.createElement("div");
footer.setAttribute("id", "footer"), boxBody.appendChild(footer), footer.innerHTML += '<label id="mouseControl" style="vertical-align:middle;"><input type="checkbox" id="cb_mouseControl" style="vertical-align:middle;" onchange="toggleMouse(checked)" checked="true" /> 鼠标导航     </label><label id="editVertex" style="vertical-align:middle;"><input type="checkbox" id="cb_edit" style="vertical-align:middle;" onchange="toggleEdit(checked)" /> 编辑节点 <span style="color:yellow;">(此时不可绘制)</span></label><input type="button" id="clearAll" onclick="clearAll()" value=" 清除 " />';
var profileBox = document.createElement("div");
profileBox.setAttribute("id", "profileBox"), document.body.appendChild(profileBox);
var title1 = document.createElement("A");
title1.setAttribute("id", "title1"), title1.innerHTML = "海拔（米）  最大值：   平均值：   最小值：", profileBox.appendChild(title1);
var title2 = document.createElement("A");
title2.setAttribute("id", "title2"), title2.innerHTML = "距离：   坡度（度）：", profileBox.appendChild(title2);
var closebtn2 = document.createElement("A");
closebtn2.setAttribute("class", "closebtn"), closebtn2.innerHTML = '<button type="button" class="cesium-infoBox-close" onclick="toggleProfile()" style="position:relative;top:0;">×</button>', profileBox.appendChild(closebtn2);
var sampleSelect = document.createElement("A");
sampleSelect.setAttribute("id", "sampleSelect"), sampleSelect.innerHTML = "采样点数量：", profileBox.appendChild(sampleSelect);
var sb_interval = document.createElement("select");
sb_interval.setAttribute("id", "sb_interval"), sb_interval.setAttribute("onchange", "drawProfile(positions)"), sb_interval.innerHTML = "<option value=20>20</option><option value=50>50</option><option value=100>100</option>", sampleSelect.appendChild(sb_interval);
var profileBody = document.createElement("div");
profileBody.setAttribute("id", "profileBody"), profileBox.appendChild(profileBody);
var charts = document.createElement("div");
charts.setAttribute("id", "charts");
var winWidth = document.body.clientWidth;
charts.setAttribute("style", "width:" + .99 * winWidth + "px;height:191px;");
var myChart = echarts.init(charts),
	chartOption = {
		tooltip: {
			trigger: "axis"
		},
		grid: {
			top: "3%",
			left: "1%",
			right: "1%",
			bottom: "1%",
			containLabel: !0
		},
		xAxis: [{
			type: "category",
			boundaryGap: !1,
			data: []
		}],
		yAxis: [{
			type: "value",
			axisLabel: {
				formatter: "{value} 米"
			}
		}],
		series: [{
			name: "高度",
			type: "line",
			label: {
				normal: {
					show: !0,
					position: "top"
				}
			},
			areaStyle: {
				normal: {}
			},
			data: []
		}]
	};
myChart.setOption(chartOption), myChart.on("click", function(t) {
	if (console.log(t), viewer.entities.remove(billboard), terrainSamplePositions.length > 0) {
		var e = terrainSamplePositions[t.dataIndex].longitude,
			n = terrainSamplePositions[t.dataIndex].latitude;
		billboard = viewer.entities.add({
			position: Cesium.Cartesian3.fromRadians(e, n),
			billboard: {
				image: "./img/arrow3.png",
				pixelOffset: new Cesium.Cartesian2(0, (-25)),
				scaleByDistance: new Cesium.NearFarScalar(150, 1, 15e6, .5),
				pixelOffsetScaleByDistance: new Cesium.NearFarScalar(1e3, 1, 15e5, .8)
			}
		})
	} else console.log("terrainSamplePositions is empty")
}), profileBody.appendChild(charts), tagNames = ["gclength", "geoplength", "headingangle", "pathlength", "globeA", "perimeter", "3DLength", "3DArea", "3DPerimeter"];
var Tags = document.getElementById("boxBody_tit").getElementsByTagName("p"),
	TagsCnt = document.getElementById("boxBody_cnt").getElementsByTagName("span"),
	len = Tags.length,
	flag = 1;
for (i = 1; i < len; i++) Tags[i].value = i, Tags[i].onclick = function() {
	changeNav(this.value)
}, TagsCnt[i].className = "undis";
Tags[flag].className = "topC1", TagsCnt[flag].className = "dis", window.onresize = windowResize;
var cb_profile = document.getElementById("cb_profile");
cb_profile.setAttribute("onchange", "change_cb(checked)"), scene.morphStart.addEventListener(morphStart), scene.morphComplete.addEventListener(morphComplete);